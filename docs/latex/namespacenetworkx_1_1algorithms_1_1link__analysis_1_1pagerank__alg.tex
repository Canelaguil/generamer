\hypertarget{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg}{}\section{networkx.\+algorithms.\+link\+\_\+analysis.\+pagerank\+\_\+alg Namespace Reference}
\label{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg}\index{networkx.\+algorithms.\+link\+\_\+analysis.\+pagerank\+\_\+alg@{networkx.\+algorithms.\+link\+\_\+analysis.\+pagerank\+\_\+alg}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a348f8656b33900f6fc8b02b4086a691d}{pagerank} (G, alpha=0.\+85, personalization=None, max\+\_\+iter=100, tol=1.\+0e-\/6, nstart=\+None, weight=\char`\"{}weight\char`\"{}, dangling=\+None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a0b713200888595d91f821de76241cc13}{google\+\_\+matrix} (G, alpha=0.\+85, personalization=None, nodelist=None, weight=\char`\"{}weight\char`\"{}, dangling=None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a1497a95c921c7d781b592798eb0156d5}{pagerank\+\_\+numpy} (G, alpha=0.\+85, personalization=None, weight=\char`\"{}weight\char`\"{}, dangling=None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a88318dd05b863d99f9a9a0207182bfe7}{pagerank\+\_\+scipy} (G, alpha=0.\+85, personalization=None, max\+\_\+iter=100, tol=1.\+0e-\/6, nstart=\+None, weight=\char`\"{}weight\char`\"{}, dangling=\+None)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}PageRank analysis of graph structure. \end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a0b713200888595d91f821de76241cc13}\label{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a0b713200888595d91f821de76241cc13}} 
\index{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg@{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg}!google\+\_\+matrix@{google\+\_\+matrix}}
\index{google\+\_\+matrix@{google\+\_\+matrix}!networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg@{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg}}
\subsubsection{\texorpdfstring{google\+\_\+matrix()}{google\_matrix()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+link\+\_\+analysis.\+pagerank\+\_\+alg.\+google\+\_\+matrix (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{alpha = {\ttfamily 0.85},  }\item[{}]{personalization = {\ttfamily None},  }\item[{}]{nodelist = {\ttfamily None},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{dangling = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the Google matrix of the graph.

Parameters
----------
G : graph
  A NetworkX graph.  Undirected graphs will be converted to a directed
  graph with two directed edges for each undirected edge.

alpha : float
  The damping factor.

personalization: dict, optional
  The "personalization vector" consisting of a dictionary with a
  key some subset of graph nodes and personalization value each of those.
  At least one personalization value must be non-zero.
  If not specfiied, a nodes personalization value will be zero.
  By default, a uniform distribution is used.

nodelist : list, optional
  The rows and columns are ordered according to the nodes in nodelist.
  If nodelist is None, then the ordering is produced by G.nodes().

weight : key, optional
  Edge data key to use as weight.  If None weights are set to 1.

dangling: dict, optional
  The outedges to be assigned to any "dangling" nodes, i.e., nodes without
  any outedges. The dict key is the node the outedge points to and the dict
  value is the weight of that outedge. By default, dangling nodes are given
  outedges according to the personalization vector (uniform if not
  specified) This must be selected to result in an irreducible transition
  matrix (see notes below). It may be common to have the dangling dict to
  be the same as the personalization dict.

Returns
-------
A : NumPy matrix
   Google matrix of the graph

Notes
-----
The matrix returned represents the transition matrix that describes the
Markov chain used in PageRank. For PageRank to converge to a unique
solution (i.e., a unique stationary distribution in a Markov chain), the
transition matrix must be irreducible. In other words, it must be that
there exists a path between every pair of nodes in the graph, or else there
is the potential of "rank sinks."

This implementation works with Multi(Di)Graphs. For multigraphs the
weight between two nodes is set to be the sum of all edge weights
between those nodes.

See Also
--------
pagerank, pagerank_numpy, pagerank_scipy
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a348f8656b33900f6fc8b02b4086a691d}\label{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a348f8656b33900f6fc8b02b4086a691d}} 
\index{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg@{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg}!pagerank@{pagerank}}
\index{pagerank@{pagerank}!networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg@{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg}}
\subsubsection{\texorpdfstring{pagerank()}{pagerank()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+link\+\_\+analysis.\+pagerank\+\_\+alg.\+pagerank (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{alpha = {\ttfamily 0.85},  }\item[{}]{personalization = {\ttfamily None},  }\item[{}]{max\+\_\+iter = {\ttfamily 100},  }\item[{}]{tol = {\ttfamily 1.0e-\/6},  }\item[{}]{nstart = {\ttfamily None},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{dangling = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the PageRank of the nodes in the graph.

PageRank computes a ranking of the nodes in the graph G based on
the structure of the incoming links. It was originally designed as
an algorithm to rank web pages.

Parameters
----------
G : graph
  A NetworkX graph.  Undirected graphs will be converted to a directed
  graph with two directed edges for each undirected edge.

alpha : float, optional
  Damping parameter for PageRank, default=0.85.

personalization: dict, optional
  The "personalization vector" consisting of a dictionary with a
  key some subset of graph nodes and personalization value each of those.
  At least one personalization value must be non-zero.
  If not specfiied, a nodes personalization value will be zero.
  By default, a uniform distribution is used.

max_iter : integer, optional
  Maximum number of iterations in power method eigenvalue solver.

tol : float, optional
  Error tolerance used to check convergence in power method solver.

nstart : dictionary, optional
  Starting value of PageRank iteration for each node.

weight : key, optional
  Edge data key to use as weight.  If None weights are set to 1.

dangling: dict, optional
  The outedges to be assigned to any "dangling" nodes, i.e., nodes without
  any outedges. The dict key is the node the outedge points to and the dict
  value is the weight of that outedge. By default, dangling nodes are given
  outedges according to the personalization vector (uniform if not
  specified). This must be selected to result in an irreducible transition
  matrix (see notes under google_matrix). It may be common to have the
  dangling dict to be the same as the personalization dict.


Returns
-------
pagerank : dictionary
   Dictionary of nodes with PageRank as value

Examples
--------
>>> G = nx.DiGraph(nx.path_graph(4))
>>> pr = nx.pagerank(G, alpha=0.9)

Notes
-----
The eigenvector calculation is done by the power iteration method
and has no guarantee of convergence.  The iteration will stop after
an error tolerance of ``len(G) * tol`` has been reached. If the
number of iterations exceed `max_iter`, a
:exc:`networkx.exception.PowerIterationFailedConvergence` exception
is raised.

The PageRank algorithm was designed for directed graphs but this
algorithm does not check if the input graph is directed and will
execute on undirected graphs by converting each edge in the
directed graph to two edges.

See Also
--------
pagerank_numpy, pagerank_scipy, google_matrix

Raises
------
PowerIterationFailedConvergence
    If the algorithm fails to converge to the specified tolerance
    within the specified number of iterations of the power iteration
    method.

References
----------
.. [1] A. Langville and C. Meyer,
   "A survey of eigenvector methods of web information retrieval."
   http://citeseer.ist.psu.edu/713792.html
.. [2] Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,
   The PageRank citation ranking: Bringing order to the Web. 1999
   http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a1497a95c921c7d781b592798eb0156d5}\label{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a1497a95c921c7d781b592798eb0156d5}} 
\index{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg@{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg}!pagerank\+\_\+numpy@{pagerank\+\_\+numpy}}
\index{pagerank\+\_\+numpy@{pagerank\+\_\+numpy}!networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg@{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg}}
\subsubsection{\texorpdfstring{pagerank\+\_\+numpy()}{pagerank\_numpy()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+link\+\_\+analysis.\+pagerank\+\_\+alg.\+pagerank\+\_\+numpy (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{alpha = {\ttfamily 0.85},  }\item[{}]{personalization = {\ttfamily None},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{dangling = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the PageRank of the nodes in the graph.

PageRank computes a ranking of the nodes in the graph G based on
the structure of the incoming links. It was originally designed as
an algorithm to rank web pages.

Parameters
----------
G : graph
  A NetworkX graph.  Undirected graphs will be converted to a directed
  graph with two directed edges for each undirected edge.

alpha : float, optional
  Damping parameter for PageRank, default=0.85.

personalization: dict, optional
  The "personalization vector" consisting of a dictionary with a
  key some subset of graph nodes and personalization value each of those.
  At least one personalization value must be non-zero.
  If not specfiied, a nodes personalization value will be zero.
  By default, a uniform distribution is used.

weight : key, optional
  Edge data key to use as weight.  If None weights are set to 1.

dangling: dict, optional
  The outedges to be assigned to any "dangling" nodes, i.e., nodes without
  any outedges. The dict key is the node the outedge points to and the dict
  value is the weight of that outedge. By default, dangling nodes are given
  outedges according to the personalization vector (uniform if not
  specified) This must be selected to result in an irreducible transition
  matrix (see notes under google_matrix). It may be common to have the
  dangling dict to be the same as the personalization dict.

Returns
-------
pagerank : dictionary
   Dictionary of nodes with PageRank as value.

Examples
--------
>>> G = nx.DiGraph(nx.path_graph(4))
>>> pr = nx.pagerank_numpy(G, alpha=0.9)

Notes
-----
The eigenvector calculation uses NumPy's interface to the LAPACK
eigenvalue solvers.  This will be the fastest and most accurate
for small graphs.

This implementation works with Multi(Di)Graphs. For multigraphs the
weight between two nodes is set to be the sum of all edge weights
between those nodes.

See Also
--------
pagerank, pagerank_scipy, google_matrix

References
----------
.. [1] A. Langville and C. Meyer,
   "A survey of eigenvector methods of web information retrieval."
   http://citeseer.ist.psu.edu/713792.html
.. [2] Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,
   The PageRank citation ranking: Bringing order to the Web. 1999
   http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a88318dd05b863d99f9a9a0207182bfe7}\label{namespacenetworkx_1_1algorithms_1_1link__analysis_1_1pagerank__alg_a88318dd05b863d99f9a9a0207182bfe7}} 
\index{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg@{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg}!pagerank\+\_\+scipy@{pagerank\+\_\+scipy}}
\index{pagerank\+\_\+scipy@{pagerank\+\_\+scipy}!networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg@{networkx\+::algorithms\+::link\+\_\+analysis\+::pagerank\+\_\+alg}}
\subsubsection{\texorpdfstring{pagerank\+\_\+scipy()}{pagerank\_scipy()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+link\+\_\+analysis.\+pagerank\+\_\+alg.\+pagerank\+\_\+scipy (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{alpha = {\ttfamily 0.85},  }\item[{}]{personalization = {\ttfamily None},  }\item[{}]{max\+\_\+iter = {\ttfamily 100},  }\item[{}]{tol = {\ttfamily 1.0e-\/6},  }\item[{}]{nstart = {\ttfamily None},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{dangling = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the PageRank of the nodes in the graph.

PageRank computes a ranking of the nodes in the graph G based on
the structure of the incoming links. It was originally designed as
an algorithm to rank web pages.

Parameters
----------
G : graph
  A NetworkX graph.  Undirected graphs will be converted to a directed
  graph with two directed edges for each undirected edge.

alpha : float, optional
  Damping parameter for PageRank, default=0.85.

personalization: dict, optional
  The "personalization vector" consisting of a dictionary with a
  key some subset of graph nodes and personalization value each of those.
  At least one personalization value must be non-zero.
  If not specfiied, a nodes personalization value will be zero.
  By default, a uniform distribution is used.

max_iter : integer, optional
  Maximum number of iterations in power method eigenvalue solver.

tol : float, optional
  Error tolerance used to check convergence in power method solver.

nstart : dictionary, optional
  Starting value of PageRank iteration for each node.

weight : key, optional
  Edge data key to use as weight.  If None weights are set to 1.

dangling: dict, optional
  The outedges to be assigned to any "dangling" nodes, i.e., nodes without
  any outedges. The dict key is the node the outedge points to and the dict
  value is the weight of that outedge. By default, dangling nodes are given
  outedges according to the personalization vector (uniform if not
  specified) This must be selected to result in an irreducible transition
  matrix (see notes under google_matrix). It may be common to have the
  dangling dict to be the same as the personalization dict.

Returns
-------
pagerank : dictionary
   Dictionary of nodes with PageRank as value

Examples
--------
>>> G = nx.DiGraph(nx.path_graph(4))
>>> pr = nx.pagerank_scipy(G, alpha=0.9)

Notes
-----
The eigenvector calculation uses power iteration with a SciPy
sparse matrix representation.

This implementation works with Multi(Di)Graphs. For multigraphs the
weight between two nodes is set to be the sum of all edge weights
between those nodes.

See Also
--------
pagerank, pagerank_numpy, google_matrix

Raises
------
PowerIterationFailedConvergence
    If the algorithm fails to converge to the specified tolerance
    within the specified number of iterations of the power iteration
    method.

References
----------
.. [1] A. Langville and C. Meyer,
   "A survey of eigenvector methods of web information retrieval."
   http://citeseer.ist.psu.edu/713792.html
.. [2] Page, Lawrence; Brin, Sergey; Motwani, Rajeev and Winograd, Terry,
   The PageRank citation ranking: Bringing order to the Web. 1999
   http://dbpubs.stanford.edu:8090/pub/showDoc.Fulltext?lang=en&doc=1999-66&format=pdf
\end{DoxyVerb}
 