\hypertarget{namespacenumpy_1_1lib_1_1utils}{}\section{numpy.\+lib.\+utils Namespace Reference}
\label{namespacenumpy_1_1lib_1_1utils}\index{numpy.\+lib.\+utils@{numpy.\+lib.\+utils}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnumpy_1_1lib_1_1utils_1_1__Deprecate}{\+\_\+\+Deprecate}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1utils_af88a4119737ebfe13e2d9b9eb50a09c5}{get\+\_\+include} ()
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1utils_a8ae7926cae438885f67fcbe036308672}{deprecate} (args, kwargs)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1utils_ad068e6779e539248b179200225a11910}{deprecate\+\_\+with\+\_\+doc} (\hyperlink{namespacenumpy_ab96122eb8e44294b488b0ef93ec27d38}{msg})
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1utils_a2f515d59bad0ace5083748a31b82155f}{byte\+\_\+bounds} (a)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1utils_a26df04e9904b2e3349eaff91896cc156}{who} (vardict=None)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1utils_a20bd9fdff36ab4476ff840623e0e62f9}{info} (object=None, maxwidth=76, output=sys.\+stdout, toplevel=\textquotesingle{}numpy\textquotesingle{})
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1utils_a95d697b2cd971f6f15b6d6643afd0fae}{source} (object, output=sys.\+stdout)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1utils_ad34dd70d113be622ed9a750e9c99de9a}{lookfor} (what, module=None, import\+\_\+modules=True, regenerate=False, output=None)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1utils_a5439fed5d1eee86e9616441b8bdda46e}{safe\+\_\+eval} (\hyperlink{namespacenumpy_1_1lib_1_1utils_a95d697b2cd971f6f15b6d6643afd0fae}{source})
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenumpy_1_1lib_1_1utils_a2f515d59bad0ace5083748a31b82155f}\label{namespacenumpy_1_1lib_1_1utils_a2f515d59bad0ace5083748a31b82155f}} 
\index{numpy\+::lib\+::utils@{numpy\+::lib\+::utils}!byte\+\_\+bounds@{byte\+\_\+bounds}}
\index{byte\+\_\+bounds@{byte\+\_\+bounds}!numpy\+::lib\+::utils@{numpy\+::lib\+::utils}}
\subsubsection{\texorpdfstring{byte\+\_\+bounds()}{byte\_bounds()}}
{\footnotesize\ttfamily def numpy.\+lib.\+utils.\+byte\+\_\+bounds (\begin{DoxyParamCaption}\item[{}]{a }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns pointers to the end-points of an array.

Parameters
----------
a : ndarray
    Input array. It must conform to the Python-side of the array
    interface.

Returns
-------
(low, high) : tuple of 2 integers
    The first integer is the first byte of the array, the second
    integer is just past the last byte of the array.  If `a` is not
    contiguous it will not use every byte between the (`low`, `high`)
    values.

Examples
--------
>>> I = np.eye(2, dtype='f'); I.dtype
dtype('float32')
>>> low, high = np.byte_bounds(I)
>>> high - low == I.size*I.itemsize
True
>>> I = np.eye(2); I.dtype
dtype('float64')
>>> low, high = np.byte_bounds(I)
>>> high - low == I.size*I.itemsize
True\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1utils_a8ae7926cae438885f67fcbe036308672}\label{namespacenumpy_1_1lib_1_1utils_a8ae7926cae438885f67fcbe036308672}} 
\index{numpy\+::lib\+::utils@{numpy\+::lib\+::utils}!deprecate@{deprecate}}
\index{deprecate@{deprecate}!numpy\+::lib\+::utils@{numpy\+::lib\+::utils}}
\subsubsection{\texorpdfstring{deprecate()}{deprecate()}}
{\footnotesize\ttfamily def numpy.\+lib.\+utils.\+deprecate (\begin{DoxyParamCaption}\item[{}]{args,  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Issues a DeprecationWarning, adds warning to `old_name`'s
docstring, rebinds ``old_name.__name__`` and returns the new
function object.

This function may also be used as a decorator.

Parameters
----------
func : function
    The function to be deprecated.
old_name : str, optional
    The name of the function to be deprecated. Default is None, in
    which case the name of `func` is used.
new_name : str, optional
    The new name for the function. Default is None, in which case the
    deprecation message is that `old_name` is deprecated. If given, the
    deprecation message is that `old_name` is deprecated and `new_name`
    should be used instead.
message : str, optional
    Additional explanation of the deprecation.  Displayed in the
    docstring after the warning.

Returns
-------
old_func : function
    The deprecated function.

Examples
--------
Note that ``olduint`` returns a value after printing Deprecation
Warning:

>>> olduint = np.deprecate(np.uint)
DeprecationWarning: `uint64` is deprecated! # may vary
>>> olduint(6)
6\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1utils_ad068e6779e539248b179200225a11910}\label{namespacenumpy_1_1lib_1_1utils_ad068e6779e539248b179200225a11910}} 
\index{numpy\+::lib\+::utils@{numpy\+::lib\+::utils}!deprecate\+\_\+with\+\_\+doc@{deprecate\+\_\+with\+\_\+doc}}
\index{deprecate\+\_\+with\+\_\+doc@{deprecate\+\_\+with\+\_\+doc}!numpy\+::lib\+::utils@{numpy\+::lib\+::utils}}
\subsubsection{\texorpdfstring{deprecate\+\_\+with\+\_\+doc()}{deprecate\_with\_doc()}}
{\footnotesize\ttfamily def numpy.\+lib.\+utils.\+deprecate\+\_\+with\+\_\+doc (\begin{DoxyParamCaption}\item[{}]{msg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Deprecates a function and includes the deprecation in its docstring.

This function is used as a decorator. It returns an object that can be
used to issue a DeprecationWarning, by passing the to-be decorated
function as argument, this adds warning to the to-be decorated function's
docstring and returns the new function object.

See Also
--------
deprecate : Decorate a function such that it issues a `DeprecationWarning`

Parameters
----------
msg : str
    Additional explanation of the deprecation. Displayed in the
    docstring after the warning.

Returns
-------
obj : object\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1utils_af88a4119737ebfe13e2d9b9eb50a09c5}\label{namespacenumpy_1_1lib_1_1utils_af88a4119737ebfe13e2d9b9eb50a09c5}} 
\index{numpy\+::lib\+::utils@{numpy\+::lib\+::utils}!get\+\_\+include@{get\+\_\+include}}
\index{get\+\_\+include@{get\+\_\+include}!numpy\+::lib\+::utils@{numpy\+::lib\+::utils}}
\subsubsection{\texorpdfstring{get\+\_\+include()}{get\_include()}}
{\footnotesize\ttfamily def numpy.\+lib.\+utils.\+get\+\_\+include (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the directory that contains the NumPy \\*.h header files.

Extension modules that need to compile against NumPy should use this
function to locate the appropriate include directory.

Notes
-----
When using ``distutils``, for example in ``setup.py``.
::

    import numpy as np
    ...
    Extension('extension_name', ...
            include_dirs=[np.get_include()])
    ...\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1utils_a20bd9fdff36ab4476ff840623e0e62f9}\label{namespacenumpy_1_1lib_1_1utils_a20bd9fdff36ab4476ff840623e0e62f9}} 
\index{numpy\+::lib\+::utils@{numpy\+::lib\+::utils}!info@{info}}
\index{info@{info}!numpy\+::lib\+::utils@{numpy\+::lib\+::utils}}
\subsubsection{\texorpdfstring{info()}{info()}}
{\footnotesize\ttfamily def numpy.\+lib.\+utils.\+info (\begin{DoxyParamCaption}\item[{}]{object = {\ttfamily None},  }\item[{}]{maxwidth = {\ttfamily 76},  }\item[{}]{output = {\ttfamily sys.stdout},  }\item[{}]{toplevel = {\ttfamily \textquotesingle{}numpy\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Get help information for a function, class, or module.

Parameters
----------
object : object or str, optional
    Input object or name to get information about. If `object` is a
    numpy object, its docstring is given. If it is a string, available
    modules are searched for matching objects.  If None, information
    about `info` itself is returned.
maxwidth : int, optional
    Printing width.
output : file like object, optional
    File like object that the output is written to, default is
    ``stdout``.  The object has to be opened in 'w' or 'a' mode.
toplevel : str, optional
    Start search at this level.

See Also
--------
source, lookfor

Notes
-----
When used interactively with an object, ``np.info(obj)`` is equivalent
to ``help(obj)`` on the Python prompt or ``obj?`` on the IPython
prompt.

Examples
--------
>>> np.info(np.polyval) # doctest: +SKIP
   polyval(p, x)
     Evaluate the polynomial p at x.
     ...

When using a string for `object` it is possible to get multiple results.

>>> np.info('fft') # doctest: +SKIP
     *** Found in numpy ***
Core FFT routines
...
     *** Found in numpy.fft ***
 fft(a, n=None, axis=-1)
...
     *** Repeat reference found in numpy.fft.fftpack ***
     *** Total of 3 references found. ***\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1utils_ad34dd70d113be622ed9a750e9c99de9a}\label{namespacenumpy_1_1lib_1_1utils_ad34dd70d113be622ed9a750e9c99de9a}} 
\index{numpy\+::lib\+::utils@{numpy\+::lib\+::utils}!lookfor@{lookfor}}
\index{lookfor@{lookfor}!numpy\+::lib\+::utils@{numpy\+::lib\+::utils}}
\subsubsection{\texorpdfstring{lookfor()}{lookfor()}}
{\footnotesize\ttfamily def numpy.\+lib.\+utils.\+lookfor (\begin{DoxyParamCaption}\item[{}]{what,  }\item[{}]{module = {\ttfamily None},  }\item[{}]{import\+\_\+modules = {\ttfamily True},  }\item[{}]{regenerate = {\ttfamily False},  }\item[{}]{output = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Do a keyword search on docstrings.

A list of objects that matched the search is displayed,
sorted by relevance. All given keywords need to be found in the
docstring for it to be returned as a result, but the order does
not matter.

Parameters
----------
what : str
    String containing words to look for.
module : str or list, optional
    Name of module(s) whose docstrings to go through.
import_modules : bool, optional
    Whether to import sub-modules in packages. Default is True.
regenerate : bool, optional
    Whether to re-generate the docstring cache. Default is False.
output : file-like, optional
    File-like object to write the output to. If omitted, use a pager.

See Also
--------
source, info

Notes
-----
Relevance is determined only roughly, by checking if the keywords occur
in the function name, at the start of a docstring, etc.

Examples
--------
>>> np.lookfor('binary representation') # doctest: +SKIP
Search results for 'binary representation'
------------------------------------------
numpy.binary_repr
    Return the binary representation of the input number as a string.
numpy.core.setup_common.long_double_representation
    Given a binary dump as given by GNU od -b, look for long double
numpy.base_repr
    Return a string representation of a number in the given base system.
...\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1utils_a5439fed5d1eee86e9616441b8bdda46e}\label{namespacenumpy_1_1lib_1_1utils_a5439fed5d1eee86e9616441b8bdda46e}} 
\index{numpy\+::lib\+::utils@{numpy\+::lib\+::utils}!safe\+\_\+eval@{safe\+\_\+eval}}
\index{safe\+\_\+eval@{safe\+\_\+eval}!numpy\+::lib\+::utils@{numpy\+::lib\+::utils}}
\subsubsection{\texorpdfstring{safe\+\_\+eval()}{safe\_eval()}}
{\footnotesize\ttfamily def numpy.\+lib.\+utils.\+safe\+\_\+eval (\begin{DoxyParamCaption}\item[{}]{source }\end{DoxyParamCaption})}

\begin{DoxyVerb}Protected string evaluation.

Evaluate a string containing a Python literal expression without
allowing the execution of arbitrary non-literal code.

Parameters
----------
source : str
    The string to evaluate.

Returns
-------
obj : object
   The result of evaluating `source`.

Raises
------
SyntaxError
    If the code has invalid Python syntax, or if it contains
    non-literal code.

Examples
--------
>>> np.safe_eval('1')
1
>>> np.safe_eval('[1, 2, 3]')
[1, 2, 3]
>>> np.safe_eval('{"foo": ("bar", 10.0)}')
{'foo': ('bar', 10.0)}

>>> np.safe_eval('import os')
Traceback (most recent call last):
  ...
SyntaxError: invalid syntax

>>> np.safe_eval('open("/home/user/.ssh/id_dsa").read()')
Traceback (most recent call last):
  ...
ValueError: malformed node or string: <_ast.Call object at 0x...>\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1utils_a95d697b2cd971f6f15b6d6643afd0fae}\label{namespacenumpy_1_1lib_1_1utils_a95d697b2cd971f6f15b6d6643afd0fae}} 
\index{numpy\+::lib\+::utils@{numpy\+::lib\+::utils}!source@{source}}
\index{source@{source}!numpy\+::lib\+::utils@{numpy\+::lib\+::utils}}
\subsubsection{\texorpdfstring{source()}{source()}}
{\footnotesize\ttfamily def numpy.\+lib.\+utils.\+source (\begin{DoxyParamCaption}\item[{}]{object,  }\item[{}]{output = {\ttfamily sys.stdout} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Print or write to a file the source code for a NumPy object.

The source code is only returned for objects written in Python. Many
functions and classes are defined in C and will therefore not return
useful information.

Parameters
----------
object : numpy object
    Input object. This can be any object (function, class, module,
    ...).
output : file object, optional
    If `output` not supplied then source code is printed to screen
    (sys.stdout).  File object must be created with either write 'w' or
    append 'a' modes.

See Also
--------
lookfor, info

Examples
--------
>>> np.source(np.interp)                        #doctest: +SKIP
In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py
def interp(x, xp, fp, left=None, right=None):
    \"\"\".... (full docstring printed)\"\"\"
    if isinstance(x, (float, int, number)):
        return compiled_interp([x], xp, fp, left, right).item()
    else:
        return compiled_interp(x, xp, fp, left, right)

The source code is only returned for objects written in Python.

>>> np.source(np.array)                         #doctest: +SKIP
Not available for this object.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1utils_a26df04e9904b2e3349eaff91896cc156}\label{namespacenumpy_1_1lib_1_1utils_a26df04e9904b2e3349eaff91896cc156}} 
\index{numpy\+::lib\+::utils@{numpy\+::lib\+::utils}!who@{who}}
\index{who@{who}!numpy\+::lib\+::utils@{numpy\+::lib\+::utils}}
\subsubsection{\texorpdfstring{who()}{who()}}
{\footnotesize\ttfamily def numpy.\+lib.\+utils.\+who (\begin{DoxyParamCaption}\item[{}]{vardict = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Print the NumPy arrays in the given dictionary.

If there is no dictionary passed in or `vardict` is None then returns
NumPy arrays in the globals() dictionary (all NumPy arrays in the
namespace).

Parameters
----------
vardict : dict, optional
    A dictionary possibly containing ndarrays.  Default is globals().

Returns
-------
out : None
    Returns 'None'.

Notes
-----
Prints out the name, shape, bytes and type of all of the ndarrays
present in `vardict`.

Examples
--------
>>> a = np.arange(10)
>>> b = np.ones(20)
>>> np.who()
Name            Shape            Bytes            Type
===========================================================
a               10               80               int64
b               20               160              float64
Upper bound on total bytes  =       240

>>> d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',
... 'idx':5}
>>> np.who(d)
Name            Shape            Bytes            Type
===========================================================
x               2                16               float64
y               3                24               float64
Upper bound on total bytes  =       40\end{DoxyVerb}
 