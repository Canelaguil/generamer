\hypertarget{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic}{}\section{networkx.\+algorithms.\+shortest\+\_\+paths.\+generic Namespace Reference}
\label{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic}\index{networkx.\+algorithms.\+shortest\+\_\+paths.\+generic@{networkx.\+algorithms.\+shortest\+\_\+paths.\+generic}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_aa9004ba323dd9fd872d3e97769f28e1d}{has\+\_\+path} (G, source, target)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_ac7e350c9388364d06e2a82553130da2b}{shortest\+\_\+path} (G, source=None, target=None, weight=None, method=\char`\"{}dijkstra\char`\"{})
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_a1497db0f134f911fea5d66ce6adda7de}{shortest\+\_\+path\+\_\+length} (G, source=None, target=None, weight=None, method=\char`\"{}dijkstra\char`\"{})
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_a9fd450807fac1acf3a78c14109ea672a}{average\+\_\+shortest\+\_\+path\+\_\+length} (G, weight=None, method=None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_aacdabc1eb6e505b924c4de9f23a71718}{all\+\_\+shortest\+\_\+paths} (G, source, target, weight=None, method=\char`\"{}dijkstra\char`\"{})
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Compute the shortest paths and path lengths between nodes in the graph.

These algorithms work with undirected and directed graphs.\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_aacdabc1eb6e505b924c4de9f23a71718}\label{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_aacdabc1eb6e505b924c4de9f23a71718}} 
\index{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}!all\+\_\+shortest\+\_\+paths@{all\+\_\+shortest\+\_\+paths}}
\index{all\+\_\+shortest\+\_\+paths@{all\+\_\+shortest\+\_\+paths}!networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}}
\subsubsection{\texorpdfstring{all\+\_\+shortest\+\_\+paths()}{all\_shortest\_paths()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+shortest\+\_\+paths.\+generic.\+all\+\_\+shortest\+\_\+paths (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{source,  }\item[{}]{target,  }\item[{}]{weight = {\ttfamily None},  }\item[{}]{method = {\ttfamily \char`\"{}dijkstra\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute all shortest simple paths in the graph.

Parameters
----------
G : NetworkX graph

source : node
   Starting node for path.

target : node
   Ending node for path.

weight : None or string, optional (default = None)
   If None, every edge has weight/distance/cost 1.
   If a string, use this edge attribute as the edge weight.
   Any edge attribute not present defaults to 1.

method : string, optional (default = 'dijkstra')
   The algorithm to use to compute the path lengths.
   Supported options: 'dijkstra', 'bellman-ford'.
   Other inputs produce a ValueError.
   If `weight` is None, unweighted graph methods are used, and this
   suggestion is ignored.

Returns
-------
paths : generator of lists
    A generator of all paths between source and target.

Raises
------
ValueError
    If `method` is not among the supported options.

NetworkXNoPath
    If `target` cannot be reached from `source`.

Examples
--------
>>> G = nx.Graph()
>>> nx.add_path(G, [0, 1, 2])
>>> nx.add_path(G, [0, 10, 2])
>>> print([p for p in nx.all_shortest_paths(G, source=0, target=2)])
[[0, 1, 2], [0, 10, 2]]

Notes
-----
There may be many shortest paths between the source and target.  If G
contains zero-weight cycles, this function will not produce all shortest
paths because doing so would produce infinitely many paths of unbounded
length -- instead, we only produce the shortest simple paths.

See Also
--------
shortest_path
single_source_shortest_path
all_pairs_shortest_path
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_a9fd450807fac1acf3a78c14109ea672a}\label{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_a9fd450807fac1acf3a78c14109ea672a}} 
\index{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}!average\+\_\+shortest\+\_\+path\+\_\+length@{average\+\_\+shortest\+\_\+path\+\_\+length}}
\index{average\+\_\+shortest\+\_\+path\+\_\+length@{average\+\_\+shortest\+\_\+path\+\_\+length}!networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}}
\subsubsection{\texorpdfstring{average\+\_\+shortest\+\_\+path\+\_\+length()}{average\_shortest\_path\_length()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+shortest\+\_\+paths.\+generic.\+average\+\_\+shortest\+\_\+path\+\_\+length (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{weight = {\ttfamily None},  }\item[{}]{method = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the average shortest path length.

The average shortest path length is

.. math::

   a =\sum_{s,t \in V} \frac{d(s, t)}{n(n-1)}

where `V` is the set of nodes in `G`,
`d(s, t)` is the shortest path from `s` to `t`,
and `n` is the number of nodes in `G`.

Parameters
----------
G : NetworkX graph

weight : None or string, optional (default = None)
   If None, every edge has weight/distance/cost 1.
   If a string, use this edge attribute as the edge weight.
   Any edge attribute not present defaults to 1.

method : string, optional (default = 'unweighted' or 'djikstra')
    The algorithm to use to compute the path lengths.
    Supported options are 'unweighted', 'dijkstra', 'bellman-ford',
    'floyd-warshall' and 'floyd-warshall-numpy'.
    Other method values produce a ValueError.
    The default method is 'unweighted' if `weight` is None,
    otherwise the default method is 'dijkstra'.

Raises
------
NetworkXPointlessConcept
    If `G` is the null graph (that is, the graph on zero nodes).

NetworkXError
    If `G` is not connected (or not weakly connected, in the case
    of a directed graph).

ValueError
    If `method` is not among the supported options.

Examples
--------
>>> G = nx.path_graph(5)
>>> nx.average_shortest_path_length(G)
2.0

For disconnected graphs, you can compute the average shortest path
length for each component

>>> G = nx.Graph([(1, 2), (3, 4)])
>>> for C in (G.subgraph(c).copy() for c in nx.connected_components(G)):
...     print(nx.average_shortest_path_length(C))
1.0
1.0\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_aa9004ba323dd9fd872d3e97769f28e1d}\label{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_aa9004ba323dd9fd872d3e97769f28e1d}} 
\index{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}!has\+\_\+path@{has\+\_\+path}}
\index{has\+\_\+path@{has\+\_\+path}!networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}}
\subsubsection{\texorpdfstring{has\+\_\+path()}{has\_path()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+shortest\+\_\+paths.\+generic.\+has\+\_\+path (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{source,  }\item[{}]{target }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns *True* if *G* has a path from *source* to *target*.

Parameters
----------
G : NetworkX graph

source : node
   Starting node for path

target : node
   Ending node for path
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_ac7e350c9388364d06e2a82553130da2b}\label{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_ac7e350c9388364d06e2a82553130da2b}} 
\index{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}!shortest\+\_\+path@{shortest\+\_\+path}}
\index{shortest\+\_\+path@{shortest\+\_\+path}!networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}}
\subsubsection{\texorpdfstring{shortest\+\_\+path()}{shortest\_path()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+shortest\+\_\+paths.\+generic.\+shortest\+\_\+path (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{source = {\ttfamily None},  }\item[{}]{target = {\ttfamily None},  }\item[{}]{weight = {\ttfamily None},  }\item[{}]{method = {\ttfamily \char`\"{}dijkstra\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute shortest paths in the graph.

Parameters
----------
G : NetworkX graph

source : node, optional
    Starting node for path. If not specified, compute shortest
    paths for each possible starting node.

target : node, optional
    Ending node for path. If not specified, compute shortest
    paths to all possible nodes.

weight : None or string, optional (default = None)
    If None, every edge has weight/distance/cost 1.
    If a string, use this edge attribute as the edge weight.
    Any edge attribute not present defaults to 1.

method : string, optional (default = 'dijkstra')
    The algorithm to use to compute the path.
    Supported options: 'dijkstra', 'bellman-ford'.
    Other inputs produce a ValueError.
    If `weight` is None, unweighted graph methods are used, and this
    suggestion is ignored.

Returns
-------
path: list or dictionary
    All returned paths include both the source and target in the path.

    If the source and target are both specified, return a single list
    of nodes in a shortest path from the source to the target.

    If only the source is specified, return a dictionary keyed by
    targets with a list of nodes in a shortest path from the source
    to one of the targets.

    If only the target is specified, return a dictionary keyed by
    sources with a list of nodes in a shortest path from one of the
    sources to the target.

    If neither the source nor target are specified return a dictionary
    of dictionaries with path[source][target]=[list of nodes in path].

Raises
------
NodeNotFound
    If `source` is not in `G`.

ValueError
    If `method` is not among the supported options.

Examples
--------
>>> G = nx.path_graph(5)
>>> print(nx.shortest_path(G, source=0, target=4))
[0, 1, 2, 3, 4]
>>> p = nx.shortest_path(G, source=0)  # target not specified
>>> p[4]
[0, 1, 2, 3, 4]
>>> p = nx.shortest_path(G, target=4)  # source not specified
>>> p[0]
[0, 1, 2, 3, 4]
>>> p = nx.shortest_path(G)  # source, target not specified
>>> p[0][4]
[0, 1, 2, 3, 4]

Notes
-----
There may be more than one shortest path between a source and target.
This returns only one of them.

See Also
--------
all_pairs_shortest_path
all_pairs_dijkstra_path
all_pairs_bellman_ford_path
single_source_shortest_path
single_source_dijkstra_path
single_source_bellman_ford_path
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_a1497db0f134f911fea5d66ce6adda7de}\label{namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1generic_a1497db0f134f911fea5d66ce6adda7de}} 
\index{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}!shortest\+\_\+path\+\_\+length@{shortest\+\_\+path\+\_\+length}}
\index{shortest\+\_\+path\+\_\+length@{shortest\+\_\+path\+\_\+length}!networkx\+::algorithms\+::shortest\+\_\+paths\+::generic@{networkx\+::algorithms\+::shortest\+\_\+paths\+::generic}}
\subsubsection{\texorpdfstring{shortest\+\_\+path\+\_\+length()}{shortest\_path\_length()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+shortest\+\_\+paths.\+generic.\+shortest\+\_\+path\+\_\+length (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{source = {\ttfamily None},  }\item[{}]{target = {\ttfamily None},  }\item[{}]{weight = {\ttfamily None},  }\item[{}]{method = {\ttfamily \char`\"{}dijkstra\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute shortest path lengths in the graph.

Parameters
----------
G : NetworkX graph

source : node, optional
    Starting node for path.
    If not specified, compute shortest path lengths using all nodes as
    source nodes.

target : node, optional
    Ending node for path.
    If not specified, compute shortest path lengths using all nodes as
    target nodes.

weight : None or string, optional (default = None)
    If None, every edge has weight/distance/cost 1.
    If a string, use this edge attribute as the edge weight.
    Any edge attribute not present defaults to 1.

method : string, optional (default = 'dijkstra')
    The algorithm to use to compute the path length.
    Supported options: 'dijkstra', 'bellman-ford'.
    Other inputs produce a ValueError.
    If `weight` is None, unweighted graph methods are used, and this
    suggestion is ignored.

Returns
-------
length: int or iterator
    If the source and target are both specified, return the length of
    the shortest path from the source to the target.

    If only the source is specified, return a dict keyed by target
    to the shortest path length from the source to that target.

    If only the target is specified, return a dict keyed by source
    to the shortest path length from that source to the target.

    If neither the source nor target are specified, return an iterator
    over (source, dictionary) where dictionary is keyed by target to
    shortest path length from source to that target.

Raises
------
NodeNotFound
    If `source` is not in `G`.

NetworkXNoPath
    If no path exists between source and target.

ValueError
    If `method` is not among the supported options.

Examples
--------
>>> G = nx.path_graph(5)
>>> nx.shortest_path_length(G, source=0, target=4)
4
>>> p = nx.shortest_path_length(G, source=0)  # target not specified
>>> p[4]
4
>>> p = nx.shortest_path_length(G, target=4)  # source not specified
>>> p[0]
4
>>> p = dict(nx.shortest_path_length(G))  # source,target not specified
>>> p[0][4]
4

Notes
-----
The length of the path is always 1 less than the number of nodes involved
in the path since the length measures the number of edges followed.

For digraphs this returns the shortest directed path length. To find path
lengths in the reverse direction use G.reverse(copy=False) first to flip
the edge orientation.

See Also
--------
all_pairs_shortest_path_length
all_pairs_dijkstra_path_length
all_pairs_bellman_ford_path_length
single_source_shortest_path_length
single_source_dijkstra_path_length
single_source_bellman_ford_path_length
\end{DoxyVerb}
 