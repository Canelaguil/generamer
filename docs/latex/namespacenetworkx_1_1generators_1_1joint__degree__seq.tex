\hypertarget{namespacenetworkx_1_1generators_1_1joint__degree__seq}{}\section{networkx.\+generators.\+joint\+\_\+degree\+\_\+seq Namespace Reference}
\label{namespacenetworkx_1_1generators_1_1joint__degree__seq}\index{networkx.\+generators.\+joint\+\_\+degree\+\_\+seq@{networkx.\+generators.\+joint\+\_\+degree\+\_\+seq}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1generators_1_1joint__degree__seq_a1dac8f1785811efb523049d51ec554e1}{is\+\_\+valid\+\_\+joint\+\_\+degree} (joint\+\_\+degrees)
\item 
def \hyperlink{namespacenetworkx_1_1generators_1_1joint__degree__seq_ab07b587a34ff4300e8b9d7b03bd39067}{joint\+\_\+degree\+\_\+graph} (joint\+\_\+degrees, seed=None)
\item 
def \hyperlink{namespacenetworkx_1_1generators_1_1joint__degree__seq_abed44ed09f640e2cec94975588d74505}{is\+\_\+valid\+\_\+directed\+\_\+joint\+\_\+degree} (in\+\_\+degrees, out\+\_\+degrees, nkk)
\item 
def \hyperlink{namespacenetworkx_1_1generators_1_1joint__degree__seq_abb3a3a00b32196156227d478e68ff0e8}{directed\+\_\+joint\+\_\+degree\+\_\+graph} (in\+\_\+degrees, out\+\_\+degrees, nkk, seed=None)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Generate graphs with a given joint degree and directed joint degree\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1generators_1_1joint__degree__seq_abb3a3a00b32196156227d478e68ff0e8}\label{namespacenetworkx_1_1generators_1_1joint__degree__seq_abb3a3a00b32196156227d478e68ff0e8}} 
\index{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq@{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq}!directed\+\_\+joint\+\_\+degree\+\_\+graph@{directed\+\_\+joint\+\_\+degree\+\_\+graph}}
\index{directed\+\_\+joint\+\_\+degree\+\_\+graph@{directed\+\_\+joint\+\_\+degree\+\_\+graph}!networkx\+::generators\+::joint\+\_\+degree\+\_\+seq@{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq}}
\subsubsection{\texorpdfstring{directed\+\_\+joint\+\_\+degree\+\_\+graph()}{directed\_joint\_degree\_graph()}}
{\footnotesize\ttfamily def networkx.\+generators.\+joint\+\_\+degree\+\_\+seq.\+directed\+\_\+joint\+\_\+degree\+\_\+graph (\begin{DoxyParamCaption}\item[{}]{in\+\_\+degrees,  }\item[{}]{out\+\_\+degrees,  }\item[{}]{nkk,  }\item[{}]{seed = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Generates a random simple directed graph with the joint degree.

Parameters
----------
degree_seq :  list of tuples (of size 3)
    degree sequence contains tuples of nodes with node id, in degree and
    out degree.
nkk  :  dictionary of dictionary of integers
    directed joint degree dictionary, for nodes of out degree k (first
    level of dict) and nodes of in degree l (second level of dict)
    describes the number of edges.
seed : hashable object, optional
    Seed for random number generator.

Returns
-------
G : Graph
    A directed graph with the specified inputs.

Raises
------
NetworkXError
    If degree_seq and nkk are not realizable as a simple directed graph.


Notes
-----
Similarly to the undirected version:
In each iteration of the "while loop" the algorithm picks two disconnected
nodes v and w, of degree k and l correspondingly,  for which nkk[k][l] has
not reached its target yet i.e. (for given k,l): n_edges_add < nkk[k][l].
It then adds edge (v,w) and always increases the number of edges in graph G
by one.

The intelligence of the algorithm lies in the fact that  it is always
possible to add an edge between disconnected nodes v and w, for which
nkk[degree(v)][degree(w)] has not reached its target, even if one or both
nodes do not have free stubs. If either node v or w does not have a free
stub, we perform a "neighbor switch", an edge rewiring move that releases a
free stub while keeping nkk the same.

The difference for the directed version lies in the fact that neighbor
switches might not be able to rewire, but in these cases unsaturated nodes
can be reassigned to use instead, see [1] for detailed description and
proofs.

The algorithm continues for E (number of edges in the graph) iterations of
the "while loop", at which point all entries of the given nkk[k][l] have
reached their target values and the construction is complete.

References
----------
[1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka,
    "Construction of Directed 2K Graphs". In Proc. of KDD 2017.

Examples
--------
>>> in_degrees = [0, 1, 1, 2]
>>> out_degrees = [1, 1, 1, 1]
>>> nkk = {1: {1: 2, 2: 2}}
>>> G = nx.directed_joint_degree_graph(in_degrees, out_degrees, nkk)
>>>
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1generators_1_1joint__degree__seq_abed44ed09f640e2cec94975588d74505}\label{namespacenetworkx_1_1generators_1_1joint__degree__seq_abed44ed09f640e2cec94975588d74505}} 
\index{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq@{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq}!is\+\_\+valid\+\_\+directed\+\_\+joint\+\_\+degree@{is\+\_\+valid\+\_\+directed\+\_\+joint\+\_\+degree}}
\index{is\+\_\+valid\+\_\+directed\+\_\+joint\+\_\+degree@{is\+\_\+valid\+\_\+directed\+\_\+joint\+\_\+degree}!networkx\+::generators\+::joint\+\_\+degree\+\_\+seq@{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq}}
\subsubsection{\texorpdfstring{is\+\_\+valid\+\_\+directed\+\_\+joint\+\_\+degree()}{is\_valid\_directed\_joint\_degree()}}
{\footnotesize\ttfamily def networkx.\+generators.\+joint\+\_\+degree\+\_\+seq.\+is\+\_\+valid\+\_\+directed\+\_\+joint\+\_\+degree (\begin{DoxyParamCaption}\item[{}]{in\+\_\+degrees,  }\item[{}]{out\+\_\+degrees,  }\item[{}]{nkk }\end{DoxyParamCaption})}

\begin{DoxyVerb}Checks whether the given directed joint degree input is realizable

Parameters
----------
in_degrees :  list of integers
    in degree sequence contains the in degrees of nodes.
out_degrees : list of integers
    out degree sequence contains the out degrees of nodes.
nkk  :  dictionary of dictionary of integers
    directed joint degree dictionary. for nodes of out degree k (first
    level of dict) and nodes of in degree l (seconnd level of dict)
    describes the number of edges.

Returns
-------
boolean
    returns true if given input is realizable, else returns false.

Notes
-----
Here is the list of conditions that the inputs (in/out degree sequences,
nkk) need to satisfy for simple directed graph realizability:

- Condition 0: in_degrees and out_degrees have the same length
- Condition 1: nkk[k][l]  is integer for all k,l
- Condition 2: sum(nkk[k])/k = number of nodes with partition id k, is an
               integer and matching degree sequence
- Condition 3: number of edges and non-chords between k and l cannot exceed
               maximum possible number of edges


References
----------
[1] B. Tillman, A. Markopoulou, C. T. Butts & M. Gjoka,
    "Construction of Directed 2K Graphs". In Proc. of KDD 2017.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1generators_1_1joint__degree__seq_a1dac8f1785811efb523049d51ec554e1}\label{namespacenetworkx_1_1generators_1_1joint__degree__seq_a1dac8f1785811efb523049d51ec554e1}} 
\index{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq@{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq}!is\+\_\+valid\+\_\+joint\+\_\+degree@{is\+\_\+valid\+\_\+joint\+\_\+degree}}
\index{is\+\_\+valid\+\_\+joint\+\_\+degree@{is\+\_\+valid\+\_\+joint\+\_\+degree}!networkx\+::generators\+::joint\+\_\+degree\+\_\+seq@{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq}}
\subsubsection{\texorpdfstring{is\+\_\+valid\+\_\+joint\+\_\+degree()}{is\_valid\_joint\_degree()}}
{\footnotesize\ttfamily def networkx.\+generators.\+joint\+\_\+degree\+\_\+seq.\+is\+\_\+valid\+\_\+joint\+\_\+degree (\begin{DoxyParamCaption}\item[{}]{joint\+\_\+degrees }\end{DoxyParamCaption})}

\begin{DoxyVerb}Checks whether the given joint degree dictionary is realizable.

A *joint degree dictionary* is a dictionary of dictionaries, in
which entry ``joint_degrees[k][l]`` is an integer representing the
number of edges joining nodes of degree *k* with nodes of degree
*l*. Such a dictionary is realizable as a simple graph if and only
if the following conditions are satisfied.

- each entry must be an integer,
- the total number of nodes of degree *k*, computed by
  ``sum(joint_degrees[k].values()) / k``, must be an integer,
- the total number of edges joining nodes of degree *k* with
  nodes of degree *l* cannot exceed the total number of possible edges,
- each diagonal entry ``joint_degrees[k][k]`` must be even (this is
  a convention assumed by the :func:`joint_degree_graph` function).


Parameters
----------
joint_degrees :  dictionary of dictionary of integers
    A joint degree dictionary in which entry ``joint_degrees[k][l]``
    is the number of edges joining nodes of degree *k* with nodes of
    degree *l*.

Returns
-------
bool
    Whether the given joint degree dictionary is realizable as a
    simple graph.

References
----------
.. [1] M. Gjoka, M. Kurant, A. Markopoulou, "2.5K Graphs: from Sampling
   to Generation", IEEE Infocom, 2013.
.. [2] I. Stanton, A. Pinar, "Constructing and sampling graphs with a
   prescribed joint degree distribution", Journal of Experimental
   Algorithmics, 2012.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1generators_1_1joint__degree__seq_ab07b587a34ff4300e8b9d7b03bd39067}\label{namespacenetworkx_1_1generators_1_1joint__degree__seq_ab07b587a34ff4300e8b9d7b03bd39067}} 
\index{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq@{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq}!joint\+\_\+degree\+\_\+graph@{joint\+\_\+degree\+\_\+graph}}
\index{joint\+\_\+degree\+\_\+graph@{joint\+\_\+degree\+\_\+graph}!networkx\+::generators\+::joint\+\_\+degree\+\_\+seq@{networkx\+::generators\+::joint\+\_\+degree\+\_\+seq}}
\subsubsection{\texorpdfstring{joint\+\_\+degree\+\_\+graph()}{joint\_degree\_graph()}}
{\footnotesize\ttfamily def networkx.\+generators.\+joint\+\_\+degree\+\_\+seq.\+joint\+\_\+degree\+\_\+graph (\begin{DoxyParamCaption}\item[{}]{joint\+\_\+degrees,  }\item[{}]{seed = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Generates a random simple graph with the given joint degree dictionary.

Parameters
----------
joint_degrees :  dictionary of dictionary of integers
    A joint degree dictionary in which entry ``joint_degrees[k][l]`` is the
    number of edges joining nodes of degree *k* with nodes of degree *l*.
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness<randomness>`.

Returns
-------
G : Graph
    A graph with the specified joint degree dictionary.

Raises
------
NetworkXError
    If *joint_degrees* dictionary is not realizable.

Notes
-----
In each iteration of the "while loop" the algorithm picks two disconnected
nodes *v* and *w*, of degree *k* and *l* correspondingly,  for which
``joint_degrees[k][l]`` has not reached its target yet. It then adds
edge (*v*, *w*) and increases the number of edges in graph G by one.

The intelligence of the algorithm lies in the fact that  it is always
possible to add an edge between such disconnected nodes *v* and *w*,
even if one or both nodes do not have free stubs. That is made possible by
executing a "neighbor switch", an edge rewiring move that releases
a free stub while keeping the joint degree of G the same.

The algorithm continues for E (number of edges) iterations of
the "while loop", at the which point all entries of the given
``joint_degrees[k][l]`` have reached their target values and the
construction is complete.

References
----------
..  [1] M. Gjoka, B. Tillman, A. Markopoulou, "Construction of Simple
    Graphs with a Target Joint Degree Matrix and Beyond", IEEE Infocom, '15

Examples
--------
>>> joint_degrees = {
...     1: {4: 1},
...     2: {2: 2, 3: 2, 4: 2},
...     3: {2: 2, 4: 1},
...     4: {1: 1, 2: 2, 3: 1},
... }
>>> G = nx.joint_degree_graph(joint_degrees)
>>>
\end{DoxyVerb}
 