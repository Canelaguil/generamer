\hypertarget{namespacenetworkx_1_1convert__matrix}{}\section{networkx.\+convert\+\_\+matrix Namespace Reference}
\label{namespacenetworkx_1_1convert__matrix}\index{networkx.\+convert\+\_\+matrix@{networkx.\+convert\+\_\+matrix}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_a0153ce03fb37943dab6046e07b4bffc0}{to\+\_\+pandas\+\_\+adjacency} (G, nodelist=None, dtype=None, order=None, multigraph\+\_\+weight=\hyperlink{assumed__shape_2foo__free_8f90_a1c860bb40bf43c289bc16f8634733f9a}{sum}, weight=\char`\"{}weight\char`\"{}, nonedge=0.\+0)
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_a566eb7823aed0eeb25556218a8aac8aa}{from\+\_\+pandas\+\_\+adjacency} (df, create\+\_\+using=None)
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_a6f3984434d922d8f5ee4fc1aff940004}{to\+\_\+pandas\+\_\+edgelist} (G, source=\char`\"{}source\char`\"{}, target=\char`\"{}target\char`\"{}, nodelist=None, dtype=None, order=None, edge\+\_\+key=None)
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_a985798534d023762687a19185c0eb578}{from\+\_\+pandas\+\_\+edgelist} (df, source=\char`\"{}source\char`\"{}, target=\char`\"{}target\char`\"{}, edge\+\_\+attr=None, create\+\_\+using=None, edge\+\_\+key=None)
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_a3a9192800f2d95a6d3588aa9e4516d20}{to\+\_\+numpy\+\_\+matrix} (G, nodelist=None, dtype=None, order=None, multigraph\+\_\+weight=\hyperlink{assumed__shape_2foo__free_8f90_a1c860bb40bf43c289bc16f8634733f9a}{sum}, weight=\char`\"{}weight\char`\"{}, nonedge=0.\+0)
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_aac4b5517e3ce3b24f975ca22e5c52751}{from\+\_\+numpy\+\_\+matrix} (A, parallel\+\_\+edges=False, create\+\_\+using=None)
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_ad41194dd5380831f9c70606b71bb3b07}{to\+\_\+numpy\+\_\+recarray} (G, nodelist=None, dtype=None, order=None)
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_a47cedef23442ab34bf69fffb4119a442}{to\+\_\+scipy\+\_\+sparse\+\_\+matrix} (G, nodelist=None, dtype=None, weight=\char`\"{}weight\char`\"{}, format=\char`\"{}csr\char`\"{})
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_ac8fbd2e587cd297b41557ad1299a9e7d}{from\+\_\+scipy\+\_\+sparse\+\_\+matrix} (A, parallel\+\_\+edges=False, create\+\_\+using=None, edge\+\_\+attribute=\char`\"{}weight\char`\"{})
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_acff6b353b4693143c1fad4d2c1c7a335}{to\+\_\+numpy\+\_\+array} (G, nodelist=None, dtype=None, order=None, multigraph\+\_\+weight=\hyperlink{assumed__shape_2foo__free_8f90_a1c860bb40bf43c289bc16f8634733f9a}{sum}, weight=\char`\"{}weight\char`\"{}, nonedge=0.\+0)
\item 
def \hyperlink{namespacenetworkx_1_1convert__matrix_abb1bfd74c48ba52319e8ccbaa20b964a}{from\+\_\+numpy\+\_\+array} (A, parallel\+\_\+edges=False, create\+\_\+using=None)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Functions to convert NetworkX graphs to and from common data containers
like numpy arrays, scipy sparse matrices, and pandas DataFrames.

The preferred way of converting data to a NetworkX graph is through the
graph constructor.  The constructor calls the to_networkx_graph() function
which attempts to guess the input type and convert it automatically.

Examples
--------
Create a 10 node random graph from a numpy array

>>> import numpy as np
>>> a = np.random.randint(0, 2, size=(10, 10))
>>> D = nx.DiGraph(a)

or equivalently

>>> D = nx.to_networkx_graph(a, create_using=nx.DiGraph)

See Also
--------
nx_agraph, nx_pydot
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_abb1bfd74c48ba52319e8ccbaa20b964a}\label{namespacenetworkx_1_1convert__matrix_abb1bfd74c48ba52319e8ccbaa20b964a}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!from\+\_\+numpy\+\_\+array@{from\+\_\+numpy\+\_\+array}}
\index{from\+\_\+numpy\+\_\+array@{from\+\_\+numpy\+\_\+array}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{from\+\_\+numpy\+\_\+array()}{from\_numpy\_array()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+from\+\_\+numpy\+\_\+array (\begin{DoxyParamCaption}\item[{}]{A,  }\item[{}]{parallel\+\_\+edges = {\ttfamily False},  }\item[{}]{create\+\_\+using = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a graph from a 2D NumPy array.

The 2D NumPy array is interpreted as an adjacency matrix for the graph.

Parameters
----------
A : a 2D numpy.ndarray
    An adjacency matrix representation of a graph

parallel_edges : Boolean
    If this is True, `create_using` is a multigraph, and `A` is an
    integer array, then entry *(i, j)* in the array is interpreted as the
    number of parallel edges joining vertices *i* and *j* in the graph.
    If it is False, then the entries in the array are interpreted as
    the weight of a single edge joining the vertices.

create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Notes
-----
For directed graphs, explicitly mention create_using=nx.DiGraph,
and entry i,j of A corresponds to an edge from i to j.

If `create_using` is :class:`networkx.MultiGraph` or
:class:`networkx.MultiDiGraph`, `parallel_edges` is True, and the
entries of `A` are of type :class:`int`, then this function returns a
multigraph (of the same type as `create_using`) with parallel edges.

If `create_using` indicates an undirected multigraph, then only the edges
indicated by the upper triangle of the array `A` will be added to the
graph.

If the NumPy array has a single data type for each array entry it
will be converted to an appropriate Python data type.

If the NumPy array has a user-specified compound data type the names
of the data fields will be used as attribute keys in the resulting
NetworkX graph.

See Also
--------
to_numpy_array

Examples
--------
Simple integer weights on edges:

>>> import numpy as np
>>> A = np.array([[1, 1], [2, 1]])
>>> G = nx.from_numpy_array(A)
>>> G.edges(data=True)
EdgeDataView([(0, 0, {'weight': 1}), (0, 1, {'weight': 2}), (1, 1, {'weight': 1})])

If `create_using` indicates a multigraph and the array has only integer
entries and `parallel_edges` is False, then the entries will be treated
as weights for edges joining the nodes (without creating parallel edges):

>>> A = np.array([[1, 1], [1, 2]])
>>> G = nx.from_numpy_array(A, create_using=nx.MultiGraph)
>>> G[1][1]
AtlasView({0: {'weight': 2}})

If `create_using` indicates a multigraph and the array has only integer
entries and `parallel_edges` is True, then the entries will be treated
as the number of parallel edges joining those two vertices:

>>> A = np.array([[1, 1], [1, 2]])
>>> temp = nx.MultiGraph()
>>> G = nx.from_numpy_array(A, parallel_edges=True, create_using=temp)
>>> G[1][1]
AtlasView({0: {'weight': 1}, 1: {'weight': 1}})

User defined compound data type on edges:

>>> dt = [("weight", float), ("cost", int)]
>>> A = np.array([[(1.0, 2)]], dtype=dt)
>>> G = nx.from_numpy_array(A)
>>> G.edges()
EdgeView([(0, 0)])
>>> G[0][0]["cost"]
2
>>> G[0][0]["weight"]
1.0\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_aac4b5517e3ce3b24f975ca22e5c52751}\label{namespacenetworkx_1_1convert__matrix_aac4b5517e3ce3b24f975ca22e5c52751}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!from\+\_\+numpy\+\_\+matrix@{from\+\_\+numpy\+\_\+matrix}}
\index{from\+\_\+numpy\+\_\+matrix@{from\+\_\+numpy\+\_\+matrix}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{from\+\_\+numpy\+\_\+matrix()}{from\_numpy\_matrix()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+from\+\_\+numpy\+\_\+matrix (\begin{DoxyParamCaption}\item[{}]{A,  }\item[{}]{parallel\+\_\+edges = {\ttfamily False},  }\item[{}]{create\+\_\+using = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a graph from numpy matrix.

The numpy matrix is interpreted as an adjacency matrix for the graph.

Parameters
----------
A : numpy matrix
    An adjacency matrix representation of a graph

parallel_edges : Boolean
    If True, `create_using` is a multigraph, and `A` is an
    integer matrix, then entry *(i, j)* in the matrix is interpreted as the
    number of parallel edges joining vertices *i* and *j* in the graph.
    If False, then the entries in the adjacency matrix are interpreted as
    the weight of a single edge joining the vertices.

create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Notes
-----
For directed graphs, explicitly mention create_using=nx.DiGraph,
and entry i,j of A corresponds to an edge from i to j.

If `create_using` is :class:`networkx.MultiGraph` or
:class:`networkx.MultiDiGraph`, `parallel_edges` is True, and the
entries of `A` are of type :class:`int`, then this function returns a
multigraph (constructed from `create_using`) with parallel edges.

If `create_using` indicates an undirected multigraph, then only the edges
indicated by the upper triangle of the matrix `A` will be added to the
graph.

If the numpy matrix has a single data type for each matrix entry it
will be converted to an appropriate Python data type.

If the numpy matrix has a user-specified compound data type the names
of the data fields will be used as attribute keys in the resulting
NetworkX graph.

See Also
--------
to_numpy_recarray

Examples
--------
Simple integer weights on edges:

>>> import numpy as np
>>> A = np.array([[1, 1], [2, 1]])
>>> G = nx.from_numpy_matrix(A)

If `create_using` indicates a multigraph and the matrix has only integer
entries and `parallel_edges` is False, then the entries will be treated
as weights for edges joining the nodes (without creating parallel edges):

>>> A = np.array([[1, 1], [1, 2]])
>>> G = nx.from_numpy_matrix(A, create_using=nx.MultiGraph)
>>> G[1][1]
AtlasView({0: {'weight': 2}})

If `create_using` indicates a multigraph and the matrix has only integer
entries and `parallel_edges` is True, then the entries will be treated
as the number of parallel edges joining those two vertices:

>>> A = np.array([[1, 1], [1, 2]])
>>> temp = nx.MultiGraph()
>>> G = nx.from_numpy_matrix(A, parallel_edges=True, create_using=temp)
>>> G[1][1]
AtlasView({0: {'weight': 1}, 1: {'weight': 1}})

User defined compound data type on edges:

>>> dt = [("weight", float), ("cost", int)]
>>> A = np.array([[(1.0, 2)]], dtype=dt)
>>> G = nx.from_numpy_matrix(A)
>>> list(G.edges())
[(0, 0)]
>>> G[0][0]["cost"]
2
>>> G[0][0]["weight"]
1.0\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_a566eb7823aed0eeb25556218a8aac8aa}\label{namespacenetworkx_1_1convert__matrix_a566eb7823aed0eeb25556218a8aac8aa}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!from\+\_\+pandas\+\_\+adjacency@{from\+\_\+pandas\+\_\+adjacency}}
\index{from\+\_\+pandas\+\_\+adjacency@{from\+\_\+pandas\+\_\+adjacency}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{from\+\_\+pandas\+\_\+adjacency()}{from\_pandas\_adjacency()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+from\+\_\+pandas\+\_\+adjacency (\begin{DoxyParamCaption}\item[{}]{df,  }\item[{}]{create\+\_\+using = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a graph from Pandas DataFrame.

The Pandas DataFrame is interpreted as an adjacency matrix for the graph.

Parameters
----------
df : Pandas DataFrame
  An adjacency matrix representation of a graph

create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Notes
-----
For directed graphs, explicitly mention create_using=nx.DiGraph,
and entry i,j of df corresponds to an edge from i to j.

If `df` has a single data type for each entry it will be converted to an
appropriate Python data type.

If `df` has a user-specified compound data type the names
of the data fields will be used as attribute keys in the resulting
NetworkX graph.

See Also
--------
to_pandas_adjacency

Examples
--------
Simple integer weights on edges:

>>> import pandas as pd
>>> pd.options.display.max_columns = 20
>>> df = pd.DataFrame([[1, 1], [2, 1]])
>>> df
   0  1
0  1  1
1  2  1
>>> G = nx.from_pandas_adjacency(df)
>>> G.name = "Graph from pandas adjacency matrix"
>>> print(nx.info(G))
Graph named 'Graph from pandas adjacency matrix' with 2 nodes and 3 edges
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_a985798534d023762687a19185c0eb578}\label{namespacenetworkx_1_1convert__matrix_a985798534d023762687a19185c0eb578}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!from\+\_\+pandas\+\_\+edgelist@{from\+\_\+pandas\+\_\+edgelist}}
\index{from\+\_\+pandas\+\_\+edgelist@{from\+\_\+pandas\+\_\+edgelist}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{from\+\_\+pandas\+\_\+edgelist()}{from\_pandas\_edgelist()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+from\+\_\+pandas\+\_\+edgelist (\begin{DoxyParamCaption}\item[{}]{df,  }\item[{}]{source = {\ttfamily \char`\"{}source\char`\"{}},  }\item[{}]{target = {\ttfamily \char`\"{}target\char`\"{}},  }\item[{}]{edge\+\_\+attr = {\ttfamily None},  }\item[{}]{create\+\_\+using = {\ttfamily None},  }\item[{}]{edge\+\_\+key = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a graph from Pandas DataFrame containing an edge list.

The Pandas DataFrame should contain at least two columns of node names and
zero or more columns of edge attributes. Each row will be processed as one
edge instance.

Note: This function iterates over DataFrame.values, which is not
guaranteed to retain the data type across columns in the row. This is only
a problem if your row is entirely numeric and a mix of ints and floats. In
that case, all values will be returned as floats. See the
DataFrame.iterrows documentation for an example.

Parameters
----------
df : Pandas DataFrame
    An edge list representation of a graph

source : str or int
    A valid column name (string or integer) for the source nodes (for the
    directed case).

target : str or int
    A valid column name (string or integer) for the target nodes (for the
    directed case).

edge_attr : str or int, iterable, True, or None
    A valid column name (str or int) or iterable of column names that are
    used to retrieve items and add them to the graph as edge attributes.
    If `True`, all of the remaining columns will be added.
    If `None`, no edge attributes are added to the graph.

create_using : NetworkX graph constructor, optional (default=nx.Graph)
    Graph type to create. If graph instance, then cleared before populated.

edge_key : str or None, optional (default=None)
    A valid column name for the edge keys (for a MultiGraph). The values in
    this column are used for the edge keys when adding edges if create_using
    is a multigraph.

See Also
--------
to_pandas_edgelist

Examples
--------
Simple integer weights on edges:

>>> import pandas as pd
>>> pd.options.display.max_columns = 20
>>> import numpy as np
>>> rng = np.random.RandomState(seed=5)
>>> ints = rng.randint(1, 11, size=(3, 2))
>>> a = ["A", "B", "C"]
>>> b = ["D", "A", "E"]
>>> df = pd.DataFrame(ints, columns=["weight", "cost"])
>>> df[0] = a
>>> df["b"] = b
>>> df[["weight", "cost", 0, "b"]]
   weight  cost  0  b
0       4     7  A  D
1       7     1  B  A
2      10     9  C  E
>>> G = nx.from_pandas_edgelist(df, 0, "b", ["weight", "cost"])
>>> G["E"]["C"]["weight"]
10
>>> G["E"]["C"]["cost"]
9
>>> edges = pd.DataFrame(
...     {
...         "source": [0, 1, 2],
...         "target": [2, 2, 3],
...         "weight": [3, 4, 5],
...         "color": ["red", "blue", "blue"],
...     }
... )
>>> G = nx.from_pandas_edgelist(edges, edge_attr=True)
>>> G[0][2]["color"]
'red'

Build multigraph with custom keys:

>>> edges = pd.DataFrame(
...     {
...         "source": [0, 1, 2, 0],
...         "target": [2, 2, 3, 2],
...         "my_edge_key": ["A", "B", "C", "D"],
...         "weight": [3, 4, 5, 6],
...         "color": ["red", "blue", "blue", "blue"],
...     }
... )
>>> G = nx.from_pandas_edgelist(
...     edges,
...     edge_key="my_edge_key",
...     edge_attr=["weight", "color"],
...     create_using=nx.MultiGraph(),
... )
>>> G[0][2]
AtlasView({'A': {'weight': 3, 'color': 'red'}, 'D': {'weight': 6, 'color': 'blue'}})\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_ac8fbd2e587cd297b41557ad1299a9e7d}\label{namespacenetworkx_1_1convert__matrix_ac8fbd2e587cd297b41557ad1299a9e7d}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!from\+\_\+scipy\+\_\+sparse\+\_\+matrix@{from\+\_\+scipy\+\_\+sparse\+\_\+matrix}}
\index{from\+\_\+scipy\+\_\+sparse\+\_\+matrix@{from\+\_\+scipy\+\_\+sparse\+\_\+matrix}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{from\+\_\+scipy\+\_\+sparse\+\_\+matrix()}{from\_scipy\_sparse\_matrix()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+from\+\_\+scipy\+\_\+sparse\+\_\+matrix (\begin{DoxyParamCaption}\item[{}]{A,  }\item[{}]{parallel\+\_\+edges = {\ttfamily False},  }\item[{}]{create\+\_\+using = {\ttfamily None},  }\item[{}]{edge\+\_\+attribute = {\ttfamily \char`\"{}weight\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Creates a new graph from an adjacency matrix given as a SciPy sparse
matrix.

Parameters
----------
A: scipy sparse matrix
  An adjacency matrix representation of a graph

parallel_edges : Boolean
  If this is True, `create_using` is a multigraph, and `A` is an
  integer matrix, then entry *(i, j)* in the matrix is interpreted as the
  number of parallel edges joining vertices *i* and *j* in the graph.
  If it is False, then the entries in the matrix are interpreted as
  the weight of a single edge joining the vertices.

create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

edge_attribute: string
   Name of edge attribute to store matrix numeric value. The data will
   have the same type as the matrix entry (int, float, (real,imag)).

Notes
-----
For directed graphs, explicitly mention create_using=nx.DiGraph,
and entry i,j of A corresponds to an edge from i to j.

If `create_using` is :class:`networkx.MultiGraph` or
:class:`networkx.MultiDiGraph`, `parallel_edges` is True, and the
entries of `A` are of type :class:`int`, then this function returns a
multigraph (constructed from `create_using`) with parallel edges.
In this case, `edge_attribute` will be ignored.

If `create_using` indicates an undirected multigraph, then only the edges
indicated by the upper triangle of the matrix `A` will be added to the
graph.

Examples
--------
>>> import scipy as sp
>>> import scipy.sparse  # call as sp.sparse
>>> A = sp.sparse.eye(2, 2, 1)
>>> G = nx.from_scipy_sparse_matrix(A)

If `create_using` indicates a multigraph and the matrix has only integer
entries and `parallel_edges` is False, then the entries will be treated
as weights for edges joining the nodes (without creating parallel edges):

>>> A = sp.sparse.csr_matrix([[1, 1], [1, 2]])
>>> G = nx.from_scipy_sparse_matrix(A, create_using=nx.MultiGraph)
>>> G[1][1]
AtlasView({0: {'weight': 2}})

If `create_using` indicates a multigraph and the matrix has only integer
entries and `parallel_edges` is True, then the entries will be treated
as the number of parallel edges joining those two vertices:

>>> A = sp.sparse.csr_matrix([[1, 1], [1, 2]])
>>> G = nx.from_scipy_sparse_matrix(
...     A, parallel_edges=True, create_using=nx.MultiGraph
... )
>>> G[1][1]
AtlasView({0: {'weight': 1}, 1: {'weight': 1}})\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_acff6b353b4693143c1fad4d2c1c7a335}\label{namespacenetworkx_1_1convert__matrix_acff6b353b4693143c1fad4d2c1c7a335}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!to\+\_\+numpy\+\_\+array@{to\+\_\+numpy\+\_\+array}}
\index{to\+\_\+numpy\+\_\+array@{to\+\_\+numpy\+\_\+array}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{to\+\_\+numpy\+\_\+array()}{to\_numpy\_array()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+to\+\_\+numpy\+\_\+array (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{nodelist = {\ttfamily None},  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{multigraph\+\_\+weight = {\ttfamily \hyperlink{assumed__shape_2foo__free_8f90_a1c860bb40bf43c289bc16f8634733f9a}{sum}},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{nonedge = {\ttfamily 0.0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the graph adjacency matrix as a NumPy array.

Parameters
----------
G : graph
    The NetworkX graph used to construct the NumPy array.

nodelist : list, optional
    The rows and columns are ordered according to the nodes in `nodelist`.
    If `nodelist` is None, then the ordering is produced by G.nodes().

dtype : NumPy data type, optional
    A valid single NumPy data type used to initialize the array.
    This must be a simple type such as int or numpy.float64 and
    not a compound data type (see to_numpy_recarray)
    If None, then the NumPy default is used.

order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory. If None, then the NumPy default
    is used.

multigraph_weight : {sum, min, max}, optional
    An operator that determines how weights in multigraphs are handled.
    The default is to sum the weights of the multiple edges.

weight : string or None optional (default = 'weight')
    The edge attribute that holds the numerical value used for
    the edge weight. If an edge does not have that attribute, then the
    value 1 is used instead.

nonedge : float (default = 0.0)
    The array values corresponding to nonedges are typically set to zero.
    However, this could be undesirable if there are array values
    corresponding to actual edges that also have the value zero. If so,
    one might prefer nonedges to have some other value, such as nan.

Returns
-------
A : NumPy ndarray
    Graph adjacency matrix

See Also
--------
from_numpy_array

Notes
-----
For directed graphs, entry i,j corresponds to an edge from i to j.

Entries in the adjacency matrix are assigned to the weight edge attribute.
When an edge does not have a weight attribute, the value of the entry is
set to the number 1.  For multiple (parallel) edges, the values of the
entries are determined by the `multigraph_weight` parameter. The default is
to sum the weight attributes for each of the parallel edges.

When `nodelist` does not contain every node in `G`, the adjacency matrix is
built from the subgraph of `G` that is induced by the nodes in `nodelist`.

The convention used for self-loop edges in graphs is to assign the
diagonal array entry value to the weight attribute of the edge
(or the number 1 if the edge has no weight attribute). If the
alternate convention of doubling the edge weight is desired the
resulting NumPy array can be modified as follows:

>>> import numpy as np
>>> G = nx.Graph([(1, 1)])
>>> A = nx.to_numpy_array(G)
>>> A
array([[1.]])
>>> A[np.diag_indices_from(A)] *= 2
>>> A
array([[2.]])

Examples
--------
>>> G = nx.MultiDiGraph()
>>> G.add_edge(0, 1, weight=2)
0
>>> G.add_edge(1, 0)
0
>>> G.add_edge(2, 2, weight=3)
0
>>> G.add_edge(2, 2)
1
>>> nx.to_numpy_array(G, nodelist=[0, 1, 2])
array([[0., 2., 0.],
       [1., 0., 0.],
       [0., 0., 4.]])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_a3a9192800f2d95a6d3588aa9e4516d20}\label{namespacenetworkx_1_1convert__matrix_a3a9192800f2d95a6d3588aa9e4516d20}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!to\+\_\+numpy\+\_\+matrix@{to\+\_\+numpy\+\_\+matrix}}
\index{to\+\_\+numpy\+\_\+matrix@{to\+\_\+numpy\+\_\+matrix}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{to\+\_\+numpy\+\_\+matrix()}{to\_numpy\_matrix()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+to\+\_\+numpy\+\_\+matrix (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{nodelist = {\ttfamily None},  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{multigraph\+\_\+weight = {\ttfamily \hyperlink{assumed__shape_2foo__free_8f90_a1c860bb40bf43c289bc16f8634733f9a}{sum}},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{nonedge = {\ttfamily 0.0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the graph adjacency matrix as a NumPy matrix.

Parameters
----------
G : graph
    The NetworkX graph used to construct the NumPy matrix.

nodelist : list, optional
    The rows and columns are ordered according to the nodes in `nodelist`.
    If `nodelist` is None, then the ordering is produced by G.nodes().

dtype : NumPy data type, optional
    A valid single NumPy data type used to initialize the array.
    This must be a simple type such as int or numpy.float64 and
    not a compound data type (see to_numpy_recarray)
    If None, then the NumPy default is used.

order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory. If None, then the NumPy default
    is used.

multigraph_weight : {sum, min, max}, optional
    An operator that determines how weights in multigraphs are handled.
    The default is to sum the weights of the multiple edges.

weight : string or None optional (default = 'weight')
    The edge attribute that holds the numerical value used for
    the edge weight. If an edge does not have that attribute, then the
    value 1 is used instead.

nonedge : float (default = 0.0)
    The matrix values corresponding to nonedges are typically set to zero.
    However, this could be undesirable if there are matrix values
    corresponding to actual edges that also have the value zero. If so,
    one might prefer nonedges to have some other value, such as nan.

Returns
-------
M : NumPy matrix
    Graph adjacency matrix

See Also
--------
to_numpy_recarray

Notes
-----
For directed graphs, entry i,j corresponds to an edge from i to j.

The matrix entries are assigned to the weight edge attribute. When
an edge does not have a weight attribute, the value of the entry is set to
the number 1.  For multiple (parallel) edges, the values of the entries
are determined by the `multigraph_weight` parameter.  The default is to
sum the weight attributes for each of the parallel edges.

When `nodelist` does not contain every node in `G`, the matrix is built
from the subgraph of `G` that is induced by the nodes in `nodelist`.

The convention used for self-loop edges in graphs is to assign the
diagonal matrix entry value to the weight attribute of the edge
(or the number 1 if the edge has no weight attribute).  If the
alternate convention of doubling the edge weight is desired the
resulting Numpy matrix can be modified as follows:

>>> import numpy as np
>>> G = nx.Graph([(1, 1)])
>>> A = nx.to_numpy_matrix(G)
>>> A
matrix([[1.]])
>>> A[np.diag_indices_from(A)] *= 2
>>> A
matrix([[2.]])

Examples
--------
>>> G = nx.MultiDiGraph()
>>> G.add_edge(0, 1, weight=2)
0
>>> G.add_edge(1, 0)
0
>>> G.add_edge(2, 2, weight=3)
0
>>> G.add_edge(2, 2)
1
>>> nx.to_numpy_matrix(G, nodelist=[0, 1, 2])
matrix([[0., 2., 0.],
        [1., 0., 0.],
        [0., 0., 4.]])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_ad41194dd5380831f9c70606b71bb3b07}\label{namespacenetworkx_1_1convert__matrix_ad41194dd5380831f9c70606b71bb3b07}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!to\+\_\+numpy\+\_\+recarray@{to\+\_\+numpy\+\_\+recarray}}
\index{to\+\_\+numpy\+\_\+recarray@{to\+\_\+numpy\+\_\+recarray}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{to\+\_\+numpy\+\_\+recarray()}{to\_numpy\_recarray()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+to\+\_\+numpy\+\_\+recarray (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{nodelist = {\ttfamily None},  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the graph adjacency matrix as a NumPy recarray.

Parameters
----------
G : graph
    The NetworkX graph used to construct the NumPy recarray.

nodelist : list, optional
   The rows and columns are ordered according to the nodes in `nodelist`.
   If `nodelist` is None, then the ordering is produced by G.nodes().

dtype : NumPy data-type, optional
    A valid NumPy named dtype used to initialize the NumPy recarray.
    The data type names are assumed to be keys in the graph edge attribute
    dictionary.

order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory. If None, then the NumPy default
    is used.

Returns
-------
M : NumPy recarray
   The graph with specified edge data as a Numpy recarray

Notes
-----
When `nodelist` does not contain every node in `G`, the adjacency
matrix is built from the subgraph of `G` that is induced by the nodes in
`nodelist`.

Examples
--------
>>> G = nx.Graph()
>>> G.add_edge(1, 2, weight=7.0, cost=5)
>>> A = nx.to_numpy_recarray(G, dtype=[("weight", float), ("cost", int)])
>>> print(A.weight)
[[0. 7.]
 [7. 0.]]
>>> print(A.cost)
[[0 5]
 [5 0]]\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_a0153ce03fb37943dab6046e07b4bffc0}\label{namespacenetworkx_1_1convert__matrix_a0153ce03fb37943dab6046e07b4bffc0}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!to\+\_\+pandas\+\_\+adjacency@{to\+\_\+pandas\+\_\+adjacency}}
\index{to\+\_\+pandas\+\_\+adjacency@{to\+\_\+pandas\+\_\+adjacency}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{to\+\_\+pandas\+\_\+adjacency()}{to\_pandas\_adjacency()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+to\+\_\+pandas\+\_\+adjacency (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{nodelist = {\ttfamily None},  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{multigraph\+\_\+weight = {\ttfamily \hyperlink{assumed__shape_2foo__free_8f90_a1c860bb40bf43c289bc16f8634733f9a}{sum}},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{nonedge = {\ttfamily 0.0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the graph adjacency matrix as a Pandas DataFrame.

Parameters
----------
G : graph
    The NetworkX graph used to construct the Pandas DataFrame.

nodelist : list, optional
   The rows and columns are ordered according to the nodes in `nodelist`.
   If `nodelist` is None, then the ordering is produced by G.nodes().

multigraph_weight : {sum, min, max}, optional
    An operator that determines how weights in multigraphs are handled.
    The default is to sum the weights of the multiple edges.

weight : string or None, optional
    The edge attribute that holds the numerical value used for
    the edge weight.  If an edge does not have that attribute, then the
    value 1 is used instead.

nonedge : float, optional
    The matrix values corresponding to nonedges are typically set to zero.
    However, this could be undesirable if there are matrix values
    corresponding to actual edges that also have the value zero. If so,
    one might prefer nonedges to have some other value, such as nan.

Returns
-------
df : Pandas DataFrame
   Graph adjacency matrix

Notes
-----
For directed graphs, entry i,j corresponds to an edge from i to j.

The DataFrame entries are assigned to the weight edge attribute. When
an edge does not have a weight attribute, the value of the entry is set to
the number 1.  For multiple (parallel) edges, the values of the entries
are determined by the 'multigraph_weight' parameter.  The default is to
sum the weight attributes for each of the parallel edges.

When `nodelist` does not contain every node in `G`, the matrix is built
from the subgraph of `G` that is induced by the nodes in `nodelist`.

The convention used for self-loop edges in graphs is to assign the
diagonal matrix entry value to the weight attribute of the edge
(or the number 1 if the edge has no weight attribute).  If the
alternate convention of doubling the edge weight is desired the
resulting Pandas DataFrame can be modified as follows:

>>> import pandas as pd
>>> pd.options.display.max_columns = 20
>>> import numpy as np
>>> G = nx.Graph([(1, 1)])
>>> df = nx.to_pandas_adjacency(G, dtype=int)
>>> df
   1
1  1
>>> df.values[np.diag_indices_from(df)] *= 2
>>> df
   1
1  2

Examples
--------
>>> G = nx.MultiDiGraph()
>>> G.add_edge(0, 1, weight=2)
0
>>> G.add_edge(1, 0)
0
>>> G.add_edge(2, 2, weight=3)
0
>>> G.add_edge(2, 2)
1
>>> nx.to_pandas_adjacency(G, nodelist=[0, 1, 2], dtype=int)
   0  1  2
0  0  2  0
1  1  0  0
2  0  0  4\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_a6f3984434d922d8f5ee4fc1aff940004}\label{namespacenetworkx_1_1convert__matrix_a6f3984434d922d8f5ee4fc1aff940004}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!to\+\_\+pandas\+\_\+edgelist@{to\+\_\+pandas\+\_\+edgelist}}
\index{to\+\_\+pandas\+\_\+edgelist@{to\+\_\+pandas\+\_\+edgelist}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{to\+\_\+pandas\+\_\+edgelist()}{to\_pandas\_edgelist()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+to\+\_\+pandas\+\_\+edgelist (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{source = {\ttfamily \char`\"{}source\char`\"{}},  }\item[{}]{target = {\ttfamily \char`\"{}target\char`\"{}},  }\item[{}]{nodelist = {\ttfamily None},  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{order = {\ttfamily None},  }\item[{}]{edge\+\_\+key = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the graph edge list as a Pandas DataFrame.

Parameters
----------
G : graph
    The NetworkX graph used to construct the Pandas DataFrame.

source : str or int, optional
    A valid column name (string or integer) for the source nodes (for the
    directed case).

target : str or int, optional
    A valid column name (string or integer) for the target nodes (for the
    directed case).

nodelist : list, optional
   Use only nodes specified in nodelist

dtype : dtype, default None
    Use to create the DataFrame. Data type to force.
    Only a single dtype is allowed. If None, infer.

order : None
    An unused parameter mistakenly included in the function.

    .. deprecated:: 2.6
        This is deprecated and will be removed in NetworkX v3.0.

edge_key : str or int or None, optional (default=None)
    A valid column name (string or integer) for the edge keys (for the
    multigraph case). If None, edge keys are not stored in the DataFrame.

Returns
-------
df : Pandas DataFrame
   Graph edge list

Examples
--------
>>> G = nx.Graph(
...     [
...         ("A", "B", {"cost": 1, "weight": 7}),
...         ("C", "E", {"cost": 9, "weight": 10}),
...     ]
... )
>>> df = nx.to_pandas_edgelist(G, nodelist=["A", "C"])
>>> df[["source", "target", "cost", "weight"]]
  source target  cost  weight
0      A      B     1       7
1      C      E     9      10

>>> G = nx.MultiGraph([('A', 'B', {'cost': 1}), ('A', 'B', {'cost': 9})])
>>> df = nx.to_pandas_edgelist(G, nodelist=['A', 'C'], edge_key='ekey')
>>> df[['source', 'target', 'cost', 'ekey']]
  source target  cost  ekey
0      A      B     1     0
1      A      B     9     1\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1convert__matrix_a47cedef23442ab34bf69fffb4119a442}\label{namespacenetworkx_1_1convert__matrix_a47cedef23442ab34bf69fffb4119a442}} 
\index{networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}!to\+\_\+scipy\+\_\+sparse\+\_\+matrix@{to\+\_\+scipy\+\_\+sparse\+\_\+matrix}}
\index{to\+\_\+scipy\+\_\+sparse\+\_\+matrix@{to\+\_\+scipy\+\_\+sparse\+\_\+matrix}!networkx\+::convert\+\_\+matrix@{networkx\+::convert\+\_\+matrix}}
\subsubsection{\texorpdfstring{to\+\_\+scipy\+\_\+sparse\+\_\+matrix()}{to\_scipy\_sparse\_matrix()}}
{\footnotesize\ttfamily def networkx.\+convert\+\_\+matrix.\+to\+\_\+scipy\+\_\+sparse\+\_\+matrix (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{nodelist = {\ttfamily None},  }\item[{}]{dtype = {\ttfamily None},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{format = {\ttfamily \char`\"{}csr\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the graph adjacency matrix as a SciPy sparse matrix.

Parameters
----------
G : graph
    The NetworkX graph used to construct the sparse matrix.

nodelist : list, optional
   The rows and columns are ordered according to the nodes in `nodelist`.
   If `nodelist` is None, then the ordering is produced by G.nodes().

dtype : NumPy data-type, optional
    A valid NumPy dtype used to initialize the array. If None, then the
    NumPy default is used.

weight : string or None   optional (default='weight')
    The edge attribute that holds the numerical value used for
    the edge weight.  If None then all edge weights are 1.

format : str in {'bsr', 'csr', 'csc', 'coo', 'lil', 'dia', 'dok'}
    The type of the matrix to be returned (default 'csr').  For
    some algorithms different implementations of sparse matrices
    can perform better.  See [1]_ for details.

Returns
-------
M : SciPy sparse matrix
   Graph adjacency matrix.

Notes
-----
For directed graphs, matrix entry i,j corresponds to an edge from i to j.

The matrix entries are populated using the edge attribute held in
parameter weight. When an edge does not have that attribute, the
value of the entry is 1.

For multiple edges the matrix values are the sums of the edge weights.

When `nodelist` does not contain every node in `G`, the adjacency matrix
is built from the subgraph of `G` that is induced by the nodes in
`nodelist`.

The convention used for self-loop edges in graphs is to assign the
diagonal matrix entry value to the weight attribute of the edge
(or the number 1 if the edge has no weight attribute).  If the
alternate convention of doubling the edge weight is desired the
resulting Scipy sparse matrix can be modified as follows:

>>> G = nx.Graph([(1, 1)])
>>> A = nx.to_scipy_sparse_matrix(G)
>>> print(A.todense())
[[1]]
>>> A.setdiag(A.diagonal() * 2)
>>> print(A.todense())
[[2]]

Examples
--------
>>> G = nx.MultiDiGraph()
>>> G.add_edge(0, 1, weight=2)
0
>>> G.add_edge(1, 0)
0
>>> G.add_edge(2, 2, weight=3)
0
>>> G.add_edge(2, 2)
1
>>> S = nx.to_scipy_sparse_matrix(G, nodelist=[0, 1, 2])
>>> print(S.todense())
[[0 2 0]
 [1 0 0]
 [0 0 4]]

References
----------
.. [1] Scipy Dev. References, "Sparse Matrices",
   https://docs.scipy.org/doc/scipy/reference/sparse.html
\end{DoxyVerb}
 