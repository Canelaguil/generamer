\hypertarget{namespacenetworkx_1_1relabel}{}\section{networkx.\+relabel Namespace Reference}
\label{namespacenetworkx_1_1relabel}\index{networkx.\+relabel@{networkx.\+relabel}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1relabel_acb2e932876a58ed2a6eea531eb4f64f7}{relabel\+\_\+nodes} (G, mapping, copy=True)
\item 
def \hyperlink{namespacenetworkx_1_1relabel_a5bef030d4c309b275324f4578af84f76}{convert\+\_\+node\+\_\+labels\+\_\+to\+\_\+integers} (G, first\+\_\+label=0, ordering=\char`\"{}default\char`\"{}, label\+\_\+attribute=None)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1relabel_a5bef030d4c309b275324f4578af84f76}\label{namespacenetworkx_1_1relabel_a5bef030d4c309b275324f4578af84f76}} 
\index{networkx\+::relabel@{networkx\+::relabel}!convert\+\_\+node\+\_\+labels\+\_\+to\+\_\+integers@{convert\+\_\+node\+\_\+labels\+\_\+to\+\_\+integers}}
\index{convert\+\_\+node\+\_\+labels\+\_\+to\+\_\+integers@{convert\+\_\+node\+\_\+labels\+\_\+to\+\_\+integers}!networkx\+::relabel@{networkx\+::relabel}}
\subsubsection{\texorpdfstring{convert\+\_\+node\+\_\+labels\+\_\+to\+\_\+integers()}{convert\_node\_labels\_to\_integers()}}
{\footnotesize\ttfamily def networkx.\+relabel.\+convert\+\_\+node\+\_\+labels\+\_\+to\+\_\+integers (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{first\+\_\+label = {\ttfamily 0},  }\item[{}]{ordering = {\ttfamily \char`\"{}default\char`\"{}},  }\item[{}]{label\+\_\+attribute = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a copy of the graph G with the nodes relabeled using
consecutive integers.

Parameters
----------
G : graph
   A NetworkX graph

first_label : int, optional (default=0)
   An integer specifying the starting offset in numbering nodes.
   The new integer labels are numbered first_label, ..., n-1+first_label.

ordering : string
   "default" : inherit node ordering from G.nodes()
   "sorted"  : inherit node ordering from sorted(G.nodes())
   "increasing degree" : nodes are sorted by increasing degree
   "decreasing degree" : nodes are sorted by decreasing degree

label_attribute : string, optional (default=None)
   Name of node attribute to store old label.  If None no attribute
   is created.

Notes
-----
Node and edge attribute data are copied to the new (relabeled) graph.

There is no guarantee that the relabeling of nodes to integers will
give the same two integers for two (even identical graphs).
Use the `ordering` argument to try to preserve the order.

See Also
--------
relabel_nodes
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1relabel_acb2e932876a58ed2a6eea531eb4f64f7}\label{namespacenetworkx_1_1relabel_acb2e932876a58ed2a6eea531eb4f64f7}} 
\index{networkx\+::relabel@{networkx\+::relabel}!relabel\+\_\+nodes@{relabel\+\_\+nodes}}
\index{relabel\+\_\+nodes@{relabel\+\_\+nodes}!networkx\+::relabel@{networkx\+::relabel}}
\subsubsection{\texorpdfstring{relabel\+\_\+nodes()}{relabel\_nodes()}}
{\footnotesize\ttfamily def networkx.\+relabel.\+relabel\+\_\+nodes (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{mapping,  }\item[{}]{copy = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Relabel the nodes of the graph G according to a given mapping.

Parameters
----------
G : graph
   A NetworkX graph

mapping : dictionary
   A dictionary with the old labels as keys and new labels as values.
   A partial mapping is allowed. Mapping 2 nodes to a single node is allowed.
   Any non-node keys in the mapping are ignored.

copy : bool (optional, default=True)
   If True return a copy, or if False relabel the nodes in place.

Examples
--------
To create a new graph with nodes relabeled according to a given
dictionary:

>>> G = nx.path_graph(3)
>>> sorted(G)
[0, 1, 2]
>>> mapping = {0: "a", 1: "b", 2: "c"}
>>> H = nx.relabel_nodes(G, mapping)
>>> sorted(H)
['a', 'b', 'c']

Nodes can be relabeled with any hashable object, including numbers
and strings:

>>> import string
>>> G = nx.path_graph(26)  # nodes are integers 0 through 25
>>> sorted(G)[:3]
[0, 1, 2]
>>> mapping = dict(zip(G, string.ascii_lowercase))
>>> G = nx.relabel_nodes(G, mapping)  # nodes are characters a through z
>>> sorted(G)[:3]
['a', 'b', 'c']
>>> mapping = dict(zip(G, range(1, 27)))
>>> G = nx.relabel_nodes(G, mapping)  # nodes are integers 1 through 26
>>> sorted(G)[:3]
[1, 2, 3]

To perform a partial in-place relabeling, provide a dictionary
mapping only a subset of the nodes, and set the `copy` keyword
argument to False:

>>> G = nx.path_graph(3)  # nodes 0-1-2
>>> mapping = {0: "a", 1: "b"}  # 0->'a' and 1->'b'
>>> G = nx.relabel_nodes(G, mapping, copy=False)
>>> sorted(G, key=str)
[2, 'a', 'b']

A mapping can also be given as a function:

>>> G = nx.path_graph(3)
>>> H = nx.relabel_nodes(G, lambda x: x ** 2)
>>> list(H)
[0, 1, 4]

In a multigraph, relabeling two or more nodes to the same new node
will retain all edges, but may change the edge keys in the process:

>>> G = nx.MultiGraph()
>>> G.add_edge(0, 1, value="a")  # returns the key for this edge
0
>>> G.add_edge(0, 2, value="b")
0
>>> G.add_edge(0, 3, value="c")
0
>>> mapping = {1: 4, 2: 4, 3: 4}
>>> H = nx.relabel_nodes(G, mapping, copy=True)
>>> print(H[0])
{4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}

This works for in-place relabeling too:

>>> G = nx.relabel_nodes(G, mapping, copy=False)
>>> print(G[0])
{4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}

Notes
-----
Only the nodes specified in the mapping will be relabeled.
Any non-node keys in the mapping are ignored.

The keyword setting copy=False modifies the graph in place.
Relabel_nodes avoids naming collisions by building a
directed graph from ``mapping`` which specifies the order of
relabelings. Naming collisions, such as a->b, b->c, are ordered
such that "b" gets renamed to "c" before "a" gets renamed "b".
In cases of circular mappings (e.g. a->b, b->a), modifying the
graph is not possible in-place and an exception is raised.
In that case, use copy=True.

If a relabel operation on a multigraph would cause two or more
edges to have the same source, target and key, the second edge must
be assigned a new key to retain all edges. The new key is set
to the lowest non-negative integer not already used as a key
for edges between these two nodes. Note that this means non-numeric
keys may be replaced by numeric keys.

See Also
--------
convert_node_labels_to_integers
\end{DoxyVerb}
 