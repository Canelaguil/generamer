\hypertarget{classpyparsing_1_1ParserElement}{}\section{pyparsing.\+Parser\+Element Class Reference}
\label{classpyparsing_1_1ParserElement}\index{pyparsing.\+Parser\+Element@{pyparsing.\+Parser\+Element}}


Inheritance diagram for pyparsing.\+Parser\+Element\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classpyparsing_1_1ParserElement__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for pyparsing.\+Parser\+Element\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=206pt]{classpyparsing_1_1ParserElement__coll__graph}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classpyparsing_1_1ParserElement_1_1__FifoCache}{\+\_\+\+Fifo\+Cache}
\item 
class \hyperlink{classpyparsing_1_1ParserElement_1_1__UnboundedCache}{\+\_\+\+Unbounded\+Cache}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classpyparsing_1_1ParserElement_af2b1ea2e6dddf5043eb401bfaf114463}{\+\_\+\+\_\+init\+\_\+\+\_\+} (self, savelist=False)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a1fc11c0465d31bf37eb92f7a5cd8c6a4}{copy} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a8197a4fff4f269747bb21028452a3755}{set\+Name} (self, \hyperlink{classpyparsing_1_1ParserElement_ab51381d24c5bc721b4a4764af8d9b470}{name})
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a4996c883b285fef6c89b2b5caf675fd0}{set\+Results\+Name} (self, \hyperlink{classpyparsing_1_1ParserElement_ab51381d24c5bc721b4a4764af8d9b470}{name}, list\+All\+Matches=False)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a078b62d7a0d94fdb5755c196347022ab}{set\+Break} (self, break\+Flag=True)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ad19e8d671046a66846d01f0604618f97}{set\+Parse\+Action} (self, fns, kwargs)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a21f4bd9d7b1c9e8c18b94e4f8d2b1951}{add\+Parse\+Action} (self, fns, kwargs)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a9fce1e8f3c0c4693eb5cd60223b0a5fc}{add\+Condition} (self, fns, kwargs)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a38989383d034cbd8b3723141d1c43ffd}{set\+Fail\+Action} (self, fn)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ac97092fcb02cd6696f51185cfceeac59}{pre\+Parse} (self, instring, loc)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a329bcec7d8f7ef6875b9390787536e5b}{parse\+Impl} (self, instring, loc, do\+Actions=True)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a3b6548ce7bb9df91108b4f923c25137c}{post\+Parse} (self, instring, loc, tokenlist)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a0f4f5dac320faf316bd8a54022f4345e}{try\+Parse} (self, instring, loc)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_aa032e6999773cbb5c0048eb9b2b6bacb}{can\+Parse\+Next} (self, instring, loc)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a0026d86408e4fb2faa89c985dcb89738}{parse\+String} (self, instring, parse\+All=False)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ae2359510cb75269e8f67637112ca4783}{scan\+String} (self, instring, max\+Matches=\+\_\+\+M\+A\+X\+\_\+\+I\+NT, overlap=False)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_aafab376b2c6bc61873e532f2042d5425}{transform\+String} (self, instring)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_abd33d51600731c951b6bc96452fa6bdd}{search\+String} (self, instring, max\+Matches=\+\_\+\+M\+A\+X\+\_\+\+I\+NT)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a8db51e82054675b073d5d03b58da4091}{split} (self, instring, maxsplit=\+\_\+\+M\+A\+X\+\_\+\+I\+NT, include\+Separators=False)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a21a06c8513b9a6be62c04b3f9589b985}{\+\_\+\+\_\+add\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a34941605b7030012a62dca995bda150c}{\+\_\+\+\_\+radd\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_afd1c67a708145e87a941f1ef32858821}{\+\_\+\+\_\+sub\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a1c075a3fb139c15e476cd8c0f0fb143e}{\+\_\+\+\_\+rsub\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ada800b289dc07ee269e242ae6f877a4b}{\+\_\+\+\_\+mul\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a2efd1d93a31fbff485aa32b1e9fc2059}{\+\_\+\+\_\+rmul\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a1c5f1f8d8ba28723519c37d3416cf6c0}{\+\_\+\+\_\+or\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ab552d5b159a2e499fd867f183fec259f}{\+\_\+\+\_\+ror\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_adc202acd38036ea9b404b20bc9833cbe}{\+\_\+\+\_\+xor\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a1192254acf0ffd8b84034e984e271e1b}{\+\_\+\+\_\+rxor\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a243eaac2e462c82b0cb8fde4108afbf7}{\+\_\+\+\_\+and\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_aeee7cc2cc9529f45892705c80a41aced}{\+\_\+\+\_\+rand\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_aecad4d0c5430e41858a02de5ed5611e0}{\+\_\+\+\_\+invert\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a8c8264e791744827f5d9857c85fe33cf}{\+\_\+\+\_\+iter\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a5ec18bd599ba5e749056ebe43e3d7bf3}{\+\_\+\+\_\+getitem\+\_\+\+\_\+} (self, key)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a46450a967b8cf18e76e893532de0ecd7}{\+\_\+\+\_\+call\+\_\+\+\_\+} (self, \hyperlink{classpyparsing_1_1ParserElement_ab51381d24c5bc721b4a4764af8d9b470}{name}=None)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_aa59fe575380165c82b618b55e91ef0a5}{suppress} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ac3de85a4c5fed7bc8d10967c7c985f8a}{leave\+Whitespace} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a02335ae8eec55cf3944fd79769a4104e}{set\+Whitespace\+Chars} (self, chars)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_af81ca1164a8903a8595c1bfec35316cd}{parse\+With\+Tabs} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ae091af36b550112da1a00aa314206d2d}{ignore} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a75debf95f36a4f456b6760a315587c50}{set\+Debug\+Actions} (self, start\+Action, success\+Action, exception\+Action)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ac5d0f98e4a43fd89567d218b36229eae}{set\+Debug} (self, flag=True)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a72ae436ae72b12a0e03572f62f5a35ae}{\+\_\+\+\_\+str\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a299291d78f90aae57bb292bba93f41cf}{\+\_\+\+\_\+repr\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a09856e9ee0198b9e5da936e4f401f2f2}{streamline} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a46cfe4be87dff6cb52586a0b4ead2b79}{check\+Recursion} (self, parse\+Element\+List)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ab3aa74c2cd7880b45b594e8cfea22a07}{validate} (self, validate\+Trace=None)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a5076b859e68470bd5fbe3f993be3e187}{parse\+File} (self, file\+\_\+or\+\_\+filename, parse\+All=False)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_adff8e67070c5b194296539a11fa5c322}{\+\_\+\+\_\+eq\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a3ac9c1ebf1401b4aed12a88eafd18194}{\+\_\+\+\_\+ne\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_aa43665da30f0da5e64586cad142162e7}{\+\_\+\+\_\+hash\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a268f1bf51db4445eb7821d8ce259bc4b}{\+\_\+\+\_\+req\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a5d076104f4ede59b1f6d6d56c568612b}{\+\_\+\+\_\+rne\+\_\+\+\_\+} (self, other)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a74c460f23d82ac8aff6b6afb6003bf3e}{matches} (self, test\+String, parse\+All=True)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_ac0985c9cc1956ae149461e308f69afa4}{run\+Tests} (self, tests, parse\+All=True, comment=\textquotesingle{}\#\textquotesingle{}, full\+Dump=True, print\+Results=True, failure\+Tests=False, \hyperlink{classpyparsing_1_1ParserElement_a3b6548ce7bb9df91108b4f923c25137c}{post\+Parse}=None, file=None)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a638b41abeb01b5133d30c1ba1fc075d8}{set\+Default\+Whitespace\+Chars} (chars)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a353358c20d9ddcb673365ce17a79bc8c}{inline\+Literals\+Using} (cls)
\item 
def \hyperlink{classpyparsing_1_1ParserElement_aa617897bf2e4c86925ef07ef57cd8665}{reset\+Cache} ()
\item 
def \hyperlink{classpyparsing_1_1ParserElement_a86772c01db5d9a951c955c9028946d46}{enable\+Packrat} (cache\+\_\+size\+\_\+limit=128)
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a479b30648437c4b8da8535395a23f985}{parse\+Action}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a9eb5996aa57caa6b30b94a059bdf2a04}{fail\+Action}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a7b203d949c094ad26eac08eeb0610129}{str\+Repr}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a1708e3e715715c9f3a5112dceca431b3}{results\+Name}
\item 
\hyperlink{classpyparsing_1_1ParserElement_ac01772081d605dac64e692755a97c45e}{save\+As\+List}
\item 
\hyperlink{classpyparsing_1_1ParserElement_add26625bd703452a7f6b72d22a855398}{skip\+Whitespace}
\item 
\hyperlink{classpyparsing_1_1ParserElement_ad9fc7af4f67091521c56a11fd2f97598}{white\+Chars}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a18b1fd95ba32ca70311f70ee89eb01ec}{copy\+Default\+White\+Chars}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a0e47f9cef4b90ed7ffed972f2709f065}{may\+Return\+Empty}
\item 
\hyperlink{classpyparsing_1_1ParserElement_ad89de4310464b6cb9a09fda4617e4458}{keep\+Tabs}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a35ca4a775c96907d923e4f1a14dd164a}{ignore\+Exprs}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a527aba73da50c8212981c57bf9d6926e}{debug}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a458b59687bb6fbd2e62bcd35a0070156}{streamlined}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a50803f6eed71e23f3c5d74719af23f61}{may\+Index\+Error}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a9942086111d72da5c13213b6f4d9a795}{errmsg}
\item 
\hyperlink{classpyparsing_1_1ParserElement_aed3e929a9e503667acde563c1effbd0e}{modal\+Results}
\item 
\hyperlink{classpyparsing_1_1ParserElement_ab5f944fef94392731c6c3b824323cec6}{debug\+Actions}
\item 
\hyperlink{classpyparsing_1_1ParserElement_abefb6a1af708572c3e1df5829f936029}{re}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a9fa130e61f31c9db3cee5aa4eb501c51}{call\+Preparse}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a2737fc1b8ea4435013df5bf4debb9fd9}{call\+During\+Try}
\item 
\hyperlink{classpyparsing_1_1ParserElement_ab51381d24c5bc721b4a4764af8d9b470}{name}
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a36e953eaa7d08c4cb112672fe9c05f2e}{D\+E\+F\+A\+U\+L\+T\+\_\+\+W\+H\+I\+T\+E\+\_\+\+C\+H\+A\+RS}
\item 
\hyperlink{classpyparsing_1_1ParserElement_a12cce1673b4720da6ca42e8acf5395da}{verbose\+\_\+stacktrace}
\item 
\hyperlink{classpyparsing_1_1ParserElement_ab2c6a1d4deffe155001c06cbffb98a31}{packrat\+\_\+cache}
\item 
\hyperlink{classpyparsing_1_1ParserElement_aa36b8eb00b36fd0cb08ad1d7dc19a1eb}{packrat\+\_\+cache\+\_\+lock}
\item 
\hyperlink{classpyparsing_1_1ParserElement_ab5ee6a77bdb23146b3100257eaffcb8a}{packrat\+\_\+cache\+\_\+stats}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Abstract base level parser element class.\end{DoxyVerb}
 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classpyparsing_1_1ParserElement_af2b1ea2e6dddf5043eb401bfaf114463}\label{classpyparsing_1_1ParserElement_af2b1ea2e6dddf5043eb401bfaf114463}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+init\+\_\+\+\_\+()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{savelist = {\ttfamily False} }\end{DoxyParamCaption})}



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a21a06c8513b9a6be62c04b3f9589b985}\label{classpyparsing_1_1ParserElement_a21a06c8513b9a6be62c04b3f9589b985}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+add\+\_\+\+\_\+@{\+\_\+\+\_\+add\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+add\+\_\+\+\_\+@{\+\_\+\+\_\+add\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+add\+\_\+\+\_\+()}{\_\_add\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+add\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of + operator - returns :class:`And`. Adding strings to a ParserElement
converts them to :class:`Literal`s by default.

Example::

    greet = Word(alphas) + "," + Word(alphas) + "!"
    hello = "Hello, World!"
    print (hello, "->", greet.parseString(hello))

prints::

    Hello, World! -> ['Hello', ',', 'World', '!']

``...`` may be used as a parse expression as a short form of :class:`SkipTo`.

    Literal('start') + ... + Literal('end')

is equivalent to:

    Literal('start') + SkipTo('end')("_skipped*") + Literal('end')

Note that the skipped text is returned with '_skipped' as a results name,
and to support having multiple skips in the same parser, the value returned is
a list of all skipped text.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a243eaac2e462c82b0cb8fde4108afbf7}\label{classpyparsing_1_1ParserElement_a243eaac2e462c82b0cb8fde4108afbf7}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+and\+\_\+\+\_\+@{\+\_\+\+\_\+and\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+and\+\_\+\+\_\+@{\+\_\+\+\_\+and\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+and\+\_\+\+\_\+()}{\_\_and\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+and\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of & operator - returns :class:`Each`
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a46450a967b8cf18e76e893532de0ecd7}\label{classpyparsing_1_1ParserElement_a46450a967b8cf18e76e893532de0ecd7}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+call\+\_\+\+\_\+@{\+\_\+\+\_\+call\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+call\+\_\+\+\_\+@{\+\_\+\+\_\+call\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+call\+\_\+\+\_\+()}{\_\_call\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+call\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{name = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Shortcut for :class:`setResultsName`, with ``listAllMatches=False``.

If ``name`` is given with a trailing ``'*'`` character, then ``listAllMatches`` will be
passed as ``True``.

If ``name` is omitted, same as calling :class:`copy`.

Example::

    # these are equivalent
    userdata = Word(alphas).setResultsName("name") + Word(nums + "-").setResultsName("socsecno")
    userdata = Word(alphas)("name") + Word(nums + "-")("socsecno")
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_adff8e67070c5b194296539a11fa5c322}\label{classpyparsing_1_1ParserElement_adff8e67070c5b194296539a11fa5c322}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+eq\+\_\+\+\_\+@{\+\_\+\+\_\+eq\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+eq\+\_\+\+\_\+@{\+\_\+\+\_\+eq\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+eq\+\_\+\+\_\+()}{\_\_eq\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+eq\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a5ec18bd599ba5e749056ebe43e3d7bf3}\label{classpyparsing_1_1ParserElement_a5ec18bd599ba5e749056ebe43e3d7bf3}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+getitem\+\_\+\+\_\+@{\+\_\+\+\_\+getitem\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+getitem\+\_\+\+\_\+@{\+\_\+\+\_\+getitem\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+getitem\+\_\+\+\_\+()}{\_\_getitem\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+getitem\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{key }\end{DoxyParamCaption})}

\begin{DoxyVerb}use ``[]`` indexing notation as a short form for expression repetition:
 - ``expr[n]`` is equivalent to ``expr*n``
 - ``expr[m, n]`` is equivalent to ``expr*(m, n)``
 - ``expr[n, ...]`` or ``expr[n,]`` is equivalent
      to ``expr*n + ZeroOrMore(expr)``
      (read as "at least n instances of ``expr``")
 - ``expr[..., n]`` is equivalent to ``expr*(0, n)``
      (read as "0 to n instances of ``expr``")
 - ``expr[...]`` and ``expr[0, ...]`` are equivalent to ``ZeroOrMore(expr)``
 - ``expr[1, ...]`` is equivalent to ``OneOrMore(expr)``
 ``None`` may be used in place of ``...``.

Note that ``expr[..., n]`` and ``expr[m, n]``do not raise an exception
if more than ``n`` ``expr``s exist in the input stream.  If this behavior is
desired, then write ``expr[..., n] + ~expr``.\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_aa43665da30f0da5e64586cad142162e7}\label{classpyparsing_1_1ParserElement_aa43665da30f0da5e64586cad142162e7}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+hash\+\_\+\+\_\+@{\+\_\+\+\_\+hash\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+hash\+\_\+\+\_\+@{\+\_\+\+\_\+hash\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+hash\+\_\+\+\_\+()}{\_\_hash\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+hash\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_aecad4d0c5430e41858a02de5ed5611e0}\label{classpyparsing_1_1ParserElement_aecad4d0c5430e41858a02de5ed5611e0}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+invert\+\_\+\+\_\+@{\+\_\+\+\_\+invert\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+invert\+\_\+\+\_\+@{\+\_\+\+\_\+invert\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+invert\+\_\+\+\_\+()}{\_\_invert\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+invert\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of ~ operator - returns :class:`NotAny`
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a8c8264e791744827f5d9857c85fe33cf}\label{classpyparsing_1_1ParserElement_a8c8264e791744827f5d9857c85fe33cf}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+iter\+\_\+\+\_\+@{\+\_\+\+\_\+iter\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+iter\+\_\+\+\_\+@{\+\_\+\+\_\+iter\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+iter\+\_\+\+\_\+()}{\_\_iter\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+iter\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ada800b289dc07ee269e242ae6f877a4b}\label{classpyparsing_1_1ParserElement_ada800b289dc07ee269e242ae6f877a4b}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+mul\+\_\+\+\_\+@{\+\_\+\+\_\+mul\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+mul\+\_\+\+\_\+@{\+\_\+\+\_\+mul\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+mul\+\_\+\+\_\+()}{\_\_mul\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+mul\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of * operator, allows use of ``expr * 3`` in place of
``expr + expr + expr``.  Expressions may also me multiplied by a 2-integer
tuple, similar to ``{min, max}`` multipliers in regular expressions.  Tuples
may also include ``None`` as in:
 - ``expr*(n, None)`` or ``expr*(n, )`` is equivalent
      to ``expr*n + ZeroOrMore(expr)``
      (read as "at least n instances of ``expr``")
 - ``expr*(None, n)`` is equivalent to ``expr*(0, n)``
      (read as "0 to n instances of ``expr``")
 - ``expr*(None, None)`` is equivalent to ``ZeroOrMore(expr)``
 - ``expr*(1, None)`` is equivalent to ``OneOrMore(expr)``

Note that ``expr*(None, n)`` does not raise an exception if
more than n exprs exist in the input stream; that is,
``expr*(None, n)`` does not enforce a maximum number of expr
occurrences.  If this behavior is desired, then write
``expr*(None, n) + ~expr``
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a3ac9c1ebf1401b4aed12a88eafd18194}\label{classpyparsing_1_1ParserElement_a3ac9c1ebf1401b4aed12a88eafd18194}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+ne\+\_\+\+\_\+@{\+\_\+\+\_\+ne\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+ne\+\_\+\+\_\+@{\+\_\+\+\_\+ne\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+ne\+\_\+\+\_\+()}{\_\_ne\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+ne\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a1c5f1f8d8ba28723519c37d3416cf6c0}\label{classpyparsing_1_1ParserElement_a1c5f1f8d8ba28723519c37d3416cf6c0}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+or\+\_\+\+\_\+@{\+\_\+\+\_\+or\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+or\+\_\+\+\_\+@{\+\_\+\+\_\+or\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+or\+\_\+\+\_\+()}{\_\_or\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+or\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of | operator - returns :class:`MatchFirst`
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a34941605b7030012a62dca995bda150c}\label{classpyparsing_1_1ParserElement_a34941605b7030012a62dca995bda150c}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+radd\+\_\+\+\_\+@{\+\_\+\+\_\+radd\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+radd\+\_\+\+\_\+@{\+\_\+\+\_\+radd\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+radd\+\_\+\+\_\+()}{\_\_radd\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+radd\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of + operator when left operand is not a :class:`ParserElement`
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_aeee7cc2cc9529f45892705c80a41aced}\label{classpyparsing_1_1ParserElement_aeee7cc2cc9529f45892705c80a41aced}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+rand\+\_\+\+\_\+@{\+\_\+\+\_\+rand\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+rand\+\_\+\+\_\+@{\+\_\+\+\_\+rand\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+rand\+\_\+\+\_\+()}{\_\_rand\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+rand\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of & operator when left operand is not a :class:`ParserElement`
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a299291d78f90aae57bb292bba93f41cf}\label{classpyparsing_1_1ParserElement_a299291d78f90aae57bb292bba93f41cf}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+repr\+\_\+\+\_\+@{\+\_\+\+\_\+repr\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+repr\+\_\+\+\_\+@{\+\_\+\+\_\+repr\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+repr\+\_\+\+\_\+()}{\_\_repr\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+repr\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a268f1bf51db4445eb7821d8ce259bc4b}\label{classpyparsing_1_1ParserElement_a268f1bf51db4445eb7821d8ce259bc4b}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+req\+\_\+\+\_\+@{\+\_\+\+\_\+req\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+req\+\_\+\+\_\+@{\+\_\+\+\_\+req\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+req\+\_\+\+\_\+()}{\_\_req\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+req\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a2efd1d93a31fbff485aa32b1e9fc2059}\label{classpyparsing_1_1ParserElement_a2efd1d93a31fbff485aa32b1e9fc2059}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+rmul\+\_\+\+\_\+@{\+\_\+\+\_\+rmul\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+rmul\+\_\+\+\_\+@{\+\_\+\+\_\+rmul\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+rmul\+\_\+\+\_\+()}{\_\_rmul\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+rmul\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a5d076104f4ede59b1f6d6d56c568612b}\label{classpyparsing_1_1ParserElement_a5d076104f4ede59b1f6d6d56c568612b}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+rne\+\_\+\+\_\+@{\+\_\+\+\_\+rne\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+rne\+\_\+\+\_\+@{\+\_\+\+\_\+rne\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+rne\+\_\+\+\_\+()}{\_\_rne\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+rne\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ab552d5b159a2e499fd867f183fec259f}\label{classpyparsing_1_1ParserElement_ab552d5b159a2e499fd867f183fec259f}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+ror\+\_\+\+\_\+@{\+\_\+\+\_\+ror\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+ror\+\_\+\+\_\+@{\+\_\+\+\_\+ror\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+ror\+\_\+\+\_\+()}{\_\_ror\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+ror\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of | operator when left operand is not a :class:`ParserElement`
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a1c075a3fb139c15e476cd8c0f0fb143e}\label{classpyparsing_1_1ParserElement_a1c075a3fb139c15e476cd8c0f0fb143e}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+rsub\+\_\+\+\_\+@{\+\_\+\+\_\+rsub\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+rsub\+\_\+\+\_\+@{\+\_\+\+\_\+rsub\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+rsub\+\_\+\+\_\+()}{\_\_rsub\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+rsub\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of - operator when left operand is not a :class:`ParserElement`
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a1192254acf0ffd8b84034e984e271e1b}\label{classpyparsing_1_1ParserElement_a1192254acf0ffd8b84034e984e271e1b}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+rxor\+\_\+\+\_\+@{\+\_\+\+\_\+rxor\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+rxor\+\_\+\+\_\+@{\+\_\+\+\_\+rxor\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+rxor\+\_\+\+\_\+()}{\_\_rxor\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+rxor\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of ^ operator when left operand is not a :class:`ParserElement`
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a72ae436ae72b12a0e03572f62f5a35ae}\label{classpyparsing_1_1ParserElement_a72ae436ae72b12a0e03572f62f5a35ae}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+str\+\_\+\+\_\+@{\+\_\+\+\_\+str\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+str\+\_\+\+\_\+@{\+\_\+\+\_\+str\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+str\+\_\+\+\_\+()}{\_\_str\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+str\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_afd1c67a708145e87a941f1ef32858821}\label{classpyparsing_1_1ParserElement_afd1c67a708145e87a941f1ef32858821}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+sub\+\_\+\+\_\+@{\+\_\+\+\_\+sub\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+sub\+\_\+\+\_\+@{\+\_\+\+\_\+sub\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+sub\+\_\+\+\_\+()}{\_\_sub\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+sub\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of - operator, returns :class:`And` with error stop
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_adc202acd38036ea9b404b20bc9833cbe}\label{classpyparsing_1_1ParserElement_adc202acd38036ea9b404b20bc9833cbe}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!\+\_\+\+\_\+xor\+\_\+\+\_\+@{\+\_\+\+\_\+xor\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+xor\+\_\+\+\_\+@{\+\_\+\+\_\+xor\+\_\+\+\_\+}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+xor\+\_\+\+\_\+()}{\_\_xor\_\_()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+\_\+\+\_\+xor\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Implementation of ^ operator - returns :class:`Or`
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a9fce1e8f3c0c4693eb5cd60223b0a5fc}\label{classpyparsing_1_1ParserElement_a9fce1e8f3c0c4693eb5cd60223b0a5fc}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!add\+Condition@{add\+Condition}}
\index{add\+Condition@{add\+Condition}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{add\+Condition()}{addCondition()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+add\+Condition (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{fns,  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Add a boolean predicate function to expression's list of parse actions. See
:class:`setParseAction` for function call signatures. Unlike ``setParseAction``,
functions passed to ``addCondition`` need to return boolean success/fail of the condition.

Optional keyword arguments:
- message = define a custom message to be used in the raised exception
- fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException

Example::

    integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
    year_int = integer.copy()
    year_int.addCondition(lambda toks: toks[0] >= 2000, message="Only support years 2000 and later")
    date_str = year_int + '/' + integer + '/' + integer

    result = date_str.parseString("1999/12/31")  # -> Exception: Only support years 2000 and later (at char 0), (line:1, col:1)
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a21f4bd9d7b1c9e8c18b94e4f8d2b1951}\label{classpyparsing_1_1ParserElement_a21f4bd9d7b1c9e8c18b94e4f8d2b1951}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!add\+Parse\+Action@{add\+Parse\+Action}}
\index{add\+Parse\+Action@{add\+Parse\+Action}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{add\+Parse\+Action()}{addParseAction()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+add\+Parse\+Action (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{fns,  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Add one or more parse actions to expression's list of parse actions. See :class:`setParseAction`.

See examples in :class:`copy`.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_aa032e6999773cbb5c0048eb9b2b6bacb}\label{classpyparsing_1_1ParserElement_aa032e6999773cbb5c0048eb9b2b6bacb}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!can\+Parse\+Next@{can\+Parse\+Next}}
\index{can\+Parse\+Next@{can\+Parse\+Next}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{can\+Parse\+Next()}{canParseNext()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+can\+Parse\+Next (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring,  }\item[{}]{loc }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a46cfe4be87dff6cb52586a0b4ead2b79}\label{classpyparsing_1_1ParserElement_a46cfe4be87dff6cb52586a0b4ead2b79}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!check\+Recursion@{check\+Recursion}}
\index{check\+Recursion@{check\+Recursion}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{check\+Recursion()}{checkRecursion()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+check\+Recursion (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{parse\+Element\+List }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a1fc11c0465d31bf37eb92f7a5cd8c6a4}\label{classpyparsing_1_1ParserElement_a1fc11c0465d31bf37eb92f7a5cd8c6a4}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!copy@{copy}}
\index{copy@{copy}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{copy()}{copy()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+copy (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Make a copy of this :class:`ParserElement`.  Useful for defining
different parse actions for the same parsing pattern, using copies of
the original parse element.

Example::

    integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
    integerK = integer.copy().addParseAction(lambda toks: toks[0] * 1024) + Suppress("K")
    integerM = integer.copy().addParseAction(lambda toks: toks[0] * 1024 * 1024) + Suppress("M")

    print(OneOrMore(integerK | integerM | integer).parseString("5K 100 640K 256M"))

prints::

    [5120, 100, 655360, 268435456]

Equivalent form of ``expr.copy()`` is just ``expr()``::

    integerM = integer().addParseAction(lambda toks: toks[0] * 1024 * 1024) + Suppress("M")
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a86772c01db5d9a951c955c9028946d46}\label{classpyparsing_1_1ParserElement_a86772c01db5d9a951c955c9028946d46}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!enable\+Packrat@{enable\+Packrat}}
\index{enable\+Packrat@{enable\+Packrat}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{enable\+Packrat()}{enablePackrat()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+enable\+Packrat (\begin{DoxyParamCaption}\item[{}]{cache\+\_\+size\+\_\+limit = {\ttfamily 128} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}Enables "packrat" parsing, which adds memoizing to the parsing logic.
   Repeated parse attempts at the same string location (which happens
   often in many complex grammars) can immediately return a cached value,
   instead of re-executing parsing/validating code.  Memoizing is done of
   both valid results and parsing exceptions.

   Parameters:

   - cache_size_limit - (default= ``128``) - if an integer value is provided
     will limit the size of the packrat cache; if None is passed, then
     the cache size will be unbounded; if 0 is passed, the cache will
     be effectively disabled.

   This speedup may break existing programs that use parse actions that
   have side-effects.  For this reason, packrat parsing is disabled when
   you first import pyparsing.  To activate the packrat feature, your
   program must call the class method :class:`ParserElement.enablePackrat`.
   For best results, call ``enablePackrat()`` immediately after
   importing pyparsing.

   Example::

       import pyparsing
       pyparsing.ParserElement.enablePackrat()
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_ae091af36b550112da1a00aa314206d2d}\label{classpyparsing_1_1ParserElement_ae091af36b550112da1a00aa314206d2d}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!ignore@{ignore}}
\index{ignore@{ignore}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{ignore()}{ignore()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+ignore (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other }\end{DoxyParamCaption})}

\begin{DoxyVerb}Define expression to be ignored (e.g., comments) while doing pattern
matching; may be called repeatedly, to define multiple comment or other
ignorable patterns.

Example::

    patt = OneOrMore(Word(alphas))
    patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj']

    patt.ignore(cStyleComment)
    patt.parseString('ablaj /* comment */ lskjd') # -> ['ablaj', 'lskjd']
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a353358c20d9ddcb673365ce17a79bc8c}\label{classpyparsing_1_1ParserElement_a353358c20d9ddcb673365ce17a79bc8c}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!inline\+Literals\+Using@{inline\+Literals\+Using}}
\index{inline\+Literals\+Using@{inline\+Literals\+Using}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{inline\+Literals\+Using()}{inlineLiteralsUsing()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+inline\+Literals\+Using (\begin{DoxyParamCaption}\item[{}]{cls }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}Set class to be used for inclusion of string literals into a parser.

Example::

    # default literal class used is Literal
    integer = Word(nums)
    date_str = integer("year") + '/' + integer("month") + '/' + integer("day")

    date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']


    # change to Suppress
    ParserElement.inlineLiteralsUsing(Suppress)
    date_str = integer("year") + '/' + integer("month") + '/' + integer("day")

    date_str.parseString("1999/12/31")  # -> ['1999', '12', '31']
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_ac3de85a4c5fed7bc8d10967c7c985f8a}\label{classpyparsing_1_1ParserElement_ac3de85a4c5fed7bc8d10967c7c985f8a}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!leave\+Whitespace@{leave\+Whitespace}}
\index{leave\+Whitespace@{leave\+Whitespace}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{leave\+Whitespace()}{leaveWhitespace()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+leave\+Whitespace (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Disables the skipping of whitespace before matching the characters in the
:class:`ParserElement`'s defined pattern.  This is normally only used internally by
the pyparsing module, but may be needed in some whitespace-sensitive grammars.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a74c460f23d82ac8aff6b6afb6003bf3e}\label{classpyparsing_1_1ParserElement_a74c460f23d82ac8aff6b6afb6003bf3e}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!matches@{matches}}
\index{matches@{matches}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{matches()}{matches()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+matches (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{test\+String,  }\item[{}]{parse\+All = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Method for quick testing of a parser against a test string. Good for simple
inline microtests of sub expressions while building up larger parser.

Parameters:
 - testString - to test against this expression for a match
 - parseAll - (default= ``True``) - flag to pass to :class:`parseString` when running tests

Example::

    expr = Word(nums)
    assert expr.matches("100")
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a5076b859e68470bd5fbe3f993be3e187}\label{classpyparsing_1_1ParserElement_a5076b859e68470bd5fbe3f993be3e187}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!parse\+File@{parse\+File}}
\index{parse\+File@{parse\+File}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{parse\+File()}{parseFile()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+parse\+File (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{file\+\_\+or\+\_\+filename,  }\item[{}]{parse\+All = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Execute the parse expression on the given file or filename.
If a filename is specified (instead of a file object),
the entire file is opened, read, and closed before parsing.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a329bcec7d8f7ef6875b9390787536e5b}\label{classpyparsing_1_1ParserElement_a329bcec7d8f7ef6875b9390787536e5b}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!parse\+Impl@{parse\+Impl}}
\index{parse\+Impl@{parse\+Impl}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{parse\+Impl()}{parseImpl()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+parse\+Impl (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring,  }\item[{}]{loc,  }\item[{}]{do\+Actions = {\ttfamily True} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a0026d86408e4fb2faa89c985dcb89738}\label{classpyparsing_1_1ParserElement_a0026d86408e4fb2faa89c985dcb89738}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!parse\+String@{parse\+String}}
\index{parse\+String@{parse\+String}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{parse\+String()}{parseString()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+parse\+String (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring,  }\item[{}]{parse\+All = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Execute the parse expression with the given string.
This is the main interface to the client code, once the complete
expression has been built.

Returns the parsed data as a :class:`ParseResults` object, which may be
accessed as a list, or as a dict or object with attributes if the given parser
includes results names.

If you want the grammar to require that the entire input string be
successfully parsed, then set ``parseAll`` to True (equivalent to ending
the grammar with ``StringEnd()``).

Note: ``parseString`` implicitly calls ``expandtabs()`` on the input string,
in order to report proper column numbers in parse actions.
If the input string contains tabs and
the grammar uses parse actions that use the ``loc`` argument to index into the
string being parsed, you can ensure you have a consistent view of the input
string by:

- calling ``parseWithTabs`` on your grammar before calling ``parseString``
  (see :class:`parseWithTabs`)
- define your parse action using the full ``(s, loc, toks)`` signature, and
  reference the input string using the parse action's ``s`` argument
- explictly expand the tabs in your input string before calling
  ``parseString``

Example::

    Word('a').parseString('aaaaabaaa')  # -> ['aaaaa']
    Word('a').parseString('aaaaabaaa', parseAll=True)  # -> Exception: Expected end of text
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_af81ca1164a8903a8595c1bfec35316cd}\label{classpyparsing_1_1ParserElement_af81ca1164a8903a8595c1bfec35316cd}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!parse\+With\+Tabs@{parse\+With\+Tabs}}
\index{parse\+With\+Tabs@{parse\+With\+Tabs}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{parse\+With\+Tabs()}{parseWithTabs()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+parse\+With\+Tabs (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Overrides default behavior to expand ``<TAB>``s to spaces before parsing the input string.
Must be called before ``parseString`` when the input grammar contains elements that
match ``<TAB>`` characters.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a3b6548ce7bb9df91108b4f923c25137c}\label{classpyparsing_1_1ParserElement_a3b6548ce7bb9df91108b4f923c25137c}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!post\+Parse@{post\+Parse}}
\index{post\+Parse@{post\+Parse}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{post\+Parse()}{postParse()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+post\+Parse (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring,  }\item[{}]{loc,  }\item[{}]{tokenlist }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ac97092fcb02cd6696f51185cfceeac59}\label{classpyparsing_1_1ParserElement_ac97092fcb02cd6696f51185cfceeac59}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!pre\+Parse@{pre\+Parse}}
\index{pre\+Parse@{pre\+Parse}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{pre\+Parse()}{preParse()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+pre\+Parse (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring,  }\item[{}]{loc }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_aa617897bf2e4c86925ef07ef57cd8665}\label{classpyparsing_1_1ParserElement_aa617897bf2e4c86925ef07ef57cd8665}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!reset\+Cache@{reset\+Cache}}
\index{reset\+Cache@{reset\+Cache}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{reset\+Cache()}{resetCache()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+reset\+Cache (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ac0985c9cc1956ae149461e308f69afa4}\label{classpyparsing_1_1ParserElement_ac0985c9cc1956ae149461e308f69afa4}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!run\+Tests@{run\+Tests}}
\index{run\+Tests@{run\+Tests}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{run\+Tests()}{runTests()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+run\+Tests (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{tests,  }\item[{}]{parse\+All = {\ttfamily True},  }\item[{}]{comment = {\ttfamily \textquotesingle{}\#\textquotesingle{}},  }\item[{}]{full\+Dump = {\ttfamily True},  }\item[{}]{print\+Results = {\ttfamily True},  }\item[{}]{failure\+Tests = {\ttfamily False},  }\item[{}]{post\+Parse = {\ttfamily None},  }\item[{}]{file = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Execute the parse expression on a series of test strings, showing each
test, the parsed results or where the parse failed. Quick and easy way to
run a parse expression against a list of sample strings.

Parameters:
 - tests - a list of separate test strings, or a multiline string of test strings
 - parseAll - (default= ``True``) - flag to pass to :class:`parseString` when running tests
 - comment - (default= ``'#'``) - expression for indicating embedded comments in the test
      string; pass None to disable comment filtering
 - fullDump - (default= ``True``) - dump results as list followed by results names in nested outline;
      if False, only dump nested list
 - printResults - (default= ``True``) prints test output to stdout
 - failureTests - (default= ``False``) indicates if these tests are expected to fail parsing
 - postParse - (default= ``None``) optional callback for successful parse results; called as
      `fn(test_string, parse_results)` and returns a string to be added to the test output
 - file - (default=``None``) optional file-like object to which test output will be written;
      if None, will default to ``sys.stdout``

Returns: a (success, results) tuple, where success indicates that all tests succeeded
(or failed if ``failureTests`` is True), and the results contain a list of lines of each
test's output

Example::

    number_expr = pyparsing_common.number.copy()

    result = number_expr.runTests('''
# unsigned integer
100
# negative integer
-100
# float with scientific notation
6.02e23
# integer with scientific notation
1e-12
''')
    print("Success" if result[0] else "Failed!")

    result = number_expr.runTests('''
# stray character
100Z
# missing leading digit before '.'
-.100
# too many '.'
3.14.159
''', failureTests=True)
    print("Success" if result[0] else "Failed!")

prints::

    # unsigned integer
    100
    [100]

    # negative integer
    -100
    [-100]

    # float with scientific notation
    6.02e23
    [6.02e+23]

    # integer with scientific notation
    1e-12
    [1e-12]

    Success

    # stray character
    100Z
       ^
    FAIL: Expected end of text (at char 3), (line:1, col:4)

    # missing leading digit before '.'
    -.100
    ^
    FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)

    # too many '.'
    3.14.159
^
    FAIL: Expected end of text (at char 4), (line:1, col:5)

    Success

Each test string must be on a single line. If you want to test a string that spans multiple
lines, create a test like this::

    expr.runTest(r"this is a test\\n of strings that spans \\n 3 lines")

(Note that this is a raw string literal, you must include the leading 'r'.)
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_ae2359510cb75269e8f67637112ca4783}\label{classpyparsing_1_1ParserElement_ae2359510cb75269e8f67637112ca4783}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!scan\+String@{scan\+String}}
\index{scan\+String@{scan\+String}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{scan\+String()}{scanString()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+scan\+String (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring,  }\item[{}]{max\+Matches = {\ttfamily \+\_\+MAX\+\_\+INT},  }\item[{}]{overlap = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Scan the input string for expression matches.  Each match will return the
matching tokens, start location, and end location.  May be called with optional
``maxMatches`` argument, to clip scanning after 'n' matches are found.  If
``overlap`` is specified, then overlapping matches will be reported.

Note that the start and end locations are reported relative to the string
being parsed.  See :class:`parseString` for more information on parsing
strings with embedded tabs.

Example::

    source = "sldjf123lsdjjkf345sldkjf879lkjsfd987"
    print(source)
    for tokens, start, end in Word(alphas).scanString(source):
print(' '*start + '^'*(end-start))
print(' '*start + tokens[0])

prints::

    sldjf123lsdjjkf345sldkjf879lkjsfd987
    ^^^^^
    sldjf
    ^^^^^^^
    lsdjjkf
              ^^^^^^
              sldkjf
                       ^^^^^^
                       lkjsfd
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_abd33d51600731c951b6bc96452fa6bdd}\label{classpyparsing_1_1ParserElement_abd33d51600731c951b6bc96452fa6bdd}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!search\+String@{search\+String}}
\index{search\+String@{search\+String}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{search\+String()}{searchString()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+search\+String (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring,  }\item[{}]{max\+Matches = {\ttfamily \+\_\+MAX\+\_\+INT} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Another extension to :class:`scanString`, simplifying the access to the tokens found
to match the given parse expression.  May be called with optional
``maxMatches`` argument, to clip searching after 'n' matches are found.

Example::

    # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters
    cap_word = Word(alphas.upper(), alphas.lower())

    print(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity"))

    # the sum() builtin can be used to merge results into a single ParseResults object
    print(sum(cap_word.searchString("More than Iron, more than Lead, more than Gold I need Electricity")))

prints::

    [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]
    ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a078b62d7a0d94fdb5755c196347022ab}\label{classpyparsing_1_1ParserElement_a078b62d7a0d94fdb5755c196347022ab}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!set\+Break@{set\+Break}}
\index{set\+Break@{set\+Break}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{set\+Break()}{setBreak()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+set\+Break (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{break\+Flag = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Method to invoke the Python pdb debugger when this element is
   about to be parsed. Set ``breakFlag`` to True to enable, False to
   disable.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_ac5d0f98e4a43fd89567d218b36229eae}\label{classpyparsing_1_1ParserElement_ac5d0f98e4a43fd89567d218b36229eae}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!set\+Debug@{set\+Debug}}
\index{set\+Debug@{set\+Debug}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{set\+Debug()}{setDebug()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+set\+Debug (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{flag = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Enable display of debugging messages while doing pattern matching.
Set ``flag`` to True to enable, False to disable.

Example::

    wd = Word(alphas).setName("alphaword")
    integer = Word(nums).setName("numword")
    term = wd | integer

    # turn on debugging for wd
    wd.setDebug()

    OneOrMore(term).parseString("abc 123 xyz 890")

prints::

    Match alphaword at loc 0(1,1)
    Matched alphaword -> ['abc']
    Match alphaword at loc 3(1,4)
    Exception raised:Expected alphaword (at char 4), (line:1, col:5)
    Match alphaword at loc 7(1,8)
    Matched alphaword -> ['xyz']
    Match alphaword at loc 11(1,12)
    Exception raised:Expected alphaword (at char 12), (line:1, col:13)
    Match alphaword at loc 15(1,16)
    Exception raised:Expected alphaword (at char 15), (line:1, col:16)

The output shown is that produced by the default debug actions - custom debug actions can be
specified using :class:`setDebugActions`. Prior to attempting
to match the ``wd`` expression, the debugging message ``"Match <exprname> at loc <n>(<line>,<col>)"``
is shown. Then if the parse succeeds, a ``"Matched"`` message is shown, or an ``"Exception raised"``
message is shown. Also note the use of :class:`setName` to assign a human-readable name to the expression,
which makes debugging and exception messages easier to understand - for instance, the default
name created for the :class:`Word` expression without calling ``setName`` is ``"W:(ABCD...)"``.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a75debf95f36a4f456b6760a315587c50}\label{classpyparsing_1_1ParserElement_a75debf95f36a4f456b6760a315587c50}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!set\+Debug\+Actions@{set\+Debug\+Actions}}
\index{set\+Debug\+Actions@{set\+Debug\+Actions}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{set\+Debug\+Actions()}{setDebugActions()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+set\+Debug\+Actions (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{start\+Action,  }\item[{}]{success\+Action,  }\item[{}]{exception\+Action }\end{DoxyParamCaption})}

\begin{DoxyVerb}Enable display of debugging messages while doing pattern matching.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a638b41abeb01b5133d30c1ba1fc075d8}\label{classpyparsing_1_1ParserElement_a638b41abeb01b5133d30c1ba1fc075d8}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!set\+Default\+Whitespace\+Chars@{set\+Default\+Whitespace\+Chars}}
\index{set\+Default\+Whitespace\+Chars@{set\+Default\+Whitespace\+Chars}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{set\+Default\+Whitespace\+Chars()}{setDefaultWhitespaceChars()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+set\+Default\+Whitespace\+Chars (\begin{DoxyParamCaption}\item[{}]{chars }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}Overrides the default whitespace chars

Example::

    # default whitespace chars are space, <TAB> and newline
    OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def', 'ghi', 'jkl']

    # change to just treat newline as significant
    ParserElement.setDefaultWhitespaceChars(" \t")
    OneOrMore(Word(alphas)).parseString("abc def\nghi jkl")  # -> ['abc', 'def']
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a38989383d034cbd8b3723141d1c43ffd}\label{classpyparsing_1_1ParserElement_a38989383d034cbd8b3723141d1c43ffd}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!set\+Fail\+Action@{set\+Fail\+Action}}
\index{set\+Fail\+Action@{set\+Fail\+Action}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{set\+Fail\+Action()}{setFailAction()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+set\+Fail\+Action (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{fn }\end{DoxyParamCaption})}

\begin{DoxyVerb}Define action to perform if parsing fails at this expression.
   Fail acton fn is a callable function that takes the arguments
   ``fn(s, loc, expr, err)`` where:
   - s = string being parsed
   - loc = location where expression match was attempted and failed
   - expr = the parse expression that failed
   - err = the exception thrown
   The function returns no value.  It may throw :class:`ParseFatalException`
   if it is desired to stop parsing immediately.\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a8197a4fff4f269747bb21028452a3755}\label{classpyparsing_1_1ParserElement_a8197a4fff4f269747bb21028452a3755}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!set\+Name@{set\+Name}}
\index{set\+Name@{set\+Name}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{set\+Name()}{setName()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+set\+Name (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{name }\end{DoxyParamCaption})}

\begin{DoxyVerb}Define name for this expression, makes debugging and exception messages clearer.

Example::

    Word(nums).parseString("ABC")  # -> Exception: Expected W:(0123...) (at char 0), (line:1, col:1)
    Word(nums).setName("integer").parseString("ABC")  # -> Exception: Expected integer (at char 0), (line:1, col:1)
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_ad19e8d671046a66846d01f0604618f97}\label{classpyparsing_1_1ParserElement_ad19e8d671046a66846d01f0604618f97}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!set\+Parse\+Action@{set\+Parse\+Action}}
\index{set\+Parse\+Action@{set\+Parse\+Action}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{set\+Parse\+Action()}{setParseAction()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+set\+Parse\+Action (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{fns,  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Define one or more actions to perform when successfully matching parse element definition.
Parse action fn is a callable method with 0-3 arguments, called as ``fn(s, loc, toks)`` ,
``fn(loc, toks)`` , ``fn(toks)`` , or just ``fn()`` , where:

- s   = the original string being parsed (see note below)
- loc = the location of the matching substring
- toks = a list of the matched tokens, packaged as a :class:`ParseResults` object

If the functions in fns modify the tokens, they can return them as the return
value from fn, and the modified list of tokens will replace the original.
Otherwise, fn does not need to return any value.

If None is passed as the parse action, all previously added parse actions for this
expression are cleared.

Optional keyword arguments:
- callDuringTry = (default= ``False``) indicate if parse action should be run during lookaheads and alternate testing

Note: the default parsing behavior is to expand tabs in the input string
before starting the parsing process.  See :class:`parseString for more
information on parsing strings containing ``<TAB>`` s, and suggested
methods to maintain a consistent view of the parsed string, the parse
location, and line and column positions within the parsed string.

Example::

    integer = Word(nums)
    date_str = integer + '/' + integer + '/' + integer

    date_str.parseString("1999/12/31")  # -> ['1999', '/', '12', '/', '31']

    # use parse action to convert to ints at parse time
    integer = Word(nums).setParseAction(lambda toks: int(toks[0]))
    date_str = integer + '/' + integer + '/' + integer

    # note that integer fields are now ints, not strings
    date_str.parseString("1999/12/31")  # -> [1999, '/', 12, '/', 31]
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a4996c883b285fef6c89b2b5caf675fd0}\label{classpyparsing_1_1ParserElement_a4996c883b285fef6c89b2b5caf675fd0}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!set\+Results\+Name@{set\+Results\+Name}}
\index{set\+Results\+Name@{set\+Results\+Name}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{set\+Results\+Name()}{setResultsName()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+set\+Results\+Name (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{name,  }\item[{}]{list\+All\+Matches = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Define name for referencing matching tokens as a nested attribute
of the returned parse results.
NOTE: this returns a *copy* of the original :class:`ParserElement` object;
this is so that the client can define a basic element, such as an
integer, and reference it in multiple places with different names.

You can also set results names using the abbreviated syntax,
``expr("name")`` in place of ``expr.setResultsName("name")``
- see :class:`__call__`.

Example::

    date_str = (integer.setResultsName("year") + '/'
        + integer.setResultsName("month") + '/'
        + integer.setResultsName("day"))

    # equivalent form:
    date_str = integer("year") + '/' + integer("month") + '/' + integer("day")
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a02335ae8eec55cf3944fd79769a4104e}\label{classpyparsing_1_1ParserElement_a02335ae8eec55cf3944fd79769a4104e}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!set\+Whitespace\+Chars@{set\+Whitespace\+Chars}}
\index{set\+Whitespace\+Chars@{set\+Whitespace\+Chars}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{set\+Whitespace\+Chars()}{setWhitespaceChars()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+set\+Whitespace\+Chars (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{chars }\end{DoxyParamCaption})}

\begin{DoxyVerb}Overrides the default whitespace chars
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a8db51e82054675b073d5d03b58da4091}\label{classpyparsing_1_1ParserElement_a8db51e82054675b073d5d03b58da4091}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!split@{split}}
\index{split@{split}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{split()}{split()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+split (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring,  }\item[{}]{maxsplit = {\ttfamily \+\_\+MAX\+\_\+INT},  }\item[{}]{include\+Separators = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Generator method to split a string using the given expression as a separator.
May be called with optional ``maxsplit`` argument, to limit the number of splits;
and the optional ``includeSeparators`` argument (default= ``False``), if the separating
matching text should be included in the split results.

Example::

    punc = oneOf(list(".,;:/-!?"))
    print(list(punc.split("This, this?, this sentence, is badly punctuated!")))

prints::

    ['This', ' this', '', ' this sentence', ' is badly punctuated', '']
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a09856e9ee0198b9e5da936e4f401f2f2}\label{classpyparsing_1_1ParserElement_a09856e9ee0198b9e5da936e4f401f2f2}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!streamline@{streamline}}
\index{streamline@{streamline}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{streamline()}{streamline()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+streamline (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_aa59fe575380165c82b618b55e91ef0a5}\label{classpyparsing_1_1ParserElement_aa59fe575380165c82b618b55e91ef0a5}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!suppress@{suppress}}
\index{suppress@{suppress}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{suppress()}{suppress()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+suppress (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Suppresses the output of this :class:`ParserElement`; useful to keep punctuation from
cluttering up returned output.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_aafab376b2c6bc61873e532f2042d5425}\label{classpyparsing_1_1ParserElement_aafab376b2c6bc61873e532f2042d5425}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!transform\+String@{transform\+String}}
\index{transform\+String@{transform\+String}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{transform\+String()}{transformString()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+transform\+String (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring }\end{DoxyParamCaption})}

\begin{DoxyVerb}Extension to :class:`scanString`, to modify matching text with modified tokens that may
be returned from a parse action.  To use ``transformString``, define a grammar and
attach a parse action to it that modifies the returned token list.
Invoking ``transformString()`` on a target string will then scan for matches,
and replace the matched text patterns according to the logic in the parse
action.  ``transformString()`` returns the resulting transformed string.

Example::

    wd = Word(alphas)
    wd.setParseAction(lambda toks: toks[0].title())

    print(wd.transformString("now is the winter of our discontent made glorious summer by this sun of york."))

prints::

    Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.
\end{DoxyVerb}
 \mbox{\Hypertarget{classpyparsing_1_1ParserElement_a0f4f5dac320faf316bd8a54022f4345e}\label{classpyparsing_1_1ParserElement_a0f4f5dac320faf316bd8a54022f4345e}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!try\+Parse@{try\+Parse}}
\index{try\+Parse@{try\+Parse}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{try\+Parse()}{tryParse()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+try\+Parse (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{instring,  }\item[{}]{loc }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ab3aa74c2cd7880b45b594e8cfea22a07}\label{classpyparsing_1_1ParserElement_ab3aa74c2cd7880b45b594e8cfea22a07}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!validate@{validate}}
\index{validate@{validate}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{validate()}{validate()}}
{\footnotesize\ttfamily def pyparsing.\+Parser\+Element.\+validate (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{validate\+Trace = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Check defined expressions for valid structure, check for infinite recursive definitions.
\end{DoxyVerb}
 

\subsection{Member Data Documentation}
\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a2737fc1b8ea4435013df5bf4debb9fd9}\label{classpyparsing_1_1ParserElement_a2737fc1b8ea4435013df5bf4debb9fd9}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!call\+During\+Try@{call\+During\+Try}}
\index{call\+During\+Try@{call\+During\+Try}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{call\+During\+Try}{callDuringTry}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+call\+During\+Try}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a9fa130e61f31c9db3cee5aa4eb501c51}\label{classpyparsing_1_1ParserElement_a9fa130e61f31c9db3cee5aa4eb501c51}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!call\+Preparse@{call\+Preparse}}
\index{call\+Preparse@{call\+Preparse}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{call\+Preparse}{callPreparse}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+call\+Preparse}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a18b1fd95ba32ca70311f70ee89eb01ec}\label{classpyparsing_1_1ParserElement_a18b1fd95ba32ca70311f70ee89eb01ec}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!copy\+Default\+White\+Chars@{copy\+Default\+White\+Chars}}
\index{copy\+Default\+White\+Chars@{copy\+Default\+White\+Chars}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{copy\+Default\+White\+Chars}{copyDefaultWhiteChars}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+copy\+Default\+White\+Chars}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a527aba73da50c8212981c57bf9d6926e}\label{classpyparsing_1_1ParserElement_a527aba73da50c8212981c57bf9d6926e}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!debug@{debug}}
\index{debug@{debug}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{debug}{debug}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+debug}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ab5f944fef94392731c6c3b824323cec6}\label{classpyparsing_1_1ParserElement_ab5f944fef94392731c6c3b824323cec6}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!debug\+Actions@{debug\+Actions}}
\index{debug\+Actions@{debug\+Actions}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{debug\+Actions}{debugActions}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+debug\+Actions}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a36e953eaa7d08c4cb112672fe9c05f2e}\label{classpyparsing_1_1ParserElement_a36e953eaa7d08c4cb112672fe9c05f2e}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!D\+E\+F\+A\+U\+L\+T\+\_\+\+W\+H\+I\+T\+E\+\_\+\+C\+H\+A\+RS@{D\+E\+F\+A\+U\+L\+T\+\_\+\+W\+H\+I\+T\+E\+\_\+\+C\+H\+A\+RS}}
\index{D\+E\+F\+A\+U\+L\+T\+\_\+\+W\+H\+I\+T\+E\+\_\+\+C\+H\+A\+RS@{D\+E\+F\+A\+U\+L\+T\+\_\+\+W\+H\+I\+T\+E\+\_\+\+C\+H\+A\+RS}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{D\+E\+F\+A\+U\+L\+T\+\_\+\+W\+H\+I\+T\+E\+\_\+\+C\+H\+A\+RS}{DEFAULT\_WHITE\_CHARS}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+D\+E\+F\+A\+U\+L\+T\+\_\+\+W\+H\+I\+T\+E\+\_\+\+C\+H\+A\+RS\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a9942086111d72da5c13213b6f4d9a795}\label{classpyparsing_1_1ParserElement_a9942086111d72da5c13213b6f4d9a795}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!errmsg@{errmsg}}
\index{errmsg@{errmsg}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{errmsg}{errmsg}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+errmsg}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a9eb5996aa57caa6b30b94a059bdf2a04}\label{classpyparsing_1_1ParserElement_a9eb5996aa57caa6b30b94a059bdf2a04}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!fail\+Action@{fail\+Action}}
\index{fail\+Action@{fail\+Action}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{fail\+Action}{failAction}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+fail\+Action}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a35ca4a775c96907d923e4f1a14dd164a}\label{classpyparsing_1_1ParserElement_a35ca4a775c96907d923e4f1a14dd164a}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!ignore\+Exprs@{ignore\+Exprs}}
\index{ignore\+Exprs@{ignore\+Exprs}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{ignore\+Exprs}{ignoreExprs}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+ignore\+Exprs}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ad89de4310464b6cb9a09fda4617e4458}\label{classpyparsing_1_1ParserElement_ad89de4310464b6cb9a09fda4617e4458}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!keep\+Tabs@{keep\+Tabs}}
\index{keep\+Tabs@{keep\+Tabs}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{keep\+Tabs}{keepTabs}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+keep\+Tabs}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a50803f6eed71e23f3c5d74719af23f61}\label{classpyparsing_1_1ParserElement_a50803f6eed71e23f3c5d74719af23f61}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!may\+Index\+Error@{may\+Index\+Error}}
\index{may\+Index\+Error@{may\+Index\+Error}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{may\+Index\+Error}{mayIndexError}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+may\+Index\+Error}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a0e47f9cef4b90ed7ffed972f2709f065}\label{classpyparsing_1_1ParserElement_a0e47f9cef4b90ed7ffed972f2709f065}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!may\+Return\+Empty@{may\+Return\+Empty}}
\index{may\+Return\+Empty@{may\+Return\+Empty}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{may\+Return\+Empty}{mayReturnEmpty}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+may\+Return\+Empty}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_aed3e929a9e503667acde563c1effbd0e}\label{classpyparsing_1_1ParserElement_aed3e929a9e503667acde563c1effbd0e}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!modal\+Results@{modal\+Results}}
\index{modal\+Results@{modal\+Results}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{modal\+Results}{modalResults}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+modal\+Results}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ab51381d24c5bc721b4a4764af8d9b470}\label{classpyparsing_1_1ParserElement_ab51381d24c5bc721b4a4764af8d9b470}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!name@{name}}
\index{name@{name}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{name}{name}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+name}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ab2c6a1d4deffe155001c06cbffb98a31}\label{classpyparsing_1_1ParserElement_ab2c6a1d4deffe155001c06cbffb98a31}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!packrat\+\_\+cache@{packrat\+\_\+cache}}
\index{packrat\+\_\+cache@{packrat\+\_\+cache}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{packrat\+\_\+cache}{packrat\_cache}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+packrat\+\_\+cache\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_aa36b8eb00b36fd0cb08ad1d7dc19a1eb}\label{classpyparsing_1_1ParserElement_aa36b8eb00b36fd0cb08ad1d7dc19a1eb}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!packrat\+\_\+cache\+\_\+lock@{packrat\+\_\+cache\+\_\+lock}}
\index{packrat\+\_\+cache\+\_\+lock@{packrat\+\_\+cache\+\_\+lock}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{packrat\+\_\+cache\+\_\+lock}{packrat\_cache\_lock}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+packrat\+\_\+cache\+\_\+lock\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ab5ee6a77bdb23146b3100257eaffcb8a}\label{classpyparsing_1_1ParserElement_ab5ee6a77bdb23146b3100257eaffcb8a}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!packrat\+\_\+cache\+\_\+stats@{packrat\+\_\+cache\+\_\+stats}}
\index{packrat\+\_\+cache\+\_\+stats@{packrat\+\_\+cache\+\_\+stats}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{packrat\+\_\+cache\+\_\+stats}{packrat\_cache\_stats}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+packrat\+\_\+cache\+\_\+stats\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a479b30648437c4b8da8535395a23f985}\label{classpyparsing_1_1ParserElement_a479b30648437c4b8da8535395a23f985}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!parse\+Action@{parse\+Action}}
\index{parse\+Action@{parse\+Action}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{parse\+Action}{parseAction}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+parse\+Action}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_abefb6a1af708572c3e1df5829f936029}\label{classpyparsing_1_1ParserElement_abefb6a1af708572c3e1df5829f936029}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!re@{re}}
\index{re@{re}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{re}{re}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+re}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a1708e3e715715c9f3a5112dceca431b3}\label{classpyparsing_1_1ParserElement_a1708e3e715715c9f3a5112dceca431b3}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!results\+Name@{results\+Name}}
\index{results\+Name@{results\+Name}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{results\+Name}{resultsName}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+results\+Name}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ac01772081d605dac64e692755a97c45e}\label{classpyparsing_1_1ParserElement_ac01772081d605dac64e692755a97c45e}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!save\+As\+List@{save\+As\+List}}
\index{save\+As\+List@{save\+As\+List}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{save\+As\+List}{saveAsList}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+save\+As\+List}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_add26625bd703452a7f6b72d22a855398}\label{classpyparsing_1_1ParserElement_add26625bd703452a7f6b72d22a855398}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!skip\+Whitespace@{skip\+Whitespace}}
\index{skip\+Whitespace@{skip\+Whitespace}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{skip\+Whitespace}{skipWhitespace}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+skip\+Whitespace}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a458b59687bb6fbd2e62bcd35a0070156}\label{classpyparsing_1_1ParserElement_a458b59687bb6fbd2e62bcd35a0070156}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!streamlined@{streamlined}}
\index{streamlined@{streamlined}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{streamlined}{streamlined}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+streamlined}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a7b203d949c094ad26eac08eeb0610129}\label{classpyparsing_1_1ParserElement_a7b203d949c094ad26eac08eeb0610129}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!str\+Repr@{str\+Repr}}
\index{str\+Repr@{str\+Repr}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{str\+Repr}{strRepr}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+str\+Repr}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_a12cce1673b4720da6ca42e8acf5395da}\label{classpyparsing_1_1ParserElement_a12cce1673b4720da6ca42e8acf5395da}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!verbose\+\_\+stacktrace@{verbose\+\_\+stacktrace}}
\index{verbose\+\_\+stacktrace@{verbose\+\_\+stacktrace}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{verbose\+\_\+stacktrace}{verbose\_stacktrace}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+verbose\+\_\+stacktrace\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classpyparsing_1_1ParserElement_ad9fc7af4f67091521c56a11fd2f97598}\label{classpyparsing_1_1ParserElement_ad9fc7af4f67091521c56a11fd2f97598}} 
\index{pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}!white\+Chars@{white\+Chars}}
\index{white\+Chars@{white\+Chars}!pyparsing\+::\+Parser\+Element@{pyparsing\+::\+Parser\+Element}}
\subsubsection{\texorpdfstring{white\+Chars}{whiteChars}}
{\footnotesize\ttfamily pyparsing.\+Parser\+Element.\+white\+Chars}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
venv/lib/python3.\+9/site-\/packages/\hyperlink{pyparsing_8py}{pyparsing.\+py}\end{DoxyCompactItemize}
