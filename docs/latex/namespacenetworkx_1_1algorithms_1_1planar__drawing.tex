\hypertarget{namespacenetworkx_1_1algorithms_1_1planar__drawing}{}\section{networkx.\+algorithms.\+planar\+\_\+drawing Namespace Reference}
\label{namespacenetworkx_1_1algorithms_1_1planar__drawing}\index{networkx.\+algorithms.\+planar\+\_\+drawing@{networkx.\+algorithms.\+planar\+\_\+drawing}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1planar__drawing_ac8d92cba8c047a320c16ffdf2684e58c}{combinatorial\+\_\+embedding\+\_\+to\+\_\+pos} (embedding, fully\+\_\+triangulate=False)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1planar__drawing_a982f71be29109cd0fdaa238cf0551a23}{set\+\_\+position} (parent, tree, remaining\+\_\+nodes, delta\+\_\+x, y\+\_\+coordinate, pos)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1planar__drawing_a5e561926d9c6866e89f8730fa371f029}{get\+\_\+canonical\+\_\+ordering} (embedding, outer\+\_\+face)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1planar__drawing_ade5ec6675aba9215ee603d9eec914f79}{triangulate\+\_\+face} (embedding, v1, v2)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1planar__drawing_a08ac4a90fdc11925daf5b94ed0789ac3}{triangulate\+\_\+embedding} (embedding, fully\+\_\+triangulate=True)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1planar__drawing_a2bf4bd4ab4a56044a6fa886186b84487}{make\+\_\+bi\+\_\+connected} (embedding, starting\+\_\+node, outgoing\+\_\+node, edges\+\_\+counted)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1planar__drawing_ac8d92cba8c047a320c16ffdf2684e58c}\label{namespacenetworkx_1_1algorithms_1_1planar__drawing_ac8d92cba8c047a320c16ffdf2684e58c}} 
\index{networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}!combinatorial\+\_\+embedding\+\_\+to\+\_\+pos@{combinatorial\+\_\+embedding\+\_\+to\+\_\+pos}}
\index{combinatorial\+\_\+embedding\+\_\+to\+\_\+pos@{combinatorial\+\_\+embedding\+\_\+to\+\_\+pos}!networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}}
\subsubsection{\texorpdfstring{combinatorial\+\_\+embedding\+\_\+to\+\_\+pos()}{combinatorial\_embedding\_to\_pos()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+planar\+\_\+drawing.\+combinatorial\+\_\+embedding\+\_\+to\+\_\+pos (\begin{DoxyParamCaption}\item[{}]{embedding,  }\item[{}]{fully\+\_\+triangulate = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Assigns every node a (x, y) position based on the given embedding

The algorithm iteratively inserts nodes of the input graph in a certain
order and rearranges previously inserted nodes so that the planar drawing
stays valid. This is done efficiently by only maintaining relative
positions during the node placements and calculating the absolute positions
at the end. For more information see [1]_.

Parameters
----------
embedding : nx.PlanarEmbedding
    This defines the order of the edges

fully_triangulate : bool
    If set to True the algorithm adds edges to a copy of the input
    embedding and makes it chordal.

Returns
-------
pos : dict
    Maps each node to a tuple that defines the (x, y) position

References
----------
.. [1] M. Chrobak and T.H. Payne:
    A Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989
    http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1planar__drawing_a5e561926d9c6866e89f8730fa371f029}\label{namespacenetworkx_1_1algorithms_1_1planar__drawing_a5e561926d9c6866e89f8730fa371f029}} 
\index{networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}!get\+\_\+canonical\+\_\+ordering@{get\+\_\+canonical\+\_\+ordering}}
\index{get\+\_\+canonical\+\_\+ordering@{get\+\_\+canonical\+\_\+ordering}!networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}}
\subsubsection{\texorpdfstring{get\+\_\+canonical\+\_\+ordering()}{get\_canonical\_ordering()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+planar\+\_\+drawing.\+get\+\_\+canonical\+\_\+ordering (\begin{DoxyParamCaption}\item[{}]{embedding,  }\item[{}]{outer\+\_\+face }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a canonical ordering of the nodes

The canonical ordering of nodes (v1, ..., vn) must fulfill the following
conditions:
(See Lemma 1 in [2]_)

- For the subgraph G_k of the input graph induced by v1, ..., vk it holds:
    - 2-connected
    - internally triangulated
    - the edge (v1, v2) is part of the outer face
- For a node v(k+1) the following holds:
    - The node v(k+1) is part of the outer face of G_k
    - It has at least two neighbors in G_k
    - All neighbors of v(k+1) in G_k lie consecutively on the outer face of
      G_k (excluding the edge (v1, v2)).

The algorithm used here starts with G_n (containing all nodes). It first
selects the nodes v1 and v2. And then tries to find the order of the other
nodes by checking which node can be removed in order to fulfill the
conditions mentioned above. This is done by calculating the number of
chords of nodes on the outer face. For more information see [1]_.

Parameters
----------
embedding : nx.PlanarEmbedding
    The embedding must be triangulated
outer_face : list
    The nodes on the outer face of the graph

Returns
-------
ordering : list
    A list of tuples `(vk, wp_wq)`. Here `vk` is the node at this position
    in the canonical ordering. The element `wp_wq` is a list of nodes that
    make up the outer face of G_k.

References
----------
.. [1] Steven Chaplick.
    Canonical Orders of Planar Graphs and (some of) Their Applications 2015
    https://wuecampus2.uni-wuerzburg.de/moodle/pluginfile.php/545727/mod_resource/content/0/vg-ss15-vl03-canonical-orders-druckversion.pdf
.. [2] M. Chrobak and T.H. Payne:
    A Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989
    http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1planar__drawing_a2bf4bd4ab4a56044a6fa886186b84487}\label{namespacenetworkx_1_1algorithms_1_1planar__drawing_a2bf4bd4ab4a56044a6fa886186b84487}} 
\index{networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}!make\+\_\+bi\+\_\+connected@{make\+\_\+bi\+\_\+connected}}
\index{make\+\_\+bi\+\_\+connected@{make\+\_\+bi\+\_\+connected}!networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}}
\subsubsection{\texorpdfstring{make\+\_\+bi\+\_\+connected()}{make\_bi\_connected()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+planar\+\_\+drawing.\+make\+\_\+bi\+\_\+connected (\begin{DoxyParamCaption}\item[{}]{embedding,  }\item[{}]{starting\+\_\+node,  }\item[{}]{outgoing\+\_\+node,  }\item[{}]{edges\+\_\+counted }\end{DoxyParamCaption})}

\begin{DoxyVerb}Triangulate a face and make it 2-connected

This method also adds all edges on the face to `edges_counted`.

Parameters
----------
embedding: nx.PlanarEmbedding
    The embedding that defines the faces
starting_node : node
    A node on the face
outgoing_node : node
    A node such that the half edge (starting_node, outgoing_node) belongs
    to the face
edges_counted: set
    Set of all half-edges that belong to a face that have been visited

Returns
-------
face_nodes: list
    A list of all nodes at the border of this face
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1planar__drawing_a982f71be29109cd0fdaa238cf0551a23}\label{namespacenetworkx_1_1algorithms_1_1planar__drawing_a982f71be29109cd0fdaa238cf0551a23}} 
\index{networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}!set\+\_\+position@{set\+\_\+position}}
\index{set\+\_\+position@{set\+\_\+position}!networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}}
\subsubsection{\texorpdfstring{set\+\_\+position()}{set\_position()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+planar\+\_\+drawing.\+set\+\_\+position (\begin{DoxyParamCaption}\item[{}]{parent,  }\item[{}]{tree,  }\item[{}]{remaining\+\_\+nodes,  }\item[{}]{delta\+\_\+x,  }\item[{}]{y\+\_\+coordinate,  }\item[{}]{pos }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper method to calculate the absolute position of nodes.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1planar__drawing_a08ac4a90fdc11925daf5b94ed0789ac3}\label{namespacenetworkx_1_1algorithms_1_1planar__drawing_a08ac4a90fdc11925daf5b94ed0789ac3}} 
\index{networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}!triangulate\+\_\+embedding@{triangulate\+\_\+embedding}}
\index{triangulate\+\_\+embedding@{triangulate\+\_\+embedding}!networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}}
\subsubsection{\texorpdfstring{triangulate\+\_\+embedding()}{triangulate\_embedding()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+planar\+\_\+drawing.\+triangulate\+\_\+embedding (\begin{DoxyParamCaption}\item[{}]{embedding,  }\item[{}]{fully\+\_\+triangulate = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Triangulates the embedding.

Traverses faces of the embedding and adds edges to a copy of the
embedding to triangulate it.
The method also ensures that the resulting graph is 2-connected by adding
edges if the same vertex is contained twice on a path around a face.

Parameters
----------
embedding : nx.PlanarEmbedding
    The input graph must contain at least 3 nodes.

fully_triangulate : bool
    If set to False the face with the most nodes is chooses as outer face.
    This outer face does not get triangulated.

Returns
-------
(embedding, outer_face) : (nx.PlanarEmbedding, list) tuple
    The element `embedding` is a new embedding containing all edges from
    the input embedding and the additional edges to triangulate the graph.
    The element `outer_face` is a list of nodes that lie on the outer face.
    If the graph is fully triangulated these are three arbitrary connected
    nodes.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1planar__drawing_ade5ec6675aba9215ee603d9eec914f79}\label{namespacenetworkx_1_1algorithms_1_1planar__drawing_ade5ec6675aba9215ee603d9eec914f79}} 
\index{networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}!triangulate\+\_\+face@{triangulate\+\_\+face}}
\index{triangulate\+\_\+face@{triangulate\+\_\+face}!networkx\+::algorithms\+::planar\+\_\+drawing@{networkx\+::algorithms\+::planar\+\_\+drawing}}
\subsubsection{\texorpdfstring{triangulate\+\_\+face()}{triangulate\_face()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+planar\+\_\+drawing.\+triangulate\+\_\+face (\begin{DoxyParamCaption}\item[{}]{embedding,  }\item[{}]{v1,  }\item[{}]{v2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Triangulates the face given by half edge (v, w)

Parameters
----------
embedding : nx.PlanarEmbedding
v1 : node
    The half-edge (v1, v2) belongs to the face that gets triangulated
v2 : node
\end{DoxyVerb}
 