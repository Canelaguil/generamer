\hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic}{}\section{networkx.\+algorithms.\+bipartite.\+basic Namespace Reference}
\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic}\index{networkx.\+algorithms.\+bipartite.\+basic@{networkx.\+algorithms.\+bipartite.\+basic}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_a6462e071381cc74c249460b049be721c}{color} (G)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_ae7270bffa6310b169dab29de12670980}{is\+\_\+bipartite} (G)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_ae6daf4a71e3df41c92b02c3004441681}{is\+\_\+bipartite\+\_\+node\+\_\+set} (G, nodes)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_aacbc287cbc9094e5b488d5e3791cc964}{sets} (G, top\+\_\+nodes=None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_a6f01281cb4f0d12041cfef9cbfc4bbb4}{density} (B, nodes)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_a3f81ac1d3e9ad819f508fb97ce748830}{degrees} (B, nodes, weight=None)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}==========================
Bipartite Graph Algorithms
==========================
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_a6462e071381cc74c249460b049be721c}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_a6462e071381cc74c249460b049be721c}} 
\index{networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}!color@{color}}
\index{color@{color}!networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}}
\subsubsection{\texorpdfstring{color()}{color()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+basic.\+color (\begin{DoxyParamCaption}\item[{}]{G }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a two-coloring of the graph.

Raises an exception if the graph is not bipartite.

Parameters
----------
G : NetworkX graph

Returns
-------
color : dictionary
    A dictionary keyed by node with a 1 or 0 as data for each node color.

Raises
------
NetworkXError
    If the graph is not two-colorable.

Examples
--------
>>> from networkx.algorithms import bipartite
>>> G = nx.path_graph(4)
>>> c = bipartite.color(G)
>>> print(c)
{0: 1, 1: 0, 2: 1, 3: 0}

You can use this to set a node attribute indicating the biparite set:

>>> nx.set_node_attributes(G, c, "bipartite")
>>> print(G.nodes[0]["bipartite"])
1
>>> print(G.nodes[1]["bipartite"])
0
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_a3f81ac1d3e9ad819f508fb97ce748830}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_a3f81ac1d3e9ad819f508fb97ce748830}} 
\index{networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}!degrees@{degrees}}
\index{degrees@{degrees}!networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}}
\subsubsection{\texorpdfstring{degrees()}{degrees()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+basic.\+degrees (\begin{DoxyParamCaption}\item[{}]{B,  }\item[{}]{nodes,  }\item[{}]{weight = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the degrees of the two node sets in the bipartite graph B.

Parameters
----------
B : NetworkX graph

nodes: list or container
  Nodes in one node set of the bipartite graph.

weight : string or None, optional (default=None)
   The edge attribute that holds the numerical value used as a weight.
   If None, then each edge has weight 1.
   The degree is the sum of the edge weights adjacent to the node.

Returns
-------
(degX,degY) : tuple of dictionaries
   The degrees of the two bipartite sets as dictionaries keyed by node.

Examples
--------
>>> from networkx.algorithms import bipartite
>>> G = nx.complete_bipartite_graph(3, 2)
>>> Y = set([3, 4])
>>> degX, degY = bipartite.degrees(G, Y)
>>> dict(degX)
{0: 2, 1: 2, 2: 2}

Notes
-----
The container of nodes passed as argument must contain all nodes
in one of the two bipartite node sets to avoid ambiguity in the
case of disconnected graphs.
See :mod:`bipartite documentation <networkx.algorithms.bipartite>`
for further details on how bipartite graphs are handled in NetworkX.

See Also
--------
color, density
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_a6f01281cb4f0d12041cfef9cbfc4bbb4}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_a6f01281cb4f0d12041cfef9cbfc4bbb4}} 
\index{networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}!density@{density}}
\index{density@{density}!networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}}
\subsubsection{\texorpdfstring{density()}{density()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+basic.\+density (\begin{DoxyParamCaption}\item[{}]{B,  }\item[{}]{nodes }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns density of bipartite graph B.

Parameters
----------
B : NetworkX graph

nodes: list or container
  Nodes in one node set of the bipartite graph.

Returns
-------
d : float
   The bipartite density

Examples
--------
>>> from networkx.algorithms import bipartite
>>> G = nx.complete_bipartite_graph(3, 2)
>>> X = set([0, 1, 2])
>>> bipartite.density(G, X)
1.0
>>> Y = set([3, 4])
>>> bipartite.density(G, Y)
1.0

Notes
-----
The container of nodes passed as argument must contain all nodes
in one of the two bipartite node sets to avoid ambiguity in the
case of disconnected graphs.
See :mod:`bipartite documentation <networkx.algorithms.bipartite>`
for further details on how bipartite graphs are handled in NetworkX.

See Also
--------
color
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_ae7270bffa6310b169dab29de12670980}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_ae7270bffa6310b169dab29de12670980}} 
\index{networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}!is\+\_\+bipartite@{is\+\_\+bipartite}}
\index{is\+\_\+bipartite@{is\+\_\+bipartite}!networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}}
\subsubsection{\texorpdfstring{is\+\_\+bipartite()}{is\_bipartite()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+basic.\+is\+\_\+bipartite (\begin{DoxyParamCaption}\item[{}]{G }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if graph G is bipartite, False if not.

Parameters
----------
G : NetworkX graph

Examples
--------
>>> from networkx.algorithms import bipartite
>>> G = nx.path_graph(4)
>>> print(bipartite.is_bipartite(G))
True

See Also
--------
color, is_bipartite_node_set
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_ae6daf4a71e3df41c92b02c3004441681}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_ae6daf4a71e3df41c92b02c3004441681}} 
\index{networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}!is\+\_\+bipartite\+\_\+node\+\_\+set@{is\+\_\+bipartite\+\_\+node\+\_\+set}}
\index{is\+\_\+bipartite\+\_\+node\+\_\+set@{is\+\_\+bipartite\+\_\+node\+\_\+set}!networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}}
\subsubsection{\texorpdfstring{is\+\_\+bipartite\+\_\+node\+\_\+set()}{is\_bipartite\_node\_set()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+basic.\+is\+\_\+bipartite\+\_\+node\+\_\+set (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{nodes }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if nodes and G/nodes are a bipartition of G.

Parameters
----------
G : NetworkX graph

nodes: list or container
  Check if nodes are a one of a bipartite set.

Examples
--------
>>> from networkx.algorithms import bipartite
>>> G = nx.path_graph(4)
>>> X = set([1, 3])
>>> bipartite.is_bipartite_node_set(G, X)
True

Notes
-----
For connected graphs the bipartite sets are unique.  This function handles
disconnected graphs.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_aacbc287cbc9094e5b488d5e3791cc964}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic_aacbc287cbc9094e5b488d5e3791cc964}} 
\index{networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}!sets@{sets}}
\index{sets@{sets}!networkx\+::algorithms\+::bipartite\+::basic@{networkx\+::algorithms\+::bipartite\+::basic}}
\subsubsection{\texorpdfstring{sets()}{sets()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+basic.\+sets (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{top\+\_\+nodes = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns bipartite node sets of graph G.

Raises an exception if the graph is not bipartite or if the input
graph is disconnected and thus more than one valid solution exists.
See :mod:`bipartite documentation <networkx.algorithms.bipartite>`
for further details on how bipartite graphs are handled in NetworkX.

Parameters
----------
G : NetworkX graph

top_nodes : container, optional
  Container with all nodes in one bipartite node set. If not supplied
  it will be computed. But if more than one solution exists an exception
  will be raised.

Returns
-------
X : set
  Nodes from one side of the bipartite graph.
Y : set
  Nodes from the other side.

Raises
------
AmbiguousSolution
  Raised if the input bipartite graph is disconnected and no container
  with all nodes in one bipartite set is provided. When determining
  the nodes in each bipartite set more than one valid solution is
  possible if the input graph is disconnected.
NetworkXError
  Raised if the input graph is not bipartite.

Examples
--------
>>> from networkx.algorithms import bipartite
>>> G = nx.path_graph(4)
>>> X, Y = bipartite.sets(G)
>>> list(X)
[0, 2]
>>> list(Y)
[1, 3]

See Also
--------
color\end{DoxyVerb}
 