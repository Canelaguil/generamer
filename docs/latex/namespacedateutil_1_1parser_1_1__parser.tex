\hypertarget{namespacedateutil_1_1parser_1_1__parser}{}\section{dateutil.\+parser.\+\_\+parser Namespace Reference}
\label{namespacedateutil_1_1parser_1_1__parser}\index{dateutil.\+parser.\+\_\+parser@{dateutil.\+parser.\+\_\+parser}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classdateutil_1_1parser_1_1__parser_1_1__resultbase}{\+\_\+resultbase}
\item 
class \hyperlink{classdateutil_1_1parser_1_1__parser_1_1__timelex}{\+\_\+timelex}
\item 
class \hyperlink{classdateutil_1_1parser_1_1__parser_1_1__tzparser}{\+\_\+tzparser}
\item 
class \hyperlink{classdateutil_1_1parser_1_1__parser_1_1__ymd}{\+\_\+ymd}
\item 
class \hyperlink{classdateutil_1_1parser_1_1__parser_1_1parser}{parser}
\item 
class \hyperlink{classdateutil_1_1parser_1_1__parser_1_1ParserError}{Parser\+Error}
\item 
class \hyperlink{classdateutil_1_1parser_1_1__parser_1_1parserinfo}{parserinfo}
\item 
class \hyperlink{classdateutil_1_1parser_1_1__parser_1_1UnknownTimezoneWarning}{Unknown\+Timezone\+Warning}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacedateutil_1_1parser_1_1__parser_aa5fbf50041e5bc1cee98263750783f7c}{parse} (timestr, \hyperlink{classdateutil_1_1parser_1_1__parser_1_1parserinfo}{parserinfo}=None, kwargs)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacedateutil_1_1parser_1_1__parser_a8e75ff5e3f1593dc66f300731a663464}{D\+E\+F\+A\+U\+L\+T\+P\+A\+R\+S\+ER} = \hyperlink{classdateutil_1_1parser_1_1__parser_1_1parser}{parser}()
\item 
\hyperlink{namespacedateutil_1_1parser_1_1__parser_ac93cf0effa79f2c46ff007c2b4b105e9}{D\+E\+F\+A\+U\+L\+T\+T\+Z\+P\+A\+R\+S\+ER} = \hyperlink{classdateutil_1_1parser_1_1__parser_1_1__tzparser}{\+\_\+tzparser}()
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacedateutil_1_1parser_1_1__parser_aa5fbf50041e5bc1cee98263750783f7c}\label{namespacedateutil_1_1parser_1_1__parser_aa5fbf50041e5bc1cee98263750783f7c}} 
\index{dateutil\+::parser\+::\+\_\+parser@{dateutil\+::parser\+::\+\_\+parser}!parse@{parse}}
\index{parse@{parse}!dateutil\+::parser\+::\+\_\+parser@{dateutil\+::parser\+::\+\_\+parser}}
\subsubsection{\texorpdfstring{parse()}{parse()}}
{\footnotesize\ttfamily def dateutil.\+parser.\+\_\+parser.\+parse (\begin{DoxyParamCaption}\item[{}]{timestr,  }\item[{}]{parserinfo = {\ttfamily None},  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Parse a string in one of the supported formats, using the
``parserinfo`` parameters.

:param timestr:
    A string containing a date/time stamp.

:param parserinfo:
    A :class:`parserinfo` object containing parameters for the parser.
    If ``None``, the default arguments to the :class:`parserinfo`
    constructor are used.

The ``**kwargs`` parameter takes the following keyword arguments:

:param default:
    The default datetime object, if this is a datetime object and not
    ``None``, elements specified in ``timestr`` replace elements in the
    default object.

:param ignoretz:
    If set ``True``, time zones in parsed strings are ignored and a naive
    :class:`datetime` object is returned.

:param tzinfos:
    Additional time zone names / aliases which may be present in the
    string. This argument maps time zone names (and optionally offsets
    from those time zones) to time zones. This parameter can be a
    dictionary with timezone aliases mapping time zone names to time
    zones or a function taking two parameters (``tzname`` and
    ``tzoffset``) and returning a time zone.

    The timezones to which the names are mapped can be an integer
    offset from UTC in seconds or a :class:`tzinfo` object.

    .. doctest::
       :options: +NORMALIZE_WHITESPACE

        >>> from dateutil.parser import parse
        >>> from dateutil.tz import gettz
        >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
        >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
        datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
        >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
        datetime.datetime(2012, 1, 19, 17, 21,
                          tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))

    This parameter is ignored if ``ignoretz`` is set.

:param dayfirst:
    Whether to interpret the first value in an ambiguous 3-integer date
    (e.g. 01/05/09) as the day (``True``) or month (``False``). If
    ``yearfirst`` is set to ``True``, this distinguishes between YDM and
    YMD. If set to ``None``, this value is retrieved from the current
    :class:`parserinfo` object (which itself defaults to ``False``).

:param yearfirst:
    Whether to interpret the first value in an ambiguous 3-integer date
    (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
    be the year, otherwise the last number is taken to be the year. If
    this is set to ``None``, the value is retrieved from the current
    :class:`parserinfo` object (which itself defaults to ``False``).

:param fuzzy:
    Whether to allow fuzzy parsing, allowing for string like "Today is
    January 1, 2047 at 8:21:00AM".

:param fuzzy_with_tokens:
    If ``True``, ``fuzzy`` is automatically set to True, and the parser
    will return a tuple where the first element is the parsed
    :class:`datetime.datetime` datetimestamp and the second element is
    a tuple containing the portions of the string which were ignored:

    .. doctest::

        >>> from dateutil.parser import parse
        >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
        (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))

:return:
    Returns a :class:`datetime.datetime` object or, if the
    ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
    first element being a :class:`datetime.datetime` object, the second
    a tuple containing the fuzzy tokens.

:raises ParserError:
    Raised for invalid or unknown string formats, if the provided
    :class:`tzinfo` is not in a valid format, or if an invalid date would
    be created.

:raises OverflowError:
    Raised if the parsed date exceeds the largest valid C integer on
    your system.
\end{DoxyVerb}
 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespacedateutil_1_1parser_1_1__parser_a8e75ff5e3f1593dc66f300731a663464}\label{namespacedateutil_1_1parser_1_1__parser_a8e75ff5e3f1593dc66f300731a663464}} 
\index{dateutil\+::parser\+::\+\_\+parser@{dateutil\+::parser\+::\+\_\+parser}!D\+E\+F\+A\+U\+L\+T\+P\+A\+R\+S\+ER@{D\+E\+F\+A\+U\+L\+T\+P\+A\+R\+S\+ER}}
\index{D\+E\+F\+A\+U\+L\+T\+P\+A\+R\+S\+ER@{D\+E\+F\+A\+U\+L\+T\+P\+A\+R\+S\+ER}!dateutil\+::parser\+::\+\_\+parser@{dateutil\+::parser\+::\+\_\+parser}}
\subsubsection{\texorpdfstring{D\+E\+F\+A\+U\+L\+T\+P\+A\+R\+S\+ER}{DEFAULTPARSER}}
{\footnotesize\ttfamily dateutil.\+parser.\+\_\+parser.\+D\+E\+F\+A\+U\+L\+T\+P\+A\+R\+S\+ER = \hyperlink{classdateutil_1_1parser_1_1__parser_1_1parser}{parser}()}

\mbox{\Hypertarget{namespacedateutil_1_1parser_1_1__parser_ac93cf0effa79f2c46ff007c2b4b105e9}\label{namespacedateutil_1_1parser_1_1__parser_ac93cf0effa79f2c46ff007c2b4b105e9}} 
\index{dateutil\+::parser\+::\+\_\+parser@{dateutil\+::parser\+::\+\_\+parser}!D\+E\+F\+A\+U\+L\+T\+T\+Z\+P\+A\+R\+S\+ER@{D\+E\+F\+A\+U\+L\+T\+T\+Z\+P\+A\+R\+S\+ER}}
\index{D\+E\+F\+A\+U\+L\+T\+T\+Z\+P\+A\+R\+S\+ER@{D\+E\+F\+A\+U\+L\+T\+T\+Z\+P\+A\+R\+S\+ER}!dateutil\+::parser\+::\+\_\+parser@{dateutil\+::parser\+::\+\_\+parser}}
\subsubsection{\texorpdfstring{D\+E\+F\+A\+U\+L\+T\+T\+Z\+P\+A\+R\+S\+ER}{DEFAULTTZPARSER}}
{\footnotesize\ttfamily dateutil.\+parser.\+\_\+parser.\+D\+E\+F\+A\+U\+L\+T\+T\+Z\+P\+A\+R\+S\+ER = \hyperlink{classdateutil_1_1parser_1_1__parser_1_1__tzparser}{\+\_\+tzparser}()}

