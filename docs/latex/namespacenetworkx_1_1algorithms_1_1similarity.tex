\hypertarget{namespacenetworkx_1_1algorithms_1_1similarity}{}\section{networkx.\+algorithms.\+similarity Namespace Reference}
\label{namespacenetworkx_1_1algorithms_1_1similarity}\index{networkx.\+algorithms.\+similarity@{networkx.\+algorithms.\+similarity}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a5d674d26dfed10d077b2bcba5902a5f8}{debug\+\_\+print} (args, kwargs)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a884d76faa68663c18288eb5f32eaea7b}{graph\+\_\+edit\+\_\+distance} (G1, G2, node\+\_\+match=None, edge\+\_\+match=None, node\+\_\+subst\+\_\+cost=None, node\+\_\+del\+\_\+cost=None, node\+\_\+ins\+\_\+cost=None, edge\+\_\+subst\+\_\+cost=None, edge\+\_\+del\+\_\+cost=None, edge\+\_\+ins\+\_\+cost=None, roots=None, upper\+\_\+bound=None, timeout=None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a29f7692d60e03483f0160961805dc9fb}{optimal\+\_\+edit\+\_\+paths} (G1, G2, node\+\_\+match=None, edge\+\_\+match=None, node\+\_\+subst\+\_\+cost=None, node\+\_\+del\+\_\+cost=None, node\+\_\+ins\+\_\+cost=None, edge\+\_\+subst\+\_\+cost=None, edge\+\_\+del\+\_\+cost=None, edge\+\_\+ins\+\_\+cost=None, upper\+\_\+bound=None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a094b2ec3e7fd9c7e6b285ff592c1384c}{optimize\+\_\+graph\+\_\+edit\+\_\+distance} (G1, G2, node\+\_\+match=None, edge\+\_\+match=None, node\+\_\+subst\+\_\+cost=None, node\+\_\+del\+\_\+cost=None, node\+\_\+ins\+\_\+cost=None, edge\+\_\+subst\+\_\+cost=None, edge\+\_\+del\+\_\+cost=None, edge\+\_\+ins\+\_\+cost=None, upper\+\_\+bound=None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a07687d73f299d48abf6c9d20b43d1e4f}{optimize\+\_\+edit\+\_\+paths} (G1, G2, node\+\_\+match=None, edge\+\_\+match=None, node\+\_\+subst\+\_\+cost=None, node\+\_\+del\+\_\+cost=None, node\+\_\+ins\+\_\+cost=None, edge\+\_\+subst\+\_\+cost=None, edge\+\_\+del\+\_\+cost=None, edge\+\_\+ins\+\_\+cost=None, upper\+\_\+bound=None, strictly\+\_\+decreasing=True, roots=None, timeout=None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a3ab3e57878c9ac3f9b4bb761079276e1}{simrank\+\_\+similarity} (G, source=None, target=None, importance\+\_\+factor=0.\+9, max\+\_\+iterations=1000, tolerance=1e-\/4)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a60b65f73b755236d64f0fa6e2006f310}{simrank\+\_\+similarity\+\_\+numpy} (G, source=None, target=None, importance\+\_\+factor=0.\+9, max\+\_\+iterations=100, tolerance=1e-\/4)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a3048856cdc525be8a48d87b458e16a14}{panther\+\_\+similarity} (G, source, k=5, path\+\_\+length=5, c=0.\+5, delta=0.\+1, eps=None)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_aa014fc0b0861d475e18f287838625f41}{generate\+\_\+random\+\_\+paths} (G, sample\+\_\+size, path\+\_\+length=5, index\+\_\+map=None)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_af8f89640fd73be251fc4c663d33ec18e}{C}
\item 
\hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a55d767953a48a5084aa61a5476467268}{lsa\+\_\+row\+\_\+ind}
\item 
\hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a4aa2ee80a261aded9e24222f90d81658}{lsa\+\_\+col\+\_\+ind}
\item 
\hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_ad3e4352e1974ac4cab904c376f999c6b}{ls}
\item 
\hyperlink{namespacenetworkx_1_1algorithms_1_1similarity_a9a6b624064a8d878701909b6ae7a8d9c}{value}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Functions measuring similarity using graph edit distance.

The graph edit distance is the number of edge/node changes needed
to make two graphs isomorphic.

The default algorithm/implementation is sub-optimal for some graphs.
The problem of finding the exact Graph Edit Distance (GED) is NP-hard
so it is often slow. If the simple interface `graph_edit_distance`
takes too long for your graph, try `optimize_graph_edit_distance`
and/or `optimize_edit_paths`.

At the same time, I encourage capable people to investigate
alternative GED algorithms, in order to improve the choices available.
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a5d674d26dfed10d077b2bcba5902a5f8}\label{namespacenetworkx_1_1algorithms_1_1similarity_a5d674d26dfed10d077b2bcba5902a5f8}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!debug\+\_\+print@{debug\+\_\+print}}
\index{debug\+\_\+print@{debug\+\_\+print}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{debug\+\_\+print()}{debug\_print()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+similarity.\+debug\+\_\+print (\begin{DoxyParamCaption}\item[{}]{args,  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_aa014fc0b0861d475e18f287838625f41}\label{namespacenetworkx_1_1algorithms_1_1similarity_aa014fc0b0861d475e18f287838625f41}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!generate\+\_\+random\+\_\+paths@{generate\+\_\+random\+\_\+paths}}
\index{generate\+\_\+random\+\_\+paths@{generate\+\_\+random\+\_\+paths}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{generate\+\_\+random\+\_\+paths()}{generate\_random\_paths()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+similarity.\+generate\+\_\+random\+\_\+paths (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{sample\+\_\+size,  }\item[{}]{path\+\_\+length = {\ttfamily 5},  }\item[{}]{index\+\_\+map = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Randomly generate `sample_size` paths of length `path_length`.

Parameters
----------
G : NetworkX graph
    A NetworkX graph
sample_size : integer
    The number of paths to generate. This is ``R`` in [1]_.
path_length : integer (default = 5)
    The maximum size of the path to randomly generate.
    This is ``T`` in [1]_. According to the paper, ``T >= 5`` is
    recommended.
index_map : dictionary, optional
    If provided, this will be populated with the inverted
    index of nodes mapped to the set of generated random path
    indices within ``paths``.

Returns
-------
paths : generator of lists
    Generator of `sample_size` paths each with length `path_length`.

Examples
--------
Note that the return value is the list of paths:

>>> G = nx.star_graph(3)
>>> random_path = nx.generate_random_paths(G, 2)

By passing a dictionary into `index_map`, it will build an
inverted index mapping of nodes to the paths in which that node is present:

>>> G = nx.star_graph(3)
>>> index_map = {}
>>> random_path = nx.generate_random_paths(G, 3, index_map=index_map)
>>> paths_containing_node_0 = [random_path[path_idx] for path_idx in index_map.get(0, [])]

References
----------
.. [1] Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.
       Panther: Fast top-k similarity search on large networks.
       In Proceedings of the ACM SIGKDD International Conference
       on Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445â€“1454).
       Association for Computing Machinery. https://doi.org/10.1145/2783258.2783267.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a884d76faa68663c18288eb5f32eaea7b}\label{namespacenetworkx_1_1algorithms_1_1similarity_a884d76faa68663c18288eb5f32eaea7b}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!graph\+\_\+edit\+\_\+distance@{graph\+\_\+edit\+\_\+distance}}
\index{graph\+\_\+edit\+\_\+distance@{graph\+\_\+edit\+\_\+distance}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{graph\+\_\+edit\+\_\+distance()}{graph\_edit\_distance()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+similarity.\+graph\+\_\+edit\+\_\+distance (\begin{DoxyParamCaption}\item[{}]{G1,  }\item[{}]{G2,  }\item[{}]{node\+\_\+match = {\ttfamily None},  }\item[{}]{edge\+\_\+match = {\ttfamily None},  }\item[{}]{node\+\_\+subst\+\_\+cost = {\ttfamily None},  }\item[{}]{node\+\_\+del\+\_\+cost = {\ttfamily None},  }\item[{}]{node\+\_\+ins\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+subst\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+del\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+ins\+\_\+cost = {\ttfamily None},  }\item[{}]{roots = {\ttfamily None},  }\item[{}]{upper\+\_\+bound = {\ttfamily None},  }\item[{}]{timeout = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns GED (graph edit distance) between graphs G1 and G2.

Graph edit distance is a graph similarity measure analogous to
Levenshtein distance for strings.  It is defined as minimum cost
of edit path (sequence of node and edge edit operations)
transforming graph G1 to graph isomorphic to G2.

Parameters
----------
G1, G2: graphs
    The two graphs G1 and G2 must be of the same type.

node_match : callable
    A function that returns True if node n1 in G1 and n2 in G2
    should be considered equal during matching.

    The function will be called like

       node_match(G1.nodes[n1], G2.nodes[n2]).

    That is, the function will receive the node attribute
    dictionaries for n1 and n2 as inputs.

    Ignored if node_subst_cost is specified.  If neither
    node_match nor node_subst_cost are specified then node
    attributes are not considered.

edge_match : callable
    A function that returns True if the edge attribute dictionaries
    for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should
    be considered equal during matching.

    The function will be called like

       edge_match(G1[u1][v1], G2[u2][v2]).

    That is, the function will receive the edge attribute
    dictionaries of the edges under consideration.

    Ignored if edge_subst_cost is specified.  If neither
    edge_match nor edge_subst_cost are specified then edge
    attributes are not considered.

node_subst_cost, node_del_cost, node_ins_cost : callable
    Functions that return the costs of node substitution, node
    deletion, and node insertion, respectively.

    The functions will be called like

       node_subst_cost(G1.nodes[n1], G2.nodes[n2]),
       node_del_cost(G1.nodes[n1]),
       node_ins_cost(G2.nodes[n2]).

    That is, the functions will receive the node attribute
    dictionaries as inputs.  The functions are expected to return
    positive numeric values.

    Function node_subst_cost overrides node_match if specified.
    If neither node_match nor node_subst_cost are specified then
    default node substitution cost of 0 is used (node attributes
    are not considered during matching).

    If node_del_cost is not specified then default node deletion
    cost of 1 is used.  If node_ins_cost is not specified then
    default node insertion cost of 1 is used.

edge_subst_cost, edge_del_cost, edge_ins_cost : callable
    Functions that return the costs of edge substitution, edge
    deletion, and edge insertion, respectively.

    The functions will be called like

       edge_subst_cost(G1[u1][v1], G2[u2][v2]),
       edge_del_cost(G1[u1][v1]),
       edge_ins_cost(G2[u2][v2]).

    That is, the functions will receive the edge attribute
    dictionaries as inputs.  The functions are expected to return
    positive numeric values.

    Function edge_subst_cost overrides edge_match if specified.
    If neither edge_match nor edge_subst_cost are specified then
    default edge substitution cost of 0 is used (edge attributes
    are not considered during matching).

    If edge_del_cost is not specified then default edge deletion
    cost of 1 is used.  If edge_ins_cost is not specified then
    default edge insertion cost of 1 is used.

roots : 2-tuple
    Tuple where first element is a node in G1 and the second
    is a node in G2.
    These nodes are forced to be matched in the comparison to
    allow comparison between rooted graphs.

upper_bound : numeric
    Maximum edit distance to consider.  Return None if no edit
    distance under or equal to upper_bound exists.

timeout : numeric
    Maximum number of seconds to execute.
    After timeout is met, the current best GED is returned.

Examples
--------
>>> G1 = nx.cycle_graph(6)
>>> G2 = nx.wheel_graph(7)
>>> nx.graph_edit_distance(G1, G2)
7.0

>>> G1 = nx.star_graph(5)
>>> G2 = nx.star_graph(5)
>>> nx.graph_edit_distance(G1, G2, roots=(0, 0))
0.0
>>> nx.graph_edit_distance(G1, G2, roots=(1, 0))
8.0

See Also
--------
optimal_edit_paths, optimize_graph_edit_distance,

is_isomorphic: test for graph edit distance of 0

References
----------
.. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick
   Martineau. An Exact Graph Edit Distance Algorithm for Solving
   Pattern Recognition Problems. 4th International Conference on
   Pattern Recognition Applications and Methods 2015, Jan 2015,
   Lisbon, Portugal. 2015,
   <10.5220/0005209202710278>. <hal-01168816>
   https://hal.archives-ouvertes.fr/hal-01168816\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a29f7692d60e03483f0160961805dc9fb}\label{namespacenetworkx_1_1algorithms_1_1similarity_a29f7692d60e03483f0160961805dc9fb}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!optimal\+\_\+edit\+\_\+paths@{optimal\+\_\+edit\+\_\+paths}}
\index{optimal\+\_\+edit\+\_\+paths@{optimal\+\_\+edit\+\_\+paths}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{optimal\+\_\+edit\+\_\+paths()}{optimal\_edit\_paths()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+similarity.\+optimal\+\_\+edit\+\_\+paths (\begin{DoxyParamCaption}\item[{}]{G1,  }\item[{}]{G2,  }\item[{}]{node\+\_\+match = {\ttfamily None},  }\item[{}]{edge\+\_\+match = {\ttfamily None},  }\item[{}]{node\+\_\+subst\+\_\+cost = {\ttfamily None},  }\item[{}]{node\+\_\+del\+\_\+cost = {\ttfamily None},  }\item[{}]{node\+\_\+ins\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+subst\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+del\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+ins\+\_\+cost = {\ttfamily None},  }\item[{}]{upper\+\_\+bound = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns all minimum-cost edit paths transforming G1 to G2.

Graph edit path is a sequence of node and edge edit operations
transforming graph G1 to graph isomorphic to G2.  Edit operations
include substitutions, deletions, and insertions.

Parameters
----------
G1, G2: graphs
    The two graphs G1 and G2 must be of the same type.

node_match : callable
    A function that returns True if node n1 in G1 and n2 in G2
    should be considered equal during matching.

    The function will be called like

       node_match(G1.nodes[n1], G2.nodes[n2]).

    That is, the function will receive the node attribute
    dictionaries for n1 and n2 as inputs.

    Ignored if node_subst_cost is specified.  If neither
    node_match nor node_subst_cost are specified then node
    attributes are not considered.

edge_match : callable
    A function that returns True if the edge attribute dictionaries
    for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should
    be considered equal during matching.

    The function will be called like

       edge_match(G1[u1][v1], G2[u2][v2]).

    That is, the function will receive the edge attribute
    dictionaries of the edges under consideration.

    Ignored if edge_subst_cost is specified.  If neither
    edge_match nor edge_subst_cost are specified then edge
    attributes are not considered.

node_subst_cost, node_del_cost, node_ins_cost : callable
    Functions that return the costs of node substitution, node
    deletion, and node insertion, respectively.

    The functions will be called like

       node_subst_cost(G1.nodes[n1], G2.nodes[n2]),
       node_del_cost(G1.nodes[n1]),
       node_ins_cost(G2.nodes[n2]).

    That is, the functions will receive the node attribute
    dictionaries as inputs.  The functions are expected to return
    positive numeric values.

    Function node_subst_cost overrides node_match if specified.
    If neither node_match nor node_subst_cost are specified then
    default node substitution cost of 0 is used (node attributes
    are not considered during matching).

    If node_del_cost is not specified then default node deletion
    cost of 1 is used.  If node_ins_cost is not specified then
    default node insertion cost of 1 is used.

edge_subst_cost, edge_del_cost, edge_ins_cost : callable
    Functions that return the costs of edge substitution, edge
    deletion, and edge insertion, respectively.

    The functions will be called like

       edge_subst_cost(G1[u1][v1], G2[u2][v2]),
       edge_del_cost(G1[u1][v1]),
       edge_ins_cost(G2[u2][v2]).

    That is, the functions will receive the edge attribute
    dictionaries as inputs.  The functions are expected to return
    positive numeric values.

    Function edge_subst_cost overrides edge_match if specified.
    If neither edge_match nor edge_subst_cost are specified then
    default edge substitution cost of 0 is used (edge attributes
    are not considered during matching).

    If edge_del_cost is not specified then default edge deletion
    cost of 1 is used.  If edge_ins_cost is not specified then
    default edge insertion cost of 1 is used.

upper_bound : numeric
    Maximum edit distance to consider.

Returns
-------
edit_paths : list of tuples (node_edit_path, edge_edit_path)
    node_edit_path : list of tuples (u, v)
    edge_edit_path : list of tuples ((u1, v1), (u2, v2))

cost : numeric
    Optimal edit path cost (graph edit distance).

Examples
--------
>>> G1 = nx.cycle_graph(4)
>>> G2 = nx.wheel_graph(5)
>>> paths, cost = nx.optimal_edit_paths(G1, G2)
>>> len(paths)
40
>>> cost
5.0

See Also
--------
graph_edit_distance, optimize_edit_paths

References
----------
.. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick
   Martineau. An Exact Graph Edit Distance Algorithm for Solving
   Pattern Recognition Problems. 4th International Conference on
   Pattern Recognition Applications and Methods 2015, Jan 2015,
   Lisbon, Portugal. 2015,
   <10.5220/0005209202710278>. <hal-01168816>
   https://hal.archives-ouvertes.fr/hal-01168816\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a07687d73f299d48abf6c9d20b43d1e4f}\label{namespacenetworkx_1_1algorithms_1_1similarity_a07687d73f299d48abf6c9d20b43d1e4f}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!optimize\+\_\+edit\+\_\+paths@{optimize\+\_\+edit\+\_\+paths}}
\index{optimize\+\_\+edit\+\_\+paths@{optimize\+\_\+edit\+\_\+paths}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{optimize\+\_\+edit\+\_\+paths()}{optimize\_edit\_paths()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+similarity.\+optimize\+\_\+edit\+\_\+paths (\begin{DoxyParamCaption}\item[{}]{G1,  }\item[{}]{G2,  }\item[{}]{node\+\_\+match = {\ttfamily None},  }\item[{}]{edge\+\_\+match = {\ttfamily None},  }\item[{}]{node\+\_\+subst\+\_\+cost = {\ttfamily None},  }\item[{}]{node\+\_\+del\+\_\+cost = {\ttfamily None},  }\item[{}]{node\+\_\+ins\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+subst\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+del\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+ins\+\_\+cost = {\ttfamily None},  }\item[{}]{upper\+\_\+bound = {\ttfamily None},  }\item[{}]{strictly\+\_\+decreasing = {\ttfamily True},  }\item[{}]{roots = {\ttfamily None},  }\item[{}]{timeout = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}GED (graph edit distance) calculation: advanced interface.

Graph edit path is a sequence of node and edge edit operations
transforming graph G1 to graph isomorphic to G2.  Edit operations
include substitutions, deletions, and insertions.

Graph edit distance is defined as minimum cost of edit path.

Parameters
----------
G1, G2: graphs
    The two graphs G1 and G2 must be of the same type.

node_match : callable
    A function that returns True if node n1 in G1 and n2 in G2
    should be considered equal during matching.

    The function will be called like

       node_match(G1.nodes[n1], G2.nodes[n2]).

    That is, the function will receive the node attribute
    dictionaries for n1 and n2 as inputs.

    Ignored if node_subst_cost is specified.  If neither
    node_match nor node_subst_cost are specified then node
    attributes are not considered.

edge_match : callable
    A function that returns True if the edge attribute dictionaries
    for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should
    be considered equal during matching.

    The function will be called like

       edge_match(G1[u1][v1], G2[u2][v2]).

    That is, the function will receive the edge attribute
    dictionaries of the edges under consideration.

    Ignored if edge_subst_cost is specified.  If neither
    edge_match nor edge_subst_cost are specified then edge
    attributes are not considered.

node_subst_cost, node_del_cost, node_ins_cost : callable
    Functions that return the costs of node substitution, node
    deletion, and node insertion, respectively.

    The functions will be called like

       node_subst_cost(G1.nodes[n1], G2.nodes[n2]),
       node_del_cost(G1.nodes[n1]),
       node_ins_cost(G2.nodes[n2]).

    That is, the functions will receive the node attribute
    dictionaries as inputs.  The functions are expected to return
    positive numeric values.

    Function node_subst_cost overrides node_match if specified.
    If neither node_match nor node_subst_cost are specified then
    default node substitution cost of 0 is used (node attributes
    are not considered during matching).

    If node_del_cost is not specified then default node deletion
    cost of 1 is used.  If node_ins_cost is not specified then
    default node insertion cost of 1 is used.

edge_subst_cost, edge_del_cost, edge_ins_cost : callable
    Functions that return the costs of edge substitution, edge
    deletion, and edge insertion, respectively.

    The functions will be called like

       edge_subst_cost(G1[u1][v1], G2[u2][v2]),
       edge_del_cost(G1[u1][v1]),
       edge_ins_cost(G2[u2][v2]).

    That is, the functions will receive the edge attribute
    dictionaries as inputs.  The functions are expected to return
    positive numeric values.

    Function edge_subst_cost overrides edge_match if specified.
    If neither edge_match nor edge_subst_cost are specified then
    default edge substitution cost of 0 is used (edge attributes
    are not considered during matching).

    If edge_del_cost is not specified then default edge deletion
    cost of 1 is used.  If edge_ins_cost is not specified then
    default edge insertion cost of 1 is used.

upper_bound : numeric
    Maximum edit distance to consider.

strictly_decreasing : bool
    If True, return consecutive approximations of strictly
    decreasing cost.  Otherwise, return all edit paths of cost
    less than or equal to the previous minimum cost.

roots : 2-tuple
    Tuple where first element is a node in G1 and the second
    is a node in G2.
    These nodes are forced to be matched in the comparison to
    allow comparison between rooted graphs.

timeout : numeric
    Maximum number of seconds to execute.
    After timeout is met, the current best GED is returned.

Returns
-------
Generator of tuples (node_edit_path, edge_edit_path, cost)
    node_edit_path : list of tuples (u, v)
    edge_edit_path : list of tuples ((u1, v1), (u2, v2))
    cost : numeric

See Also
--------
graph_edit_distance, optimize_graph_edit_distance, optimal_edit_paths

References
----------
.. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick
   Martineau. An Exact Graph Edit Distance Algorithm for Solving
   Pattern Recognition Problems. 4th International Conference on
   Pattern Recognition Applications and Methods 2015, Jan 2015,
   Lisbon, Portugal. 2015,
   <10.5220/0005209202710278>. <hal-01168816>
   https://hal.archives-ouvertes.fr/hal-01168816\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a094b2ec3e7fd9c7e6b285ff592c1384c}\label{namespacenetworkx_1_1algorithms_1_1similarity_a094b2ec3e7fd9c7e6b285ff592c1384c}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!optimize\+\_\+graph\+\_\+edit\+\_\+distance@{optimize\+\_\+graph\+\_\+edit\+\_\+distance}}
\index{optimize\+\_\+graph\+\_\+edit\+\_\+distance@{optimize\+\_\+graph\+\_\+edit\+\_\+distance}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{optimize\+\_\+graph\+\_\+edit\+\_\+distance()}{optimize\_graph\_edit\_distance()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+similarity.\+optimize\+\_\+graph\+\_\+edit\+\_\+distance (\begin{DoxyParamCaption}\item[{}]{G1,  }\item[{}]{G2,  }\item[{}]{node\+\_\+match = {\ttfamily None},  }\item[{}]{edge\+\_\+match = {\ttfamily None},  }\item[{}]{node\+\_\+subst\+\_\+cost = {\ttfamily None},  }\item[{}]{node\+\_\+del\+\_\+cost = {\ttfamily None},  }\item[{}]{node\+\_\+ins\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+subst\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+del\+\_\+cost = {\ttfamily None},  }\item[{}]{edge\+\_\+ins\+\_\+cost = {\ttfamily None},  }\item[{}]{upper\+\_\+bound = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns consecutive approximations of GED (graph edit distance)
between graphs G1 and G2.

Graph edit distance is a graph similarity measure analogous to
Levenshtein distance for strings.  It is defined as minimum cost
of edit path (sequence of node and edge edit operations)
transforming graph G1 to graph isomorphic to G2.

Parameters
----------
G1, G2: graphs
    The two graphs G1 and G2 must be of the same type.

node_match : callable
    A function that returns True if node n1 in G1 and n2 in G2
    should be considered equal during matching.

    The function will be called like

       node_match(G1.nodes[n1], G2.nodes[n2]).

    That is, the function will receive the node attribute
    dictionaries for n1 and n2 as inputs.

    Ignored if node_subst_cost is specified.  If neither
    node_match nor node_subst_cost are specified then node
    attributes are not considered.

edge_match : callable
    A function that returns True if the edge attribute dictionaries
    for the pair of nodes (u1, v1) in G1 and (u2, v2) in G2 should
    be considered equal during matching.

    The function will be called like

       edge_match(G1[u1][v1], G2[u2][v2]).

    That is, the function will receive the edge attribute
    dictionaries of the edges under consideration.

    Ignored if edge_subst_cost is specified.  If neither
    edge_match nor edge_subst_cost are specified then edge
    attributes are not considered.

node_subst_cost, node_del_cost, node_ins_cost : callable
    Functions that return the costs of node substitution, node
    deletion, and node insertion, respectively.

    The functions will be called like

       node_subst_cost(G1.nodes[n1], G2.nodes[n2]),
       node_del_cost(G1.nodes[n1]),
       node_ins_cost(G2.nodes[n2]).

    That is, the functions will receive the node attribute
    dictionaries as inputs.  The functions are expected to return
    positive numeric values.

    Function node_subst_cost overrides node_match if specified.
    If neither node_match nor node_subst_cost are specified then
    default node substitution cost of 0 is used (node attributes
    are not considered during matching).

    If node_del_cost is not specified then default node deletion
    cost of 1 is used.  If node_ins_cost is not specified then
    default node insertion cost of 1 is used.

edge_subst_cost, edge_del_cost, edge_ins_cost : callable
    Functions that return the costs of edge substitution, edge
    deletion, and edge insertion, respectively.

    The functions will be called like

       edge_subst_cost(G1[u1][v1], G2[u2][v2]),
       edge_del_cost(G1[u1][v1]),
       edge_ins_cost(G2[u2][v2]).

    That is, the functions will receive the edge attribute
    dictionaries as inputs.  The functions are expected to return
    positive numeric values.

    Function edge_subst_cost overrides edge_match if specified.
    If neither edge_match nor edge_subst_cost are specified then
    default edge substitution cost of 0 is used (edge attributes
    are not considered during matching).

    If edge_del_cost is not specified then default edge deletion
    cost of 1 is used.  If edge_ins_cost is not specified then
    default edge insertion cost of 1 is used.

upper_bound : numeric
    Maximum edit distance to consider.

Returns
-------
Generator of consecutive approximations of graph edit distance.

Examples
--------
>>> G1 = nx.cycle_graph(6)
>>> G2 = nx.wheel_graph(7)
>>> for v in nx.optimize_graph_edit_distance(G1, G2):
...     minv = v
>>> minv
7.0

See Also
--------
graph_edit_distance, optimize_edit_paths

References
----------
.. [1] Zeina Abu-Aisheh, Romain Raveaux, Jean-Yves Ramel, Patrick
   Martineau. An Exact Graph Edit Distance Algorithm for Solving
   Pattern Recognition Problems. 4th International Conference on
   Pattern Recognition Applications and Methods 2015, Jan 2015,
   Lisbon, Portugal. 2015,
   <10.5220/0005209202710278>. <hal-01168816>
   https://hal.archives-ouvertes.fr/hal-01168816
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a3048856cdc525be8a48d87b458e16a14}\label{namespacenetworkx_1_1algorithms_1_1similarity_a3048856cdc525be8a48d87b458e16a14}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!panther\+\_\+similarity@{panther\+\_\+similarity}}
\index{panther\+\_\+similarity@{panther\+\_\+similarity}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{panther\+\_\+similarity()}{panther\_similarity()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+similarity.\+panther\+\_\+similarity (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{source,  }\item[{}]{k = {\ttfamily 5},  }\item[{}]{path\+\_\+length = {\ttfamily 5},  }\item[{}]{c = {\ttfamily 0.5},  }\item[{}]{delta = {\ttfamily 0.1},  }\item[{}]{eps = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the Panther similarity of nodes in the graph `G` to node ``v``.

Panther is a similarity metric that says "two objects are considered
to be similar if they frequently appear on the same paths." [1]_.

Parameters
----------
G : NetworkX graph
    A NetworkX graph
source : node
    Source node for which to find the top `k` similar other nodes
k : int (default = 5)
    The number of most similar nodes to return
path_length : int (default = 5)
    How long the randomly generated paths should be (``T`` in [1]_)
c : float (default = 0.5)
    A universal positive constant used to scale the number
    of sample random paths to generate.
delta : float (default = 0.1)
    The probability that the similarity $S$ is not an epsilon-approximation to (R, phi),
    where $R$ is the number of random paths and $\phi$ is the probability
    that an element sampled from a set $A \subseteq D$, where $D$ is the domain.
eps : float or None (default = None)
    The error bound. Per [1]_, a good value is ``sqrt(1/|E|)``. Therefore,
    if no value is provided, the recommended computed value will be used.

Returns
-------
similarity : dictionary
    Dictionary of nodes to similarity scores (as floats). Note:
    the self-similarity (i.e., ``v``) will not be included in
    the returned dictionary.

Examples
--------
>>> G = nx.star_graph(10)
>>> sim = nx.panther_similarity(G, 0)

References
----------
.. [1] Zhang, J., Tang, J., Ma, C., Tong, H., Jing, Y., & Li, J.
       Panther: Fast top-k similarity search on large networks.
       In Proceedings of the ACM SIGKDD International Conference
       on Knowledge Discovery and Data Mining (Vol. 2015-August, pp. 1445â€“1454).
       Association for Computing Machinery. https://doi.org/10.1145/2783258.2783267.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a3ab3e57878c9ac3f9b4bb761079276e1}\label{namespacenetworkx_1_1algorithms_1_1similarity_a3ab3e57878c9ac3f9b4bb761079276e1}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!simrank\+\_\+similarity@{simrank\+\_\+similarity}}
\index{simrank\+\_\+similarity@{simrank\+\_\+similarity}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{simrank\+\_\+similarity()}{simrank\_similarity()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+similarity.\+simrank\+\_\+similarity (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{source = {\ttfamily None},  }\item[{}]{target = {\ttfamily None},  }\item[{}]{importance\+\_\+factor = {\ttfamily 0.9},  }\item[{}]{max\+\_\+iterations = {\ttfamily 1000},  }\item[{}]{tolerance = {\ttfamily 1e-\/4} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the SimRank similarity of nodes in the graph ``G``.

SimRank is a similarity metric that says "two objects are considered
to be similar if they are referenced by similar objects." [1]_.

The pseudo-code definition from the paper is::

    def simrank(G, u, v):
        in_neighbors_u = G.predecessors(u)
        in_neighbors_v = G.predecessors(v)
        scale = C / (len(in_neighbors_u) * len(in_neighbors_v))
        return scale * sum(simrank(G, w, x)
                           for w, x in product(in_neighbors_u,
                                               in_neighbors_v))

where ``G`` is the graph, ``u`` is the source, ``v`` is the target,
and ``C`` is a float decay or importance factor between 0 and 1.

The SimRank algorithm for determining node similarity is defined in
[2]_.

Parameters
----------
G : NetworkX graph
    A NetworkX graph

source : node
    If this is specified, the returned dictionary maps each node
    ``v`` in the graph to the similarity between ``source`` and
    ``v``.

target : node
    If both ``source`` and ``target`` are specified, the similarity
    value between ``source`` and ``target`` is returned. If
    ``target`` is specified but ``source`` is not, this argument is
    ignored.

importance_factor : float
    The relative importance of indirect neighbors with respect to
    direct neighbors.

max_iterations : integer
    Maximum number of iterations.

tolerance : float
    Error tolerance used to check convergence. When an iteration of
    the algorithm finds that no similarity value changes more than
    this amount, the algorithm halts.

Returns
-------
similarity : dictionary or float
    If ``source`` and ``target`` are both ``None``, this returns a
    dictionary of dictionaries, where keys are node pairs and value
    are similarity of the pair of nodes.

    If ``source`` is not ``None`` but ``target`` is, this returns a
    dictionary mapping node to the similarity of ``source`` and that
    node.

    If neither ``source`` nor ``target`` is ``None``, this returns
    the similarity value for the given pair of nodes.

Examples
--------
>>> G = nx.cycle_graph(2)
>>> nx.simrank_similarity(G)
{0: {0: 1.0, 1: 0.0}, 1: {0: 0.0, 1: 1.0}}
>>> nx.simrank_similarity(G, source=0)
{0: 1.0, 1: 0.0}
>>> nx.simrank_similarity(G, source=0, target=0)
1.0

The result of this function can be converted to a numpy array
representing the SimRank matrix by using the node order of the
graph to determine which row and column represent each node.
Other ordering of nodes is also possible.

>>> import numpy as np
>>> sim = nx.simrank_similarity(G)
>>> np.array([[sim[u][v] for v in G] for u in G])
array([[1., 0.],
       [0., 1.]])
>>> sim_1d = nx.simrank_similarity(G, source=0)
>>> np.array([sim[0][v] for v in G])
array([1., 0.])

References
----------
.. [1] https://en.wikipedia.org/wiki/SimRank
.. [2] G. Jeh and J. Widom.
       "SimRank: a measure of structural-context similarity",
       In KDD'02: Proceedings of the Eighth ACM SIGKDD
       International Conference on Knowledge Discovery and Data Mining,
       pp. 538--543. ACM Press, 2002.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a60b65f73b755236d64f0fa6e2006f310}\label{namespacenetworkx_1_1algorithms_1_1similarity_a60b65f73b755236d64f0fa6e2006f310}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!simrank\+\_\+similarity\+\_\+numpy@{simrank\+\_\+similarity\+\_\+numpy}}
\index{simrank\+\_\+similarity\+\_\+numpy@{simrank\+\_\+similarity\+\_\+numpy}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{simrank\+\_\+similarity\+\_\+numpy()}{simrank\_similarity\_numpy()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+similarity.\+simrank\+\_\+similarity\+\_\+numpy (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{source = {\ttfamily None},  }\item[{}]{target = {\ttfamily None},  }\item[{}]{importance\+\_\+factor = {\ttfamily 0.9},  }\item[{}]{max\+\_\+iterations = {\ttfamily 100},  }\item[{}]{tolerance = {\ttfamily 1e-\/4} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Calculate SimRank of nodes in ``G`` using matrices with ``numpy``.

.. deprecated:: 2.6
    simrank_similarity_numpy is deprecated and will be removed in networkx 3.0.
    Use simrank_similarity\end{DoxyVerb}
 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_af8f89640fd73be251fc4c663d33ec18e}\label{namespacenetworkx_1_1algorithms_1_1similarity_af8f89640fd73be251fc4c663d33ec18e}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!C@{C}}
\index{C@{C}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{C}{C}}
{\footnotesize\ttfamily networkx.\+algorithms.\+similarity.\+C}

\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_ad3e4352e1974ac4cab904c376f999c6b}\label{namespacenetworkx_1_1algorithms_1_1similarity_ad3e4352e1974ac4cab904c376f999c6b}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!ls@{ls}}
\index{ls@{ls}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{ls}{ls}}
{\footnotesize\ttfamily networkx.\+algorithms.\+similarity.\+ls}

\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a4aa2ee80a261aded9e24222f90d81658}\label{namespacenetworkx_1_1algorithms_1_1similarity_a4aa2ee80a261aded9e24222f90d81658}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!lsa\+\_\+col\+\_\+ind@{lsa\+\_\+col\+\_\+ind}}
\index{lsa\+\_\+col\+\_\+ind@{lsa\+\_\+col\+\_\+ind}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{lsa\+\_\+col\+\_\+ind}{lsa\_col\_ind}}
{\footnotesize\ttfamily networkx.\+algorithms.\+similarity.\+lsa\+\_\+col\+\_\+ind}

\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a55d767953a48a5084aa61a5476467268}\label{namespacenetworkx_1_1algorithms_1_1similarity_a55d767953a48a5084aa61a5476467268}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!lsa\+\_\+row\+\_\+ind@{lsa\+\_\+row\+\_\+ind}}
\index{lsa\+\_\+row\+\_\+ind@{lsa\+\_\+row\+\_\+ind}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{lsa\+\_\+row\+\_\+ind}{lsa\_row\_ind}}
{\footnotesize\ttfamily networkx.\+algorithms.\+similarity.\+lsa\+\_\+row\+\_\+ind}

\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1similarity_a9a6b624064a8d878701909b6ae7a8d9c}\label{namespacenetworkx_1_1algorithms_1_1similarity_a9a6b624064a8d878701909b6ae7a8d9c}} 
\index{networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}!value@{value}}
\index{value@{value}!networkx\+::algorithms\+::similarity@{networkx\+::algorithms\+::similarity}}
\subsubsection{\texorpdfstring{value}{value}}
{\footnotesize\ttfamily networkx.\+algorithms.\+similarity.\+value}

