\hypertarget{namespacenumpy_1_1core_1_1__ufunc__config}{}\section{numpy.\+core.\+\_\+ufunc\+\_\+config Namespace Reference}
\label{namespacenumpy_1_1core_1_1__ufunc__config}\index{numpy.\+core.\+\_\+ufunc\+\_\+config@{numpy.\+core.\+\_\+ufunc\+\_\+config}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnumpy_1_1core_1_1__ufunc__config_1_1__unspecified}{\+\_\+unspecified}
\item 
class \hyperlink{classnumpy_1_1core_1_1__ufunc__config_1_1errstate}{errstate}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenumpy_1_1core_1_1__ufunc__config_a4918dbe1e60ec3a552e954dd018b77f1}{seterr} (all=None, divide=None, over=None, under=None, invalid=None)
\item 
def \hyperlink{namespacenumpy_1_1core_1_1__ufunc__config_afcd6f622aa3b9d333e5fd614095c9f06}{geterr} ()
\item 
def \hyperlink{namespacenumpy_1_1core_1_1__ufunc__config_ad64972c5159efdca49ba505081ecb3e0}{setbufsize} (size)
\item 
def \hyperlink{namespacenumpy_1_1core_1_1__ufunc__config_adcdf967493ff6c8180ea677ffd01342e}{getbufsize} ()
\item 
def \hyperlink{namespacenumpy_1_1core_1_1__ufunc__config_acf6a2cd80c820dd631915a45ece44095}{seterrcall} (func)
\item 
def \hyperlink{namespacenumpy_1_1core_1_1__ufunc__config_a0821cf6e03cf8c0ca7c960dd6a4a6bd8}{geterrcall} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Functions for changing global ufunc configuration

This provides helpers which wrap `umath.geterrobj` and `umath.seterrobj`
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenumpy_1_1core_1_1__ufunc__config_adcdf967493ff6c8180ea677ffd01342e}\label{namespacenumpy_1_1core_1_1__ufunc__config_adcdf967493ff6c8180ea677ffd01342e}} 
\index{numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}!getbufsize@{getbufsize}}
\index{getbufsize@{getbufsize}!numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}}
\subsubsection{\texorpdfstring{getbufsize()}{getbufsize()}}
{\footnotesize\ttfamily def numpy.\+core.\+\_\+ufunc\+\_\+config.\+getbufsize (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the size of the buffer used in ufuncs.

Returns
-------
getbufsize : int
    Size of ufunc buffer in bytes.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1__ufunc__config_afcd6f622aa3b9d333e5fd614095c9f06}\label{namespacenumpy_1_1core_1_1__ufunc__config_afcd6f622aa3b9d333e5fd614095c9f06}} 
\index{numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}!geterr@{geterr}}
\index{geterr@{geterr}!numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}}
\subsubsection{\texorpdfstring{geterr()}{geterr()}}
{\footnotesize\ttfamily def numpy.\+core.\+\_\+ufunc\+\_\+config.\+geterr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}Get the current way of handling floating-point errors.

Returns
-------
res : dict
    A dictionary with keys "divide", "over", "under", and "invalid",
    whose values are from the strings "ignore", "print", "log", "warn",
    "raise", and "call". The keys represent possible floating-point
    exceptions, and the values define how these exceptions are handled.

See Also
--------
geterrcall, seterr, seterrcall

Notes
-----
For complete documentation of the types of floating-point exceptions and
treatment options, see `seterr`.

Examples
--------
>>> np.geterr()
{'divide': 'warn', 'over': 'warn', 'under': 'ignore', 'invalid': 'warn'}
>>> np.arange(3.) / np.arange(3.)
array([nan,  1.,  1.])

>>> oldsettings = np.seterr(all='warn', over='raise')
>>> np.geterr()
{'divide': 'warn', 'over': 'raise', 'under': 'warn', 'invalid': 'warn'}
>>> np.arange(3.) / np.arange(3.)
array([nan,  1.,  1.])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1__ufunc__config_a0821cf6e03cf8c0ca7c960dd6a4a6bd8}\label{namespacenumpy_1_1core_1_1__ufunc__config_a0821cf6e03cf8c0ca7c960dd6a4a6bd8}} 
\index{numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}!geterrcall@{geterrcall}}
\index{geterrcall@{geterrcall}!numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}}
\subsubsection{\texorpdfstring{geterrcall()}{geterrcall()}}
{\footnotesize\ttfamily def numpy.\+core.\+\_\+ufunc\+\_\+config.\+geterrcall (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the current callback function used on floating-point errors.

When the error handling for a floating-point error (one of "divide",
"over", "under", or "invalid") is set to 'call' or 'log', the function
that is called or the log instance that is written to is returned by
`geterrcall`. This function or log instance has been set with
`seterrcall`.

Returns
-------
errobj : callable, log instance or None
    The current error handler. If no handler was set through `seterrcall`,
    ``None`` is returned.

See Also
--------
seterrcall, seterr, geterr

Notes
-----
For complete documentation of the types of floating-point exceptions and
treatment options, see `seterr`.

Examples
--------
>>> np.geterrcall()  # we did not yet set a handler, returns None

>>> oldsettings = np.seterr(all='call')
>>> def err_handler(type, flag):
...     print("Floating point error (%s), with flag %s" % (type, flag))
>>> oldhandler = np.seterrcall(err_handler)
>>> np.array([1, 2, 3]) / 0.0
Floating point error (divide by zero), with flag 1
array([inf, inf, inf])

>>> cur_handler = np.geterrcall()
>>> cur_handler is err_handler
True\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1__ufunc__config_ad64972c5159efdca49ba505081ecb3e0}\label{namespacenumpy_1_1core_1_1__ufunc__config_ad64972c5159efdca49ba505081ecb3e0}} 
\index{numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}!setbufsize@{setbufsize}}
\index{setbufsize@{setbufsize}!numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}}
\subsubsection{\texorpdfstring{setbufsize()}{setbufsize()}}
{\footnotesize\ttfamily def numpy.\+core.\+\_\+ufunc\+\_\+config.\+setbufsize (\begin{DoxyParamCaption}\item[{}]{size }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set the size of the buffer used in ufuncs.

Parameters
----------
size : int
    Size of buffer.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1__ufunc__config_a4918dbe1e60ec3a552e954dd018b77f1}\label{namespacenumpy_1_1core_1_1__ufunc__config_a4918dbe1e60ec3a552e954dd018b77f1}} 
\index{numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}!seterr@{seterr}}
\index{seterr@{seterr}!numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}}
\subsubsection{\texorpdfstring{seterr()}{seterr()}}
{\footnotesize\ttfamily def numpy.\+core.\+\_\+ufunc\+\_\+config.\+seterr (\begin{DoxyParamCaption}\item[{}]{all = {\ttfamily None},  }\item[{}]{divide = {\ttfamily None},  }\item[{}]{over = {\ttfamily None},  }\item[{}]{under = {\ttfamily None},  }\item[{}]{invalid = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set how floating-point errors are handled.

Note that operations on integer scalar types (such as `int16`) are
handled like floating point, and are affected by these settings.

Parameters
----------
all : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Set treatment for all types of floating-point errors at once:

    - ignore: Take no action when the exception occurs.
    - warn: Print a `RuntimeWarning` (via the Python `warnings` module).
    - raise: Raise a `FloatingPointError`.
    - call: Call a function specified using the `seterrcall` function.
    - print: Print a warning directly to ``stdout``.
    - log: Record error in a Log object specified by `seterrcall`.

    The default is not to change the current behavior.
divide : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for division by zero.
over : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for floating-point overflow.
under : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for floating-point underflow.
invalid : {'ignore', 'warn', 'raise', 'call', 'print', 'log'}, optional
    Treatment for invalid floating-point operation.

Returns
-------
old_settings : dict
    Dictionary containing the old settings.

See also
--------
seterrcall : Set a callback function for the 'call' mode.
geterr, geterrcall, errstate

Notes
-----
The floating-point exceptions are defined in the IEEE 754 standard [1]_:

- Division by zero: infinite result obtained from finite numbers.
- Overflow: result too large to be expressed.
- Underflow: result so close to zero that some precision
  was lost.
- Invalid operation: result is not an expressible number, typically
  indicates that a NaN was produced.

.. [1] https://en.wikipedia.org/wiki/IEEE_754

Examples
--------
>>> old_settings = np.seterr(all='ignore')  #seterr to known value
>>> np.seterr(over='raise')
{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}
>>> np.seterr(**old_settings)  # reset to default
{'divide': 'ignore', 'over': 'raise', 'under': 'ignore', 'invalid': 'ignore'}

>>> np.int16(32000) * np.int16(3)
30464
>>> old_settings = np.seterr(all='warn', over='raise')
>>> np.int16(32000) * np.int16(3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
FloatingPointError: overflow encountered in short_scalars

>>> old_settings = np.seterr(all='print')
>>> np.geterr()
{'divide': 'print', 'over': 'print', 'under': 'print', 'invalid': 'print'}
>>> np.int16(32000) * np.int16(3)
30464\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1core_1_1__ufunc__config_acf6a2cd80c820dd631915a45ece44095}\label{namespacenumpy_1_1core_1_1__ufunc__config_acf6a2cd80c820dd631915a45ece44095}} 
\index{numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}!seterrcall@{seterrcall}}
\index{seterrcall@{seterrcall}!numpy\+::core\+::\+\_\+ufunc\+\_\+config@{numpy\+::core\+::\+\_\+ufunc\+\_\+config}}
\subsubsection{\texorpdfstring{seterrcall()}{seterrcall()}}
{\footnotesize\ttfamily def numpy.\+core.\+\_\+ufunc\+\_\+config.\+seterrcall (\begin{DoxyParamCaption}\item[{}]{func }\end{DoxyParamCaption})}

\begin{DoxyVerb}Set the floating-point error callback function or log object.

There are two ways to capture floating-point error messages.  The first
is to set the error-handler to 'call', using `seterr`.  Then, set
the function to call using this function.

The second is to set the error-handler to 'log', using `seterr`.
Floating-point errors then trigger a call to the 'write' method of
the provided object.

Parameters
----------
func : callable f(err, flag) or object with write method
    Function to call upon floating-point errors ('call'-mode) or
    object whose 'write' method is used to log such message ('log'-mode).

    The call function takes two arguments. The first is a string describing
    the type of error (such as "divide by zero", "overflow", "underflow",
    or "invalid value"), and the second is the status flag.  The flag is a
    byte, whose four least-significant bits indicate the type of error, one
    of "divide", "over", "under", "invalid"::

      [0 0 0 0 divide over under invalid]

    In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.

    If an object is provided, its write method should take one argument,
    a string.

Returns
-------
h : callable, log instance or None
    The old error handler.

See Also
--------
seterr, geterr, geterrcall

Examples
--------
Callback upon error:

>>> def err_handler(type, flag):
...     print("Floating point error (%s), with flag %s" % (type, flag))
...

>>> saved_handler = np.seterrcall(err_handler)
>>> save_err = np.seterr(all='call')

>>> np.array([1, 2, 3]) / 0.0
Floating point error (divide by zero), with flag 1
array([inf, inf, inf])

>>> np.seterrcall(saved_handler)
<function err_handler at 0x...>
>>> np.seterr(**save_err)
{'divide': 'call', 'over': 'call', 'under': 'call', 'invalid': 'call'}

Log error message:

>>> class Log:
...     def write(self, msg):
...         print("LOG: %s" % msg)
...

>>> log = Log()
>>> saved_handler = np.seterrcall(log)
>>> save_err = np.seterr(all='log')

>>> np.array([1, 2, 3]) / 0.0
LOG: Warning: divide by zero encountered in true_divide
array([inf, inf, inf])

>>> np.seterrcall(saved_handler)
<numpy.core.numeric.Log object at 0x...>
>>> np.seterr(**save_err)
{'divide': 'log', 'over': 'log', 'under': 'log', 'invalid': 'log'}\end{DoxyVerb}
 