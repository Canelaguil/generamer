\hypertarget{namespacenetworkx_1_1generators_1_1line}{}\section{networkx.\+generators.\+line Namespace Reference}
\label{namespacenetworkx_1_1generators_1_1line}\index{networkx.\+generators.\+line@{networkx.\+generators.\+line}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1generators_1_1line_a91e386e1b725708aec705908b53d81ca}{line\+\_\+graph} (G, create\+\_\+using=None)
\item 
def \hyperlink{namespacenetworkx_1_1generators_1_1line_aa2ea922a9a8351b3868ca866bd316262}{inverse\+\_\+line\+\_\+graph} (G)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Functions for generating line graphs.\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1generators_1_1line_aa2ea922a9a8351b3868ca866bd316262}\label{namespacenetworkx_1_1generators_1_1line_aa2ea922a9a8351b3868ca866bd316262}} 
\index{networkx\+::generators\+::line@{networkx\+::generators\+::line}!inverse\+\_\+line\+\_\+graph@{inverse\+\_\+line\+\_\+graph}}
\index{inverse\+\_\+line\+\_\+graph@{inverse\+\_\+line\+\_\+graph}!networkx\+::generators\+::line@{networkx\+::generators\+::line}}
\subsubsection{\texorpdfstring{inverse\+\_\+line\+\_\+graph()}{inverse\_line\_graph()}}
{\footnotesize\ttfamily def networkx.\+generators.\+line.\+inverse\+\_\+line\+\_\+graph (\begin{DoxyParamCaption}\item[{}]{G }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the inverse line graph of graph G.

If H is a graph, and G is the line graph of H, such that G = L(H).
Then H is the inverse line graph of G.

Not all graphs are line graphs and these do not have an inverse line graph.
In these cases this function raises a NetworkXError.

Parameters
----------
G : graph
    A NetworkX Graph

Returns
-------
H : graph
    The inverse line graph of G.

Raises
------
NetworkXNotImplemented
    If G is directed or a multigraph

NetworkXError
    If G is not a line graph

Notes
-----
This is an implementation of the Roussopoulos algorithm.

If G consists of multiple components, then the algorithm doesn't work.
You should invert every component seperately:

>>> K5 = nx.complete_graph(5)
>>> P4 = nx.Graph([("a", "b"), ("b", "c"), ("c", "d")])
>>> G = nx.union(K5, P4)
>>> root_graphs = []
>>> for comp in nx.connected_components(G):
...     root_graphs.append(nx.inverse_line_graph(G.subgraph(comp)))
>>> len(root_graphs)
2

References
----------
* Roussopolous, N, "A max {m, n} algorithm for determining the graph H from
  its line graph G", Information Processing Letters 2, (1973), 108--112.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1generators_1_1line_a91e386e1b725708aec705908b53d81ca}\label{namespacenetworkx_1_1generators_1_1line_a91e386e1b725708aec705908b53d81ca}} 
\index{networkx\+::generators\+::line@{networkx\+::generators\+::line}!line\+\_\+graph@{line\+\_\+graph}}
\index{line\+\_\+graph@{line\+\_\+graph}!networkx\+::generators\+::line@{networkx\+::generators\+::line}}
\subsubsection{\texorpdfstring{line\+\_\+graph()}{line\_graph()}}
{\footnotesize\ttfamily def networkx.\+generators.\+line.\+line\+\_\+graph (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{create\+\_\+using = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the line graph of the graph or digraph `G`.

The line graph of a graph `G` has a node for each edge in `G` and an
edge joining those nodes if the two edges in `G` share a common node. For
directed graphs, nodes are adjacent exactly when the edges they represent
form a directed path of length two.

The nodes of the line graph are 2-tuples of nodes in the original graph (or
3-tuples for multigraphs, with the key of the edge as the third element).

For information about self-loops and more discussion, see the **Notes**
section below.

Parameters
----------
G : graph
    A NetworkX Graph, DiGraph, MultiGraph, or MultiDigraph.
create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Returns
-------
L : graph
    The line graph of G.

Examples
--------
>>> G = nx.star_graph(3)
>>> L = nx.line_graph(G)
>>> print(sorted(map(sorted, L.edges())))  # makes a 3-clique, K3
[[(0, 1), (0, 2)], [(0, 1), (0, 3)], [(0, 2), (0, 3)]]

Notes
-----
Graph, node, and edge data are not propagated to the new graph. For
undirected graphs, the nodes in G must be sortable, otherwise the
constructed line graph may not be correct.

*Self-loops in undirected graphs*

For an undirected graph `G` without multiple edges, each edge can be
written as a set `\{u, v\}`.  Its line graph `L` has the edges of `G` as
its nodes. If `x` and `y` are two nodes in `L`, then `\{x, y\}` is an edge
in `L` if and only if the intersection of `x` and `y` is nonempty. Thus,
the set of all edges is determined by the set of all pairwise intersections
of edges in `G`.

Trivially, every edge in G would have a nonzero intersection with itself,
and so every node in `L` should have a self-loop. This is not so
interesting, and the original context of line graphs was with simple
graphs, which had no self-loops or multiple edges. The line graph was also
meant to be a simple graph and thus, self-loops in `L` are not part of the
standard definition of a line graph. In a pairwise intersection matrix,
this is analogous to excluding the diagonal entries from the line graph
definition.

Self-loops and multiple edges in `G` add nodes to `L` in a natural way, and
do not require any fundamental changes to the definition. It might be
argued that the self-loops we excluded before should now be included.
However, the self-loops are still "trivial" in some sense and thus, are
usually excluded.

*Self-loops in directed graphs*

For a directed graph `G` without multiple edges, each edge can be written
as a tuple `(u, v)`. Its line graph `L` has the edges of `G` as its
nodes. If `x` and `y` are two nodes in `L`, then `(x, y)` is an edge in `L`
if and only if the tail of `x` matches the head of `y`, for example, if `x
= (a, b)` and `y = (b, c)` for some vertices `a`, `b`, and `c` in `G`.

Due to the directed nature of the edges, it is no longer the case that
every edge in `G` should have a self-loop in `L`. Now, the only time
self-loops arise is if a node in `G` itself has a self-loop.  So such
self-loops are no longer "trivial" but instead, represent essential
features of the topology of `G`. For this reason, the historical
development of line digraphs is such that self-loops are included. When the
graph `G` has multiple edges, once again only superficial changes are
required to the definition.

References
----------
* Harary, Frank, and Norman, Robert Z., "Some properties of line digraphs",
  Rend. Circ. Mat. Palermo, II. Ser. 9 (1960), 161--168.
* Hemminger, R. L.; Beineke, L. W. (1978), "Line graphs and line digraphs",
  in Beineke, L. W.; Wilson, R. J., Selected Topics in Graph Theory,
  Academic Press Inc., pp. 271--305.\end{DoxyVerb}
 