\hypertarget{namespacenetworkx_1_1algorithms_1_1flow_1_1utils}{}\section{networkx.\+algorithms.\+flow.\+utils Namespace Reference}
\label{namespacenetworkx_1_1algorithms_1_1flow_1_1utils}\index{networkx.\+algorithms.\+flow.\+utils@{networkx.\+algorithms.\+flow.\+utils}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnetworkx_1_1algorithms_1_1flow_1_1utils_1_1CurrentEdge}{Current\+Edge}
\item 
class \hyperlink{classnetworkx_1_1algorithms_1_1flow_1_1utils_1_1GlobalRelabelThreshold}{Global\+Relabel\+Threshold}
\item 
class \hyperlink{classnetworkx_1_1algorithms_1_1flow_1_1utils_1_1Level}{Level}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1flow_1_1utils_a515b34ec3e49e135f52a56a114eb6325}{build\+\_\+residual\+\_\+network} (G, capacity)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1flow_1_1utils_a1bb8d6c8638ad8f624b26b1bcefc42ed}{detect\+\_\+unboundedness} (R, s, t)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1flow_1_1utils_ab44f082cd2b370ad109055d451a69043}{build\+\_\+flow\+\_\+dict} (G, R)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Utility classes and functions for network flow algorithms.
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1flow_1_1utils_ab44f082cd2b370ad109055d451a69043}\label{namespacenetworkx_1_1algorithms_1_1flow_1_1utils_ab44f082cd2b370ad109055d451a69043}} 
\index{networkx\+::algorithms\+::flow\+::utils@{networkx\+::algorithms\+::flow\+::utils}!build\+\_\+flow\+\_\+dict@{build\+\_\+flow\+\_\+dict}}
\index{build\+\_\+flow\+\_\+dict@{build\+\_\+flow\+\_\+dict}!networkx\+::algorithms\+::flow\+::utils@{networkx\+::algorithms\+::flow\+::utils}}
\subsubsection{\texorpdfstring{build\+\_\+flow\+\_\+dict()}{build\_flow\_dict()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+flow.\+utils.\+build\+\_\+flow\+\_\+dict (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{R }\end{DoxyParamCaption})}

\begin{DoxyVerb}Build a flow dictionary from a residual network.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1flow_1_1utils_a515b34ec3e49e135f52a56a114eb6325}\label{namespacenetworkx_1_1algorithms_1_1flow_1_1utils_a515b34ec3e49e135f52a56a114eb6325}} 
\index{networkx\+::algorithms\+::flow\+::utils@{networkx\+::algorithms\+::flow\+::utils}!build\+\_\+residual\+\_\+network@{build\+\_\+residual\+\_\+network}}
\index{build\+\_\+residual\+\_\+network@{build\+\_\+residual\+\_\+network}!networkx\+::algorithms\+::flow\+::utils@{networkx\+::algorithms\+::flow\+::utils}}
\subsubsection{\texorpdfstring{build\+\_\+residual\+\_\+network()}{build\_residual\_network()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+flow.\+utils.\+build\+\_\+residual\+\_\+network (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{capacity }\end{DoxyParamCaption})}

\begin{DoxyVerb}Build a residual network and initialize a zero flow.

The residual network :samp:`R` from an input graph :samp:`G` has the
same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair
of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a
self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists
in :samp:`G`.

For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`
is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists
in :samp:`G` or zero otherwise. If the capacity is infinite,
:samp:`R[u][v]['capacity']` will have a high arbitrary finite value
that does not affect the solution of the problem. This value is stored in
:samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,
:samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and
satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.

The flow value, defined as the total flow into :samp:`t`, the sink, is
stored in :samp:`R.graph['flow_value']`. If :samp:`cutoff` is not
specified, reachability to :samp:`t` using only edges :samp:`(u, v)` such
that :samp:`R[u][v]['flow'] < R[u][v]['capacity']` induces a minimum
:samp:`s`-:samp:`t` cut.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1flow_1_1utils_a1bb8d6c8638ad8f624b26b1bcefc42ed}\label{namespacenetworkx_1_1algorithms_1_1flow_1_1utils_a1bb8d6c8638ad8f624b26b1bcefc42ed}} 
\index{networkx\+::algorithms\+::flow\+::utils@{networkx\+::algorithms\+::flow\+::utils}!detect\+\_\+unboundedness@{detect\+\_\+unboundedness}}
\index{detect\+\_\+unboundedness@{detect\+\_\+unboundedness}!networkx\+::algorithms\+::flow\+::utils@{networkx\+::algorithms\+::flow\+::utils}}
\subsubsection{\texorpdfstring{detect\+\_\+unboundedness()}{detect\_unboundedness()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+flow.\+utils.\+detect\+\_\+unboundedness (\begin{DoxyParamCaption}\item[{}]{R,  }\item[{}]{s,  }\item[{}]{t }\end{DoxyParamCaption})}

\begin{DoxyVerb}Detect an infinite-capacity s-t path in R.\end{DoxyVerb}
 