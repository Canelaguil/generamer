\hypertarget{namespacenumpy_1_1lib_1_1scimath}{}\section{numpy.\+lib.\+scimath Namespace Reference}
\label{namespacenumpy_1_1lib_1_1scimath}\index{numpy.\+lib.\+scimath@{numpy.\+lib.\+scimath}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1scimath_a62a6a855729e4cb6bcf2fa28b65f0b17}{sqrt} (x)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1scimath_a7219fe7d43e8f38dc344562ec9586219}{log} (x)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1scimath_a8eb4fdbb200982738232bd19e56fce16}{log10} (x)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1scimath_ada5a76e9576694ac6135decd9456937b}{logn} (\hyperlink{namespacenumpy_a352663c52853d2754274407d5cae2832}{n}, x)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1scimath_a7ad3798370da0c475531cd6fa59a64f1}{log2} (x)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1scimath_add4d264003a9655b6720b3e5aaca7caf}{power} (x, p)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1scimath_a86d091c95419b41624c14bba0f8f984a}{arccos} (x)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1scimath_a056e2ee08f73ea14121699d1d53ce962}{arcsin} (x)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1scimath_aebdc2055e5745021f61f1827e86a26ef}{arctanh} (x)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Wrapper functions to more user-friendly calling of certain math functions
whose output data-type is different than the input data-type in certain
domains of the input.

For example, for functions like `log` with branch cuts, the versions in this
module provide the mathematically valid answers in the complex plane::

  >>> import math
  >>> from numpy.lib import scimath
  >>> scimath.log(-math.exp(1)) == (1+1j*math.pi)
  True

Similarly, `sqrt`, other base logarithms, `power` and trig functions are
correctly handled.  See their respective docstrings for specific examples.

Functions
---------

.. autosummary::
   :toctree: generated/

   sqrt
   log
   log2
   logn
   log10
   power
   arccos
   arcsin
   arctanh\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a86d091c95419b41624c14bba0f8f984a}\label{namespacenumpy_1_1lib_1_1scimath_a86d091c95419b41624c14bba0f8f984a}} 
\index{numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}!arccos@{arccos}}
\index{arccos@{arccos}!numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}}
\subsubsection{\texorpdfstring{arccos()}{arccos()}}
{\footnotesize\ttfamily def numpy.\+lib.\+scimath.\+arccos (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the inverse cosine of x.

Return the "principal value" (for a description of this, see
`numpy.arccos`) of the inverse cosine of `x`. For real `x` such that
`abs(x) <= 1`, this is a real number in the closed interval
:math:`[0, \\pi]`.  Otherwise, the complex principle value is returned.

Parameters
----------
x : array_like or scalar
   The value(s) whose arccos is (are) required.

Returns
-------
out : ndarray or scalar
   The inverse cosine(s) of the `x` value(s). If `x` was a scalar, so
   is `out`, otherwise an array object is returned.

See Also
--------
numpy.arccos

Notes
-----
For an arccos() that returns ``NAN`` when real `x` is not in the
interval ``[-1,1]``, use `numpy.arccos`.

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.emath.arccos(1) # a scalar is returned
0.0

>>> np.emath.arccos([1,2])
array([0.-0.j   , 0.-1.317j])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a056e2ee08f73ea14121699d1d53ce962}\label{namespacenumpy_1_1lib_1_1scimath_a056e2ee08f73ea14121699d1d53ce962}} 
\index{numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}!arcsin@{arcsin}}
\index{arcsin@{arcsin}!numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}}
\subsubsection{\texorpdfstring{arcsin()}{arcsin()}}
{\footnotesize\ttfamily def numpy.\+lib.\+scimath.\+arcsin (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the inverse sine of x.

Return the "principal value" (for a description of this, see
`numpy.arcsin`) of the inverse sine of `x`. For real `x` such that
`abs(x) <= 1`, this is a real number in the closed interval
:math:`[-\\pi/2, \\pi/2]`.  Otherwise, the complex principle value is
returned.

Parameters
----------
x : array_like or scalar
   The value(s) whose arcsin is (are) required.

Returns
-------
out : ndarray or scalar
   The inverse sine(s) of the `x` value(s). If `x` was a scalar, so
   is `out`, otherwise an array object is returned.

See Also
--------
numpy.arcsin

Notes
-----
For an arcsin() that returns ``NAN`` when real `x` is not in the
interval ``[-1,1]``, use `numpy.arcsin`.

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.emath.arcsin(0)
0.0

>>> np.emath.arcsin([0,1])
array([0.    , 1.5708])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1scimath_aebdc2055e5745021f61f1827e86a26ef}\label{namespacenumpy_1_1lib_1_1scimath_aebdc2055e5745021f61f1827e86a26ef}} 
\index{numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}!arctanh@{arctanh}}
\index{arctanh@{arctanh}!numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}}
\subsubsection{\texorpdfstring{arctanh()}{arctanh()}}
{\footnotesize\ttfamily def numpy.\+lib.\+scimath.\+arctanh (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the inverse hyperbolic tangent of `x`.

Return the "principal value" (for a description of this, see
`numpy.arctanh`) of ``arctanh(x)``. For real `x` such that
``abs(x) < 1``, this is a real number.  If `abs(x) > 1`, or if `x` is
complex, the result is complex. Finally, `x = 1` returns``inf`` and
``x=-1`` returns ``-inf``.

Parameters
----------
x : array_like
   The value(s) whose arctanh is (are) required.

Returns
-------
out : ndarray or scalar
   The inverse hyperbolic tangent(s) of the `x` value(s). If `x` was
   a scalar so is `out`, otherwise an array is returned.


See Also
--------
numpy.arctanh

Notes
-----
For an arctanh() that returns ``NAN`` when real `x` is not in the
interval ``(-1,1)``, use `numpy.arctanh` (this latter, however, does
return +/-inf for ``x = +/-1``).

Examples
--------
>>> np.set_printoptions(precision=4)

>>> from numpy.testing import suppress_warnings
>>> with suppress_warnings() as sup:
...     sup.filter(RuntimeWarning)
...     np.emath.arctanh(np.eye(2))
array([[inf,  0.],
       [ 0., inf]])
>>> np.emath.arctanh([1j])
array([0.+0.7854j])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a7219fe7d43e8f38dc344562ec9586219}\label{namespacenumpy_1_1lib_1_1scimath_a7219fe7d43e8f38dc344562ec9586219}} 
\index{numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}!log@{log}}
\index{log@{log}!numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}}
\subsubsection{\texorpdfstring{log()}{log()}}
{\footnotesize\ttfamily def numpy.\+lib.\+scimath.\+log (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the natural logarithm of `x`.

Return the "principal value" (for a description of this, see `numpy.log`)
of :math:`log_e(x)`. For real `x > 0`, this is a real number (``log(0)``
returns ``-inf`` and ``log(np.inf)`` returns ``inf``). Otherwise, the
complex principle value is returned.

Parameters
----------
x : array_like
   The value(s) whose log is (are) required.

Returns
-------
out : ndarray or scalar
   The log of the `x` value(s). If `x` was a scalar, so is `out`,
   otherwise an array is returned.

See Also
--------
numpy.log

Notes
-----
For a log() that returns ``NAN`` when real `x < 0`, use `numpy.log`
(note, however, that otherwise `numpy.log` and this `log` are identical,
i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`, and,
notably, the complex principle value if ``x.imag != 0``).

Examples
--------
>>> np.emath.log(np.exp(1))
1.0

Negative arguments are handled "correctly" (recall that
``exp(log(x)) == x`` does *not* hold for real ``x < 0``):

>>> np.emath.log(-np.exp(1)) == (1 + np.pi * 1j)
True\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a8eb4fdbb200982738232bd19e56fce16}\label{namespacenumpy_1_1lib_1_1scimath_a8eb4fdbb200982738232bd19e56fce16}} 
\index{numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}!log10@{log10}}
\index{log10@{log10}!numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}}
\subsubsection{\texorpdfstring{log10()}{log10()}}
{\footnotesize\ttfamily def numpy.\+lib.\+scimath.\+log10 (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the logarithm base 10 of `x`.

Return the "principal value" (for a description of this, see
`numpy.log10`) of :math:`log_{10}(x)`. For real `x > 0`, this
is a real number (``log10(0)`` returns ``-inf`` and ``log10(np.inf)``
returns ``inf``). Otherwise, the complex principle value is returned.

Parameters
----------
x : array_like or scalar
   The value(s) whose log base 10 is (are) required.

Returns
-------
out : ndarray or scalar
   The log base 10 of the `x` value(s). If `x` was a scalar, so is `out`,
   otherwise an array object is returned.

See Also
--------
numpy.log10

Notes
-----
For a log10() that returns ``NAN`` when real `x < 0`, use `numpy.log10`
(note, however, that otherwise `numpy.log10` and this `log10` are
identical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,
and, notably, the complex principle value if ``x.imag != 0``).

Examples
--------

(We set the printing precision so the example can be auto-tested)

>>> np.set_printoptions(precision=4)

>>> np.emath.log10(10**1)
1.0

>>> np.emath.log10([-10**1, -10**2, 10**2])
array([1.+1.3644j, 2.+1.3644j, 2.+0.j    ])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a7ad3798370da0c475531cd6fa59a64f1}\label{namespacenumpy_1_1lib_1_1scimath_a7ad3798370da0c475531cd6fa59a64f1}} 
\index{numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}!log2@{log2}}
\index{log2@{log2}!numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}}
\subsubsection{\texorpdfstring{log2()}{log2()}}
{\footnotesize\ttfamily def numpy.\+lib.\+scimath.\+log2 (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the logarithm base 2 of `x`.

Return the "principal value" (for a description of this, see
`numpy.log2`) of :math:`log_2(x)`. For real `x > 0`, this is
a real number (``log2(0)`` returns ``-inf`` and ``log2(np.inf)`` returns
``inf``). Otherwise, the complex principle value is returned.

Parameters
----------
x : array_like
   The value(s) whose log base 2 is (are) required.

Returns
-------
out : ndarray or scalar
   The log base 2 of the `x` value(s). If `x` was a scalar, so is `out`,
   otherwise an array is returned.

See Also
--------
numpy.log2

Notes
-----
For a log2() that returns ``NAN`` when real `x < 0`, use `numpy.log2`
(note, however, that otherwise `numpy.log2` and this `log2` are
identical, i.e., both return ``-inf`` for `x = 0`, ``inf`` for `x = inf`,
and, notably, the complex principle value if ``x.imag != 0``).

Examples
--------
We set the printing precision so the example can be auto-tested:

>>> np.set_printoptions(precision=4)

>>> np.emath.log2(8)
3.0
>>> np.emath.log2([-4, -8, 8])
array([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1scimath_ada5a76e9576694ac6135decd9456937b}\label{namespacenumpy_1_1lib_1_1scimath_ada5a76e9576694ac6135decd9456937b}} 
\index{numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}!logn@{logn}}
\index{logn@{logn}!numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}}
\subsubsection{\texorpdfstring{logn()}{logn()}}
{\footnotesize\ttfamily def numpy.\+lib.\+scimath.\+logn (\begin{DoxyParamCaption}\item[{}]{n,  }\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Take log base n of x.

If `x` contains negative inputs, the answer is computed and returned in the
complex domain.

Parameters
----------
n : array_like
   The integer base(s) in which the log is taken.
x : array_like
   The value(s) whose log base `n` is (are) required.

Returns
-------
out : ndarray or scalar
   The log base `n` of the `x` value(s). If `x` was a scalar, so is
   `out`, otherwise an array is returned.

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.lib.scimath.logn(2, [4, 8])
array([2., 3.])
>>> np.lib.scimath.logn(2, [-4, -8, 8])
array([2.+4.5324j, 3.+4.5324j, 3.+0.j    ])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1scimath_add4d264003a9655b6720b3e5aaca7caf}\label{namespacenumpy_1_1lib_1_1scimath_add4d264003a9655b6720b3e5aaca7caf}} 
\index{numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}!power@{power}}
\index{power@{power}!numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}}
\subsubsection{\texorpdfstring{power()}{power()}}
{\footnotesize\ttfamily def numpy.\+lib.\+scimath.\+power (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{p }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return x to the power p, (x**p).

If `x` contains negative values, the output is converted to the
complex domain.

Parameters
----------
x : array_like
    The input value(s).
p : array_like of ints
    The power(s) to which `x` is raised. If `x` contains multiple values,
    `p` has to either be a scalar, or contain the same number of values
    as `x`. In the latter case, the result is
    ``x[0]**p[0], x[1]**p[1], ...``.

Returns
-------
out : ndarray or scalar
    The result of ``x**p``. If `x` and `p` are scalars, so is `out`,
    otherwise an array is returned.

See Also
--------
numpy.power

Examples
--------
>>> np.set_printoptions(precision=4)

>>> np.lib.scimath.power([2, 4], 2)
array([ 4, 16])
>>> np.lib.scimath.power([2, 4], -2)
array([0.25  ,  0.0625])
>>> np.lib.scimath.power([-2, 4], 2)
array([ 4.-0.j, 16.+0.j])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1scimath_a62a6a855729e4cb6bcf2fa28b65f0b17}\label{namespacenumpy_1_1lib_1_1scimath_a62a6a855729e4cb6bcf2fa28b65f0b17}} 
\index{numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}!sqrt@{sqrt}}
\index{sqrt@{sqrt}!numpy\+::lib\+::scimath@{numpy\+::lib\+::scimath}}
\subsubsection{\texorpdfstring{sqrt()}{sqrt()}}
{\footnotesize\ttfamily def numpy.\+lib.\+scimath.\+sqrt (\begin{DoxyParamCaption}\item[{}]{x }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the square root of x.

For negative input elements, a complex value is returned
(unlike `numpy.sqrt` which returns NaN).

Parameters
----------
x : array_like
   The input value(s).

Returns
-------
out : ndarray or scalar
   The square root of `x`. If `x` was a scalar, so is `out`,
   otherwise an array is returned.

See Also
--------
numpy.sqrt

Examples
--------
For real, non-negative inputs this works just like `numpy.sqrt`:

>>> np.lib.scimath.sqrt(1)
1.0
>>> np.lib.scimath.sqrt([1, 4])
array([1.,  2.])

But it automatically handles negative inputs:

>>> np.lib.scimath.sqrt(-1)
1j
>>> np.lib.scimath.sqrt([-1,4])
array([0.+1.j, 2.+0.j])\end{DoxyVerb}
 