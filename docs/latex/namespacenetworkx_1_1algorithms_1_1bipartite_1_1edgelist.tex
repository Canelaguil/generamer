\hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist}{}\section{networkx.\+algorithms.\+bipartite.\+edgelist Namespace Reference}
\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist}\index{networkx.\+algorithms.\+bipartite.\+edgelist@{networkx.\+algorithms.\+bipartite.\+edgelist}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a4a4a5c6bb34fb2d6fc90af46921b9362}{write\+\_\+edgelist} (G, path, comments=\char`\"{}\#\char`\"{}, delimiter=\char`\"{} \char`\"{}, data=True, encoding=\char`\"{}utf-\/8\char`\"{})
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a266599de891eacaa2b95b9c8af109b0a}{generate\+\_\+edgelist} (G, delimiter=\char`\"{} \char`\"{}, data=True)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_afeb373f6e6e573ef4c4e28751ed3b015}{parse\+\_\+edgelist} (lines, comments=\char`\"{}\#\char`\"{}, delimiter=None, create\+\_\+using=None, nodetype=None, data=True)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a7a2bfc7f57eb2ce55cc6fef9331c8793}{read\+\_\+edgelist} (path, comments=\char`\"{}\#\char`\"{}, delimiter=None, create\+\_\+using=None, nodetype=None, data=True, edgetype=None, encoding=\char`\"{}utf-\/8\char`\"{})
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a87863ab361ffba11ec470920ec5f2f6f}{mode}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}********************
Bipartite Edge Lists
********************
Read and write NetworkX graphs as bipartite edge lists.

Format
------
You can read or write three formats of edge lists with these functions.

Node pairs with no data::

 1 2

Python dictionary as data::

 1 2 {'weight':7, 'color':'green'}

Arbitrary data::

 1 2 7 green

For each edge (u, v) the node u is assigned to part 0 and the node v to part 1.
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a266599de891eacaa2b95b9c8af109b0a}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a266599de891eacaa2b95b9c8af109b0a}} 
\index{networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}!generate\+\_\+edgelist@{generate\+\_\+edgelist}}
\index{generate\+\_\+edgelist@{generate\+\_\+edgelist}!networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}}
\subsubsection{\texorpdfstring{generate\+\_\+edgelist()}{generate\_edgelist()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+edgelist.\+generate\+\_\+edgelist (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{delimiter = {\ttfamily \char`\"{}~\char`\"{}},  }\item[{}]{data = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate a single line of the bipartite graph G in edge list format.

Parameters
----------
G : NetworkX graph
   The graph is assumed to have node attribute `part` set to 0,1 representing
   the two graph parts

delimiter : string, optional
   Separator for node labels

data : bool or list of keys
   If False generate no edge data.  If True use a dictionary
   representation of edge data.  If a list of keys use a list of data
   values corresponding to the keys.

Returns
-------
lines : string
    Lines of data in adjlist format.

Examples
--------
>>> from networkx.algorithms import bipartite
>>> G = nx.path_graph(4)
>>> G.add_nodes_from([0, 2], bipartite=0)
>>> G.add_nodes_from([1, 3], bipartite=1)
>>> G[1][2]["weight"] = 3
>>> G[2][3]["capacity"] = 12
>>> for line in bipartite.generate_edgelist(G, data=False):
...     print(line)
0 1
2 1
2 3

>>> for line in bipartite.generate_edgelist(G):
...     print(line)
0 1 {}
2 1 {'weight': 3}
2 3 {'capacity': 12}

>>> for line in bipartite.generate_edgelist(G, data=["weight"]):
...     print(line)
0 1
2 1 3
2 3
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_afeb373f6e6e573ef4c4e28751ed3b015}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_afeb373f6e6e573ef4c4e28751ed3b015}} 
\index{networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}!parse\+\_\+edgelist@{parse\+\_\+edgelist}}
\index{parse\+\_\+edgelist@{parse\+\_\+edgelist}!networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}}
\subsubsection{\texorpdfstring{parse\+\_\+edgelist()}{parse\_edgelist()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+edgelist.\+parse\+\_\+edgelist (\begin{DoxyParamCaption}\item[{}]{lines,  }\item[{}]{comments = {\ttfamily \char`\"{}\#\char`\"{}},  }\item[{}]{delimiter = {\ttfamily None},  }\item[{}]{create\+\_\+using = {\ttfamily None},  }\item[{}]{nodetype = {\ttfamily None},  }\item[{}]{data = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Parse lines of an edge list representation of a bipartite graph.

Parameters
----------
lines : list or iterator of strings
    Input data in edgelist format
comments : string, optional
   Marker for comment lines
delimiter : string, optional
   Separator for node labels
create_using: NetworkX graph container, optional
   Use given NetworkX graph for holding nodes or edges.
nodetype : Python type, optional
   Convert nodes to this type.
data : bool or list of (label,type) tuples
   If False generate no edge data or if True use a dictionary
   representation of edge data or a list tuples specifying dictionary
   key names and types for edge data.

Returns
-------
G: NetworkX Graph
    The bipartite graph corresponding to lines

Examples
--------
Edgelist with no data:

>>> from networkx.algorithms import bipartite
>>> lines = ["1 2", "2 3", "3 4"]
>>> G = bipartite.parse_edgelist(lines, nodetype=int)
>>> sorted(G.nodes())
[1, 2, 3, 4]
>>> sorted(G.nodes(data=True))
[(1, {'bipartite': 0}), (2, {'bipartite': 0}), (3, {'bipartite': 0}), (4, {'bipartite': 1})]
>>> sorted(G.edges())
[(1, 2), (2, 3), (3, 4)]

Edgelist with data in Python dictionary representation:

>>> lines = ["1 2 {'weight':3}", "2 3 {'weight':27}", "3 4 {'weight':3.0}"]
>>> G = bipartite.parse_edgelist(lines, nodetype=int)
>>> sorted(G.nodes())
[1, 2, 3, 4]
>>> sorted(G.edges(data=True))
[(1, 2, {'weight': 3}), (2, 3, {'weight': 27}), (3, 4, {'weight': 3.0})]

Edgelist with data in a list:

>>> lines = ["1 2 3", "2 3 27", "3 4 3.0"]
>>> G = bipartite.parse_edgelist(lines, nodetype=int, data=(("weight", float),))
>>> sorted(G.nodes())
[1, 2, 3, 4]
>>> sorted(G.edges(data=True))
[(1, 2, {'weight': 3.0}), (2, 3, {'weight': 27.0}), (3, 4, {'weight': 3.0})]

See Also
--------
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a7a2bfc7f57eb2ce55cc6fef9331c8793}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a7a2bfc7f57eb2ce55cc6fef9331c8793}} 
\index{networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}!read\+\_\+edgelist@{read\+\_\+edgelist}}
\index{read\+\_\+edgelist@{read\+\_\+edgelist}!networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}}
\subsubsection{\texorpdfstring{read\+\_\+edgelist()}{read\_edgelist()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+edgelist.\+read\+\_\+edgelist (\begin{DoxyParamCaption}\item[{}]{path,  }\item[{}]{comments = {\ttfamily \char`\"{}\#\char`\"{}},  }\item[{}]{delimiter = {\ttfamily None},  }\item[{}]{create\+\_\+using = {\ttfamily None},  }\item[{}]{nodetype = {\ttfamily None},  }\item[{}]{data = {\ttfamily True},  }\item[{}]{edgetype = {\ttfamily None},  }\item[{}]{encoding = {\ttfamily \char`\"{}utf-\/8\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Read a bipartite graph from a list of edges.

Parameters
----------
path : file or string
   File or filename to read. If a file is provided, it must be
   opened in 'rb' mode.
   Filenames ending in .gz or .bz2 will be uncompressed.
comments : string, optional
   The character used to indicate the start of a comment.
delimiter : string, optional
   The string used to separate values.  The default is whitespace.
create_using : Graph container, optional,
   Use specified container to build graph.  The default is networkx.Graph,
   an undirected graph.
nodetype : int, float, str, Python type, optional
   Convert node data from strings to specified type
data : bool or list of (label,type) tuples
   Tuples specifying dictionary key names and types for edge data
edgetype : int, float, str, Python type, optional OBSOLETE
   Convert edge data from strings to specified type and use as 'weight'
encoding: string, optional
   Specify which encoding to use when reading file.

Returns
-------
G : graph
   A networkx Graph or other type specified with create_using

Examples
--------
>>> from networkx.algorithms import bipartite
>>> G = nx.path_graph(4)
>>> G.add_nodes_from([0, 2], bipartite=0)
>>> G.add_nodes_from([1, 3], bipartite=1)
>>> bipartite.write_edgelist(G, "test.edgelist")
>>> G = bipartite.read_edgelist("test.edgelist")

>>> fh = open("test.edgelist", "rb")
>>> G = bipartite.read_edgelist(fh)
>>> fh.close()

>>> G = bipartite.read_edgelist("test.edgelist", nodetype=int)

Edgelist with data in a list:

>>> textline = "1 2 3"
>>> fh = open("test.edgelist", "w")
>>> d = fh.write(textline)
>>> fh.close()
>>> G = bipartite.read_edgelist(
...     "test.edgelist", nodetype=int, data=(("weight", float),)
... )
>>> list(G)
[1, 2]
>>> list(G.edges(data=True))
[(1, 2, {'weight': 3.0})]

See parse_edgelist() for more examples of formatting.

See Also
--------
parse_edgelist

Notes
-----
Since nodes must be hashable, the function nodetype must return hashable
types (e.g. int, float, str, frozenset - or tuples of those, etc.)
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a4a4a5c6bb34fb2d6fc90af46921b9362}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a4a4a5c6bb34fb2d6fc90af46921b9362}} 
\index{networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}!write\+\_\+edgelist@{write\+\_\+edgelist}}
\index{write\+\_\+edgelist@{write\+\_\+edgelist}!networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}}
\subsubsection{\texorpdfstring{write\+\_\+edgelist()}{write\_edgelist()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+bipartite.\+edgelist.\+write\+\_\+edgelist (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{path,  }\item[{}]{comments = {\ttfamily \char`\"{}\#\char`\"{}},  }\item[{}]{delimiter = {\ttfamily \char`\"{}~\char`\"{}},  }\item[{}]{data = {\ttfamily True},  }\item[{}]{encoding = {\ttfamily \char`\"{}utf-\/8\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Write a bipartite graph as a list of edges.

Parameters
----------
G : Graph
   A NetworkX bipartite graph
path : file or string
   File or filename to write. If a file is provided, it must be
   opened in 'wb' mode. Filenames ending in .gz or .bz2 will be compressed.
comments : string, optional
   The character used to indicate the start of a comment
delimiter : string, optional
   The string used to separate values.  The default is whitespace.
data : bool or list, optional
   If False write no edge data.
   If True write a string representation of the edge data dictionary..
   If a list (or other iterable) is provided, write the  keys specified
   in the list.
encoding: string, optional
   Specify which encoding to use when writing file.

Examples
--------
>>> G = nx.path_graph(4)
>>> G.add_nodes_from([0, 2], bipartite=0)
>>> G.add_nodes_from([1, 3], bipartite=1)
>>> nx.write_edgelist(G, "test.edgelist")
>>> fh = open("test.edgelist", "wb")
>>> nx.write_edgelist(G, fh)
>>> nx.write_edgelist(G, "test.edgelist.gz")
>>> nx.write_edgelist(G, "test.edgelist.gz", data=False)

>>> G = nx.Graph()
>>> G.add_edge(1, 2, weight=7, color="red")
>>> nx.write_edgelist(G, "test.edgelist", data=False)
>>> nx.write_edgelist(G, "test.edgelist", data=["color"])
>>> nx.write_edgelist(G, "test.edgelist", data=["color", "weight"])

See Also
--------
write_edgelist
generate_edgelist
\end{DoxyVerb}
 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a87863ab361ffba11ec470920ec5f2f6f}\label{namespacenetworkx_1_1algorithms_1_1bipartite_1_1edgelist_a87863ab361ffba11ec470920ec5f2f6f}} 
\index{networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}!mode@{mode}}
\index{mode@{mode}!networkx\+::algorithms\+::bipartite\+::edgelist@{networkx\+::algorithms\+::bipartite\+::edgelist}}
\subsubsection{\texorpdfstring{mode}{mode}}
{\footnotesize\ttfamily networkx.\+algorithms.\+bipartite.\+edgelist.\+mode}

