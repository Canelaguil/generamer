\hypertarget{namespacenetworkx_1_1utils_1_1decorators}{}\section{networkx.\+utils.\+decorators Namespace Reference}
\label{namespacenetworkx_1_1utils_1_1decorators}\index{networkx.\+utils.\+decorators@{networkx.\+utils.\+decorators}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnetworkx_1_1utils_1_1decorators_1_1argmap}{argmap}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1utils_1_1decorators_a0ed95ec8bd617750c9c86fabeb605dc3}{not\+\_\+implemented\+\_\+for} (graph\+\_\+types)
\item 
def \hyperlink{namespacenetworkx_1_1utils_1_1decorators_a18d22de0af3b4116edf4d1b4c6facfed}{open\+\_\+file} (path\+\_\+arg, mode=\char`\"{}r\char`\"{})
\item 
def \hyperlink{namespacenetworkx_1_1utils_1_1decorators_a70c253fe8c06d4036b428fd9f9e176ca}{nodes\+\_\+or\+\_\+number} (which\+\_\+args)
\item 
def \hyperlink{namespacenetworkx_1_1utils_1_1decorators_abea11d7fda9dda374bd6930d5a0cb65e}{preserve\+\_\+random\+\_\+state} (func)
\item 
def \hyperlink{namespacenetworkx_1_1utils_1_1decorators_aac9c86a445c407bb96ac3a7103a62a07}{random\+\_\+state} (random\+\_\+state\+\_\+argument)
\item 
def \hyperlink{namespacenetworkx_1_1utils_1_1decorators_a5168d850b80d4a80eb9423720bf3be7d}{py\+\_\+random\+\_\+state} (random\+\_\+state\+\_\+argument)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacenetworkx_1_1utils_1_1decorators_a2878a448026ebcbeda1f29e7f3506cd5}{np\+\_\+random\+\_\+state}
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1utils_1_1decorators_a70c253fe8c06d4036b428fd9f9e176ca}\label{namespacenetworkx_1_1utils_1_1decorators_a70c253fe8c06d4036b428fd9f9e176ca}} 
\index{networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}!nodes\+\_\+or\+\_\+number@{nodes\+\_\+or\+\_\+number}}
\index{nodes\+\_\+or\+\_\+number@{nodes\+\_\+or\+\_\+number}!networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}}
\subsubsection{\texorpdfstring{nodes\+\_\+or\+\_\+number()}{nodes\_or\_number()}}
{\footnotesize\ttfamily def networkx.\+utils.\+decorators.\+nodes\+\_\+or\+\_\+number (\begin{DoxyParamCaption}\item[{}]{which\+\_\+args }\end{DoxyParamCaption})}

\begin{DoxyVerb}Decorator to allow number of nodes or container of nodes.

With this decorator, the specified argument can be either a number or a container
of nodes. If it is a number, the nodes used are `range(n)`.
This allows `nx.complete_graph(50)` in place of `nx.complete_graph(list(range(50)))`.
And it also allows `nx.complete_graph(any_list_of_nodes)`.

Parameters
----------
which_args : string or int or sequence of strings or ints
    If string, the name of the argument to be treated.
    If int, the index of the argument to be treated.
    If more than one node argument is allowed, can be a list of locations.

Returns
-------
_nodes_or_numbers : function
    Function which replaces int args with ranges.

Examples
--------
Decorate functions like this::

   @nodes_or_number("nodes")
   def empty_graph(nodes):
       # nodes is converted to a list of nodes

   @nodes_or_number(0)
   def empty_graph(nodes):
       # nodes is converted to a list of nodes

   @nodes_or_number(["m1", "m2"])
   def grid_2d_graph(m1, m2, periodic=False):
       # m1 and m2 are each converted to a list of nodes

   @nodes_or_number([0, 1])
   def grid_2d_graph(m1, m2, periodic=False):
       # m1 and m2 are each converted to a list of nodes

   @nodes_or_number(1)
   def full_rary_tree(r, n)
       # presumably r is a number. It is not handled by this decorator.
       # n is converted to a list of nodes
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1utils_1_1decorators_a0ed95ec8bd617750c9c86fabeb605dc3}\label{namespacenetworkx_1_1utils_1_1decorators_a0ed95ec8bd617750c9c86fabeb605dc3}} 
\index{networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}!not\+\_\+implemented\+\_\+for@{not\+\_\+implemented\+\_\+for}}
\index{not\+\_\+implemented\+\_\+for@{not\+\_\+implemented\+\_\+for}!networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}}
\subsubsection{\texorpdfstring{not\+\_\+implemented\+\_\+for()}{not\_implemented\_for()}}
{\footnotesize\ttfamily def networkx.\+utils.\+decorators.\+not\+\_\+implemented\+\_\+for (\begin{DoxyParamCaption}\item[{}]{graph\+\_\+types }\end{DoxyParamCaption})}

\begin{DoxyVerb}Decorator to mark algorithms as not implemented

Parameters
----------
graph_types : container of strings
    Entries must be one of "directed", "undirected", "multigraph", or "graph".

Returns
-------
_require : function
    The decorated function.

Raises
------
NetworkXNotImplemented
If any of the packages cannot be imported

Notes
-----
Multiple types are joined logically with "and".
For "or" use multiple @not_implemented_for() lines.

Examples
--------
Decorate functions like this::

   @not_implemented_for("directed")
   def sp_function(G):
       pass

   # rule out MultiDiGraph
   @not_implemented_for("directed","multigraph")
   def sp_np_function(G):
       pass

   # rule out all except DiGraph
   @not_implemented_for("undirected")
   @not_implemented_for("multigraph")
   def sp_np_function(G):
       pass
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1utils_1_1decorators_a18d22de0af3b4116edf4d1b4c6facfed}\label{namespacenetworkx_1_1utils_1_1decorators_a18d22de0af3b4116edf4d1b4c6facfed}} 
\index{networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}!open\+\_\+file@{open\+\_\+file}}
\index{open\+\_\+file@{open\+\_\+file}!networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}}
\subsubsection{\texorpdfstring{open\+\_\+file()}{open\_file()}}
{\footnotesize\ttfamily def networkx.\+utils.\+decorators.\+open\+\_\+file (\begin{DoxyParamCaption}\item[{}]{path\+\_\+arg,  }\item[{}]{mode = {\ttfamily \char`\"{}r\char`\"{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Decorator to ensure clean opening and closing of files.

Parameters
----------
path_arg : string or int
    Name or index of the argument that is a path.

mode : str
    String for opening mode.

Returns
-------
_open_file : function
    Function which cleanly executes the io.

Examples
--------
Decorate functions like this::

   @open_file(0,"r")
   def read_function(pathname):
       pass

   @open_file(1,"w")
   def write_function(G, pathname):
       pass

   @open_file(1,"w")
   def write_function(G, pathname="graph.dot")
       pass

   @open_file("pathname","w")
   def write_function(G, pathname="graph.dot")
       pass

   @open_file("path", "w+")
   def another_function(arg, **kwargs):
       path = kwargs["path"]
       pass

Notes
-----
Note that this decorator solves the problem when a path argument is
specified as a string, but it does not handle the situation when the
function wants to accept a default of None (and then handle it).

Here is an example of how to handle this case:

  @open_file("path")
  def some_function(arg1, arg2, path=None):
     if path is None:
         fobj = tempfile.NamedTemporaryFile(delete=False)
     else:
         # `path` could have been a string or file object or something
         # similar. In any event, the decorator has given us a file object
         # and it will close it for us, if it should.
         fobj = path

     try:
         fobj.write("blah")
     finally:
         if path is None:
             fobj.close()

Normally, we'd want to use "with" to ensure that fobj gets closed.
However, the decorator will make `path` a file object for us,
and using "with" would undesirably close that file object.
Instead, we use a try block, as shown above.
When we exit the function, fobj will be closed, if it should be, by the decorator.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1utils_1_1decorators_abea11d7fda9dda374bd6930d5a0cb65e}\label{namespacenetworkx_1_1utils_1_1decorators_abea11d7fda9dda374bd6930d5a0cb65e}} 
\index{networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}!preserve\+\_\+random\+\_\+state@{preserve\+\_\+random\+\_\+state}}
\index{preserve\+\_\+random\+\_\+state@{preserve\+\_\+random\+\_\+state}!networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}}
\subsubsection{\texorpdfstring{preserve\+\_\+random\+\_\+state()}{preserve\_random\_state()}}
{\footnotesize\ttfamily def networkx.\+utils.\+decorators.\+preserve\+\_\+random\+\_\+state (\begin{DoxyParamCaption}\item[{}]{func }\end{DoxyParamCaption})}

\begin{DoxyVerb}Decorator to preserve the numpy.random state during a function.

.. deprecated:: 2.6
    This is deprecated and will be removed in NetworkX v3.0.

Parameters
----------
func : function
    function around which to preserve the random state.

Returns
-------
wrapper : function
    Function which wraps the input function by saving the state before
    calling the function and restoring the function afterward.

Examples
--------
Decorate functions like this::

    @preserve_random_state
    def do_random_stuff(x, y):
        return x + y * numpy.random.random()

Notes
-----
If numpy.random is not importable, the state is not saved or restored.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1utils_1_1decorators_a5168d850b80d4a80eb9423720bf3be7d}\label{namespacenetworkx_1_1utils_1_1decorators_a5168d850b80d4a80eb9423720bf3be7d}} 
\index{networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}!py\+\_\+random\+\_\+state@{py\+\_\+random\+\_\+state}}
\index{py\+\_\+random\+\_\+state@{py\+\_\+random\+\_\+state}!networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}}
\subsubsection{\texorpdfstring{py\+\_\+random\+\_\+state()}{py\_random\_state()}}
{\footnotesize\ttfamily def networkx.\+utils.\+decorators.\+py\+\_\+random\+\_\+state (\begin{DoxyParamCaption}\item[{}]{random\+\_\+state\+\_\+argument }\end{DoxyParamCaption})}

\begin{DoxyVerb}Decorator to generate a random.Random instance (or equiv).

The decorator processes the argument indicated by `random_state_argument`
using :func:`nx.utils.create_py_random_state`.
The argument value can be a seed (integer), or a random number generator::

    If int, return a random.Random instance set with seed=int.
    If random.Random instance, return it.
    If None or the `random` package, return the global random number
    generator used by `random`.
    If np.random package, return the global numpy random number
    generator wrapped in a PythonRandomInterface class.
    If np.random.RandomState instance, return it wrapped in
    PythonRandomInterface
    If a PythonRandomInterface instance, return it

Parameters
----------
random_state_argument : string or int
    The name of the argument or the index of the argument in args that is
    to be converted to the random.Random instance or numpy.random.RandomState
    instance that mimics basic methods of random.Random.

Returns
-------
_random_state : function
    Function whose random_state_argument is converted to a Random instance.

Examples
--------
Decorate functions like this::

   @py_random_state("random_state")
   def random_float(random_state=None):
       return random_state.rand()

   @py_random_state(0)
   def random_float(rng=None):
       return rng.rand()

   @py_random_state(1)
   def random_array(dims, seed=12345):
       return seed.rand(*dims)

See Also
--------
np_random_state
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1utils_1_1decorators_aac9c86a445c407bb96ac3a7103a62a07}\label{namespacenetworkx_1_1utils_1_1decorators_aac9c86a445c407bb96ac3a7103a62a07}} 
\index{networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}!random\+\_\+state@{random\+\_\+state}}
\index{random\+\_\+state@{random\+\_\+state}!networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}}
\subsubsection{\texorpdfstring{random\+\_\+state()}{random\_state()}}
{\footnotesize\ttfamily def networkx.\+utils.\+decorators.\+random\+\_\+state (\begin{DoxyParamCaption}\item[{}]{random\+\_\+state\+\_\+argument }\end{DoxyParamCaption})}

\begin{DoxyVerb}Decorator to generate a `numpy.random.RandomState` instance.

The decorator processes the argument indicated by `random_state_argument`
using :func:`nx.utils.create_random_state`.
The argument value can be a seed (integer), or a `numpy.random.RandomState`
instance or (`None` or `numpy.random`). The latter options use the glocal
random number generator used by `numpy.random`.
The result is a `numpy.random.RandomState` instance.

Parameters
----------
random_state_argument : string or int
    The name or index of the argument to be converted
    to a `numpy.random.RandomState` instance.

Returns
-------
_random_state : function
    Function whose random_state keyword argument is a RandomState instance.

Examples
--------
Decorate functions like this::

   @np_random_state("seed")
   def random_float(seed=None):
       return seed.rand()

   @np_random_state(0)
   def random_float(rng=None):
       return rng.rand()

   @np_random_state(1)
   def random_array(dims, random_state=1):
       return random_state.rand(*dims)

See Also
--------
py_random_state
\end{DoxyVerb}
 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1utils_1_1decorators_a2878a448026ebcbeda1f29e7f3506cd5}\label{namespacenetworkx_1_1utils_1_1decorators_a2878a448026ebcbeda1f29e7f3506cd5}} 
\index{networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}!np\+\_\+random\+\_\+state@{np\+\_\+random\+\_\+state}}
\index{np\+\_\+random\+\_\+state@{np\+\_\+random\+\_\+state}!networkx\+::utils\+::decorators@{networkx\+::utils\+::decorators}}
\subsubsection{\texorpdfstring{np\+\_\+random\+\_\+state}{np\_random\_state}}
{\footnotesize\ttfamily networkx.\+utils.\+decorators.\+np\+\_\+random\+\_\+state}

