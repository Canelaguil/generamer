\hypertarget{namespacepyparsing}{}\section{pyparsing Namespace Reference}
\label{namespacepyparsing}\index{pyparsing@{pyparsing}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classpyparsing_1_1__lazyclassproperty}{\+\_\+lazyclassproperty}
\item 
class \hyperlink{classpyparsing_1_1__MultipleMatch}{\+\_\+\+Multiple\+Match}
\item 
class \hyperlink{classpyparsing_1_1__NullToken}{\+\_\+\+Null\+Token}
\item 
class \hyperlink{classpyparsing_1_1__ParseResultsWithOffset}{\+\_\+\+Parse\+Results\+With\+Offset}
\item 
class \hyperlink{classpyparsing_1_1__PendingSkip}{\+\_\+\+Pending\+Skip}
\item 
class \hyperlink{classpyparsing_1_1__PositionToken}{\+\_\+\+Position\+Token}
\item 
class \hyperlink{classpyparsing_1_1__SingleCharLiteral}{\+\_\+\+Single\+Char\+Literal}
\item 
class \hyperlink{classpyparsing_1_1__WordRegex}{\+\_\+\+Word\+Regex}
\item 
class \hyperlink{classpyparsing_1_1And}{And}
\item 
class \hyperlink{classpyparsing_1_1CaselessKeyword}{Caseless\+Keyword}
\item 
class \hyperlink{classpyparsing_1_1CaselessLiteral}{Caseless\+Literal}
\item 
class \hyperlink{classpyparsing_1_1Char}{Char}
\item 
class \hyperlink{classpyparsing_1_1CharsNotIn}{Chars\+Not\+In}
\item 
class \hyperlink{classpyparsing_1_1CloseMatch}{Close\+Match}
\item 
class \hyperlink{classpyparsing_1_1Combine}{Combine}
\item 
class \hyperlink{classpyparsing_1_1Dict}{Dict}
\item 
class \hyperlink{classpyparsing_1_1Each}{Each}
\item 
class \hyperlink{classpyparsing_1_1Empty}{Empty}
\item 
class \hyperlink{classpyparsing_1_1FollowedBy}{Followed\+By}
\item 
class \hyperlink{classpyparsing_1_1Forward}{Forward}
\item 
class \hyperlink{classpyparsing_1_1GoToColumn}{Go\+To\+Column}
\item 
class \hyperlink{classpyparsing_1_1Group}{Group}
\item 
class \hyperlink{classpyparsing_1_1Keyword}{Keyword}
\item 
class \hyperlink{classpyparsing_1_1LineEnd}{Line\+End}
\item 
class \hyperlink{classpyparsing_1_1LineStart}{Line\+Start}
\item 
class \hyperlink{classpyparsing_1_1Literal}{Literal}
\item 
class \hyperlink{classpyparsing_1_1MatchFirst}{Match\+First}
\item 
class \hyperlink{classpyparsing_1_1NoMatch}{No\+Match}
\item 
class \hyperlink{classpyparsing_1_1NotAny}{Not\+Any}
\item 
class \hyperlink{classpyparsing_1_1OneOrMore}{One\+Or\+More}
\item 
class \hyperlink{classpyparsing_1_1OnlyOnce}{Only\+Once}
\item 
class \hyperlink{classpyparsing_1_1Optional}{Optional}
\item 
class \hyperlink{classpyparsing_1_1Or}{Or}
\item 
class \hyperlink{classpyparsing_1_1ParseBaseException}{Parse\+Base\+Exception}
\item 
class \hyperlink{classpyparsing_1_1ParseElementEnhance}{Parse\+Element\+Enhance}
\item 
class \hyperlink{classpyparsing_1_1ParseException}{Parse\+Exception}
\item 
class \hyperlink{classpyparsing_1_1ParseExpression}{Parse\+Expression}
\item 
class \hyperlink{classpyparsing_1_1ParseFatalException}{Parse\+Fatal\+Exception}
\item 
class \hyperlink{classpyparsing_1_1ParserElement}{Parser\+Element}
\item 
class \hyperlink{classpyparsing_1_1ParseResults}{Parse\+Results}
\item 
class \hyperlink{classpyparsing_1_1ParseSyntaxException}{Parse\+Syntax\+Exception}
\item 
class \hyperlink{classpyparsing_1_1PrecededBy}{Preceded\+By}
\item 
class \hyperlink{classpyparsing_1_1pyparsing__common}{pyparsing\+\_\+common}
\item 
class \hyperlink{classpyparsing_1_1pyparsing__test}{pyparsing\+\_\+test}
\item 
class \hyperlink{classpyparsing_1_1pyparsing__unicode}{pyparsing\+\_\+unicode}
\item 
class \hyperlink{classpyparsing_1_1QuotedString}{Quoted\+String}
\item 
class \hyperlink{classpyparsing_1_1RecursiveGrammarException}{Recursive\+Grammar\+Exception}
\item 
class \hyperlink{classpyparsing_1_1Regex}{Regex}
\item 
class \hyperlink{classpyparsing_1_1SimpleNamespace}{Simple\+Namespace}
\item 
class \hyperlink{classpyparsing_1_1SkipTo}{Skip\+To}
\item 
class \hyperlink{classpyparsing_1_1StringEnd}{String\+End}
\item 
class \hyperlink{classpyparsing_1_1StringStart}{String\+Start}
\item 
class \hyperlink{classpyparsing_1_1Suppress}{Suppress}
\item 
class \hyperlink{classpyparsing_1_1Token}{Token}
\item 
class \hyperlink{classpyparsing_1_1TokenConverter}{Token\+Converter}
\item 
class \hyperlink{classpyparsing_1_1unicode__set}{unicode\+\_\+set}
\item 
class \hyperlink{classpyparsing_1_1White}{White}
\item 
class \hyperlink{classpyparsing_1_1Word}{Word}
\item 
class \hyperlink{classpyparsing_1_1WordEnd}{Word\+End}
\item 
class \hyperlink{classpyparsing_1_1WordStart}{Word\+Start}
\item 
class \hyperlink{classpyparsing_1_1ZeroOrMore}{Zero\+Or\+More}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacepyparsing_ade1d8de85fac4306e21a3d31cb366bf3}{condition\+As\+Parse\+Action} (fn, message=None, fatal=False)
\item 
def \hyperlink{namespacepyparsing_af3e07bff69d7504360e58f40a227ff74}{col} (loc, strg)
\item 
def \hyperlink{namespacepyparsing_ab41b88fb8292745d6460e7363ce459d8}{lineno} (loc, strg)
\item 
def \hyperlink{namespacepyparsing_a4b96d613a62571b4c813681f5d785150}{line} (loc, strg)
\item 
def \hyperlink{namespacepyparsing_a07c627d849577b15ab1b5da26df30982}{null\+Debug\+Action} (args)
\item 
def \hyperlink{namespacepyparsing_a90995c5cae27231b18d57f49d55db206}{trace\+Parse\+Action} (f)
\item 
def \hyperlink{namespacepyparsing_a8f460285aae56fa589c97cc6d906321e}{delimited\+List} (expr, delim=\char`\"{},  combine=False)
\item 
def \hyperlink{namespacepyparsing_a9db2989e6618f26af797ca93bd7b5fdd}{counted\+Array} (expr, int\+Expr=None)
\item 
def \hyperlink{namespacepyparsing_a08768339b63e29777dc0a552147ccf30}{match\+Previous\+Literal} (expr)
\item 
def \hyperlink{namespacepyparsing_a3b5fd9941a3576d6b7345bddce6dc0c3}{match\+Previous\+Expr} (expr)
\item 
def \hyperlink{namespacepyparsing_a98720c0a7307da8e72d225755faeea30}{one\+Of} (strs, caseless=False, use\+Regex=True, as\+Keyword=False)
\item 
def \hyperlink{namespacepyparsing_a1ca11345ac006d9374c42fdd3205e0e6}{dict\+Of} (key, value)
\item 
def \hyperlink{namespacepyparsing_ae35d76fb7539167de55fee44a601aabf}{original\+Text\+For} (expr, as\+String=True)
\item 
def \hyperlink{namespacepyparsing_a88118fadaa81fc84f4c5a2c3a9ca4205}{ungroup} (expr)
\item 
def \hyperlink{namespacepyparsing_a745ff2c112643ae0bb8649a56eaf51cf}{located\+Expr} (expr)
\item 
def \hyperlink{namespacepyparsing_a189051e4dd15d661d3e577ef5490d716}{srange} (s)
\item 
def \hyperlink{namespacepyparsing_a561346d6568db7e83c52dc807f8c243d}{match\+Only\+At\+Col} (n)
\item 
def \hyperlink{namespacepyparsing_a495a53dce17529eb7ae084dfe3a0acc4}{replace\+With} (repl\+Str)
\item 
def \hyperlink{namespacepyparsing_a343049ca4aeee44db41864846afb2f9b}{remove\+Quotes} (s, l, t)
\item 
def \hyperlink{namespacepyparsing_a4f2b3f96efca0c41fda874a8f9389555}{token\+Map} (func, args)
\item 
def \hyperlink{namespacepyparsing_acd02ec882992514110dd9f188328d5be}{make\+H\+T\+M\+L\+Tags} (tag\+Str)
\item 
def \hyperlink{namespacepyparsing_a15935de52b21b1c342e0ed68e7bac2d6}{make\+X\+M\+L\+Tags} (tag\+Str)
\item 
def \hyperlink{namespacepyparsing_ada8651dcae5c5d931d803b9e9a63e1e9}{with\+Attribute} (args, attr\+Dict)
\item 
def \hyperlink{namespacepyparsing_a7e7ce66cc9889c783c6d086ffd29eec9}{with\+Class} (classname, namespace=\textquotesingle{}\textquotesingle{})
\item 
def \hyperlink{namespacepyparsing_acdf84dac66cbf76ba8850d88ce9556ed}{infix\+Notation} (base\+Expr, op\+List, lpar=\hyperlink{classpyparsing_1_1Suppress}{Suppress}(\textquotesingle{}(\textquotesingle{}), rpar=\hyperlink{classpyparsing_1_1Suppress}{Suppress}(\textquotesingle{})\textquotesingle{}))
\item 
def \hyperlink{namespacepyparsing_a9c52168a8f25a43675d7ee8d271332cb}{nested\+Expr} (opener=\char`\"{}(\char`\"{}, closer=\char`\"{})\char`\"{}, content=None, ignore\+Expr=quoted\+String.\+copy())
\item 
def \hyperlink{namespacepyparsing_ab8b1b70b5d1e96e7c4ac6c23d76f8a3a}{indented\+Block} (block\+Statement\+Expr, indent\+Stack, indent=True)
\item 
def \hyperlink{namespacepyparsing_a6bdc3e8bb15795f14ddf563e1ca764b3}{replace\+H\+T\+M\+L\+Entity} (t)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacepyparsing_a36ef0f31029c711e127c908399dd04bb}{collect\+\_\+all\+\_\+\+And\+\_\+tokens}
\item 
\hyperlink{namespacepyparsing_a7d99f94ef00c20cbfc7c636536123ad3}{warn\+\_\+multiple\+\_\+tokens\+\_\+in\+\_\+named\+\_\+alternation}
\item 
\hyperlink{namespacepyparsing_a2613eebe20756859399b13cd478b2f22}{warn\+\_\+ungrouped\+\_\+named\+\_\+tokens\+\_\+in\+\_\+collection}
\item 
\hyperlink{namespacepyparsing_abd7b3ceae5de7e98982573176ca2ffa1}{warn\+\_\+name\+\_\+set\+\_\+on\+\_\+empty\+\_\+\+Forward}
\item 
\hyperlink{namespacepyparsing_a54dcb097557af387ec19dc45be5b0f28}{warn\+\_\+on\+\_\+multiple\+\_\+string\+\_\+args\+\_\+to\+\_\+oneof}
\item 
\hyperlink{namespacepyparsing_a5dd424478354cea2c2a4eec9e762fd23}{enable\+\_\+debug\+\_\+on\+\_\+named\+\_\+expressions}
\item 
\hyperlink{namespacepyparsing_a07e6a30780a15263d8cb84c17a229a69}{system\+\_\+version}
\item 
\hyperlink{namespacepyparsing_a1e1385063b54a6e3461c11bb1c85c72f}{P\+Y\+\_\+3}
\item 
\hyperlink{namespacepyparsing_a6c68e6b7f8abb69c2e4bf97f737501e4}{basestring}
\item 
\hyperlink{namespacepyparsing_a6fb3beeb55235aeb9620d7c12b47dab4}{unichr}
\item 
\hyperlink{namespacepyparsing_a26795664953d67ad5c7ed1828e11aa6b}{unicode}
\item 
\hyperlink{namespacepyparsing_a1784680ba17a7229153f90c437d5fe39}{single\+Arg\+Builtins}
\item 
\hyperlink{namespacepyparsing_a602ae0487c529c04f859bb13c0d8a50f}{range}
\item 
\hyperlink{namespacepyparsing_a7ea525fb202cede10838006336a1bce3}{alphas}
\item 
\hyperlink{namespacepyparsing_a5a54a159f2739470343562de3a9079a7}{nums}
\item 
\hyperlink{namespacepyparsing_acb57794a1fe02811f6033bb6f89f3ccb}{hexnums}
\item 
\hyperlink{namespacepyparsing_ab4563dfe6c41c6e5f5ac641f3264882a}{alphanums}
\item 
\hyperlink{namespacepyparsing_ad8c4f09cc517099e759be4c94403f9b4}{printables}
\item 
\hyperlink{namespacepyparsing_af77587cc29467c9ee7feb01c8cc71445}{empty}
\item 
\hyperlink{namespacepyparsing_a2b04510cc30ccec2e272684c835b4d0c}{line\+Start}
\item 
\hyperlink{namespacepyparsing_a042457c4400ee7d4cbc47498d08a7373}{line\+End}
\item 
\hyperlink{namespacepyparsing_a67f47d95cd52b3975fe581d9a7f8ab29}{string\+Start}
\item 
\hyperlink{namespacepyparsing_a703772e5be771c9f8d299cbffaf84a5c}{string\+End}
\item 
\hyperlink{namespacepyparsing_a832e22d9e8c149774782b6f58d10278f}{exact}
\item 
\hyperlink{namespacepyparsing_a87da767bd1f40e1004abf38d62e37162}{upcase\+Tokens}
\item 
\hyperlink{namespacepyparsing_ae22271fdc1f1b5617ad49da27880d980}{downcase\+Tokens}
\item 
\hyperlink{namespacepyparsing_a2c8744b10e3c348dea440d54cae878d5}{op\+Assoc}
\item 
\hyperlink{namespacepyparsing_a4483dde0dd5ecb74c34ae9a7af941236}{L\+E\+FT}
\item 
\hyperlink{namespacepyparsing_a76212e2a2b806de1ea2565168c9f68d8}{R\+I\+G\+HT}
\item 
\hyperlink{namespacepyparsing_a87d6136009560b41a09d42269b7982d8}{operator\+Precedence}
\item 
\hyperlink{namespacepyparsing_ab8f938666ea40119a8419a8cabca3eee}{dbl\+Quoted\+String}
\item 
\hyperlink{namespacepyparsing_a1c5f0ce91e25d989ae22e23242e98f3a}{sgl\+Quoted\+String}
\item 
\hyperlink{namespacepyparsing_ae8adf871b3e4f03a1f441f0616841ef2}{quoted\+String}
\item 
\hyperlink{namespacepyparsing_a63ab3f5b3ec40c82f883f2b187a4059a}{unicode\+String}
\item 
\hyperlink{namespacepyparsing_af6acfb83e599b4f2faf002a272701618}{alphas8bit}
\item 
\hyperlink{namespacepyparsing_aa6f0bafa554b716a30eacdc87bc2b127}{punc8bit}
\item 
\hyperlink{namespacepyparsing_a4aae3dfc90ea1f18670821f07458e9cb}{any\+Open\+Tag}
\item 
\hyperlink{namespacepyparsing_a4d942e48b9a8f74387a2fc26b3f7ad9a}{any\+Close\+Tag}
\item 
\hyperlink{namespacepyparsing_a6d28fa11d5129a845c510f8b1c95d5db}{common\+H\+T\+M\+L\+Entity}
\item 
\hyperlink{namespacepyparsing_a6e3b9caf64e1ab2062eb456c83fd60bb}{c\+Style\+Comment}
\item 
\hyperlink{namespacepyparsing_a31d6b3c2621c7ee5fce8a4f4ff920826}{html\+Comment}
\item 
\hyperlink{namespacepyparsing_a1629e0f70e54804d41c13c042c99d7c9}{rest\+Of\+Line}
\item 
\hyperlink{namespacepyparsing_a78f004a9a6f08bdd699b70210724a9b2}{dbl\+Slash\+Comment}
\item 
\hyperlink{namespacepyparsing_ad628fe6a4713164892174183fdf408c4}{cpp\+Style\+Comment}
\item 
\hyperlink{namespacepyparsing_aaf99577452dceda33ce9a94cac87bdc7}{java\+Style\+Comment}
\item 
\hyperlink{namespacepyparsing_abf3cd0b4b911951b53e88978b03b2d7e}{python\+Style\+Comment}
\item 
\hyperlink{namespacepyparsing_a74a0d58c5c3028ec3baa9b4db4a9a9f0}{exclude\+Chars}
\item 
\hyperlink{namespacepyparsing_ab20829dba0badd12b633306b6e947568}{comma\+Separated\+List}
\item 
\hyperlink{namespacepyparsing_af718ddc22535044334309aa6db3c8bb9}{default}
\item 
\hyperlink{namespacepyparsing_a40b34d438ee87b3e8ae2e84f371f0e4d}{select\+Token}
\item 
\hyperlink{namespacepyparsing_ab4ff54360a77decc8f7a39f8a09e781b}{from\+Token}
\item 
\hyperlink{namespacepyparsing_ac1f47b83b95624ba10c0fe5884afa784}{ident}
\item 
\hyperlink{namespacepyparsing_a39b7738fa924d5b7f5e7d618b7977288}{column\+Name}
\item 
\hyperlink{namespacepyparsing_a0126ec62225fec124646aff2b8e03a09}{combine}
\item 
\hyperlink{namespacepyparsing_a62e51d98617e05187ba5fd6cf5921d7b}{column\+Name\+List}
\item 
\hyperlink{namespacepyparsing_af132d884d4b4dff49793ed88314e000a}{column\+Spec}
\item 
\hyperlink{namespacepyparsing_a99b6235d1239f50a062716d8e1df305a}{table\+Name}
\item 
\hyperlink{namespacepyparsing_a7fa9d94a72a7f9f75d582cce8539e11c}{table\+Name\+List}
\item 
\hyperlink{namespacepyparsing_a6247ca830771f5336f5595ce38aae4e5}{simple\+S\+QL}
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacepyparsing_af3e07bff69d7504360e58f40a227ff74}\label{namespacepyparsing_af3e07bff69d7504360e58f40a227ff74}} 
\index{pyparsing@{pyparsing}!col@{col}}
\index{col@{col}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{col()}{col()}}
{\footnotesize\ttfamily def pyparsing.\+col (\begin{DoxyParamCaption}\item[{}]{loc,  }\item[{}]{strg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns current column within a string, counting newlines as line separators.
   The first column is number 1.

   Note: the default parsing behavior is to expand tabs in the input string
   before starting the parsing process.  See
   :class:`ParserElement.parseString` for more
   information on parsing strings containing ``<TAB>`` s, and suggested
   methods to maintain a consistent view of the parsed string, the parse
   location, and line and column positions within the parsed string.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_ade1d8de85fac4306e21a3d31cb366bf3}\label{namespacepyparsing_ade1d8de85fac4306e21a3d31cb366bf3}} 
\index{pyparsing@{pyparsing}!condition\+As\+Parse\+Action@{condition\+As\+Parse\+Action}}
\index{condition\+As\+Parse\+Action@{condition\+As\+Parse\+Action}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{condition\+As\+Parse\+Action()}{conditionAsParseAction()}}
{\footnotesize\ttfamily def pyparsing.\+condition\+As\+Parse\+Action (\begin{DoxyParamCaption}\item[{}]{fn,  }\item[{}]{message = {\ttfamily None},  }\item[{}]{fatal = {\ttfamily False} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacepyparsing_a9db2989e6618f26af797ca93bd7b5fdd}\label{namespacepyparsing_a9db2989e6618f26af797ca93bd7b5fdd}} 
\index{pyparsing@{pyparsing}!counted\+Array@{counted\+Array}}
\index{counted\+Array@{counted\+Array}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{counted\+Array()}{countedArray()}}
{\footnotesize\ttfamily def pyparsing.\+counted\+Array (\begin{DoxyParamCaption}\item[{}]{expr,  }\item[{}]{int\+Expr = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to define a counted list of expressions.

This helper defines a pattern of the form::

    integer expr expr expr...

where the leading integer tells how many expr expressions follow.
The matched tokens returns the array of expr tokens as a list - the
leading count token is suppressed.

If ``intExpr`` is specified, it should be a pyparsing expression
that produces an integer value.

Example::

    countedArray(Word(alphas)).parseString('2 ab cd ef')  # -> ['ab', 'cd']

    # in this parser, the leading integer value is given in binary,
    # '10' indicating that 2 values are in the array
    binaryConstant = Word('01').setParseAction(lambda t: int(t[0], 2))
    countedArray(Word(alphas), intExpr=binaryConstant).parseString('10 ab cd ef')  # -> ['ab', 'cd']
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a8f460285aae56fa589c97cc6d906321e}\label{namespacepyparsing_a8f460285aae56fa589c97cc6d906321e}} 
\index{pyparsing@{pyparsing}!delimited\+List@{delimited\+List}}
\index{delimited\+List@{delimited\+List}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{delimited\+List()}{delimitedList()}}
{\footnotesize\ttfamily def pyparsing.\+delimited\+List (\begin{DoxyParamCaption}\item[{}]{expr,  }\item[{}]{delim = {\ttfamily \char`\"{}},  }\item[{}]{combine = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to define a delimited list of expressions - the delimiter
defaults to ','. By default, the list elements and delimiters can
have intervening whitespace, and comments, but this can be
overridden by passing ``combine=True`` in the constructor. If
``combine`` is set to ``True``, the matching tokens are
returned as a single token string, with the delimiters included;
otherwise, the matching tokens are returned as a list of tokens,
with the delimiters suppressed.

Example::

    delimitedList(Word(alphas)).parseString("aa,bb,cc") # -> ['aa', 'bb', 'cc']
    delimitedList(Word(hexnums), delim=':', combine=True).parseString("AA:BB:CC:DD:EE") # -> ['AA:BB:CC:DD:EE']
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a1ca11345ac006d9374c42fdd3205e0e6}\label{namespacepyparsing_a1ca11345ac006d9374c42fdd3205e0e6}} 
\index{pyparsing@{pyparsing}!dict\+Of@{dict\+Of}}
\index{dict\+Of@{dict\+Of}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{dict\+Of()}{dictOf()}}
{\footnotesize\ttfamily def pyparsing.\+dict\+Of (\begin{DoxyParamCaption}\item[{}]{key,  }\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to easily and clearly define a dictionary by specifying
the respective patterns for the key and value.  Takes care of
defining the :class:`Dict`, :class:`ZeroOrMore`, and
:class:`Group` tokens in the proper order.  The key pattern
can include delimiting markers or punctuation, as long as they are
suppressed, thereby leaving the significant key text.  The value
pattern can include named results, so that the :class:`Dict` results
can include named token fields.

Example::

    text = "shape: SQUARE posn: upper left color: light blue texture: burlap"
    attr_expr = (label + Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join))
    print(OneOrMore(attr_expr).parseString(text).dump())

    attr_label = label
    attr_value = Suppress(':') + OneOrMore(data_word, stopOn=label).setParseAction(' '.join)

    # similar to Dict, but simpler call format
    result = dictOf(attr_label, attr_value).parseString(text)
    print(result.dump())
    print(result['shape'])
    print(result.shape)  # object attribute access works too
    print(result.asDict())

prints::

    [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]
    - color: light blue
    - posn: upper left
    - shape: SQUARE
    - texture: burlap
    SQUARE
    SQUARE
    {'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'}
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_ab8b1b70b5d1e96e7c4ac6c23d76f8a3a}\label{namespacepyparsing_ab8b1b70b5d1e96e7c4ac6c23d76f8a3a}} 
\index{pyparsing@{pyparsing}!indented\+Block@{indented\+Block}}
\index{indented\+Block@{indented\+Block}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{indented\+Block()}{indentedBlock()}}
{\footnotesize\ttfamily def pyparsing.\+indented\+Block (\begin{DoxyParamCaption}\item[{}]{block\+Statement\+Expr,  }\item[{}]{indent\+Stack,  }\item[{}]{indent = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper method for defining space-delimited indentation blocks,
such as those used to define block statements in Python source code.

Parameters:

 - blockStatementExpr - expression defining syntax of statement that
   is repeated within the indented block
 - indentStack - list created by caller to manage indentation stack
   (multiple statementWithIndentedBlock expressions within a single
   grammar should share a common indentStack)
 - indent - boolean indicating whether block must be indented beyond
   the current level; set to False for block of left-most
   statements (default= ``True``)

A valid block must contain at least one ``blockStatement``.

Example::

    data = '''
    def A(z):
      A1
      B = 100
      G = A2
      A2
      A3
    B
    def BB(a,b,c):
      BB1
      def BBA():
        bba1
        bba2
        bba3
    C
    D
    def spam(x,y):
         def eggs(z):
             pass
    '''


    indentStack = [1]
    stmt = Forward()

    identifier = Word(alphas, alphanums)
    funcDecl = ("def" + identifier + Group("(" + Optional(delimitedList(identifier)) + ")") + ":")
    func_body = indentedBlock(stmt, indentStack)
    funcDef = Group(funcDecl + func_body)

    rvalue = Forward()
    funcCall = Group(identifier + "(" + Optional(delimitedList(rvalue)) + ")")
    rvalue << (funcCall | identifier | Word(nums))
    assignment = Group(identifier + "=" + rvalue)
    stmt << (funcDef | assignment | identifier)

    module_body = OneOrMore(stmt)

    parseTree = module_body.parseString(data)
    parseTree.pprint()

prints::

    [['def',
      'A',
      ['(', 'z', ')'],
      ':',
      [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]],
     'B',
     ['def',
      'BB',
      ['(', 'a', 'b', 'c', ')'],
      ':',
      [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]],
     'C',
     'D',
     ['def',
      'spam',
      ['(', 'x', 'y', ')'],
      ':',
      [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]]
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_acdf84dac66cbf76ba8850d88ce9556ed}\label{namespacepyparsing_acdf84dac66cbf76ba8850d88ce9556ed}} 
\index{pyparsing@{pyparsing}!infix\+Notation@{infix\+Notation}}
\index{infix\+Notation@{infix\+Notation}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{infix\+Notation()}{infixNotation()}}
{\footnotesize\ttfamily def pyparsing.\+infix\+Notation (\begin{DoxyParamCaption}\item[{}]{base\+Expr,  }\item[{}]{op\+List,  }\item[{}]{lpar = {\ttfamily \hyperlink{classpyparsing_1_1Suppress}{Suppress}(\textquotesingle{}(\textquotesingle{}),~rpar=\hyperlink{classpyparsing_1_1Suppress}{Suppress}(\textquotesingle{})\textquotesingle{})} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper method for constructing grammars of expressions made up of
operators working in a precedence hierarchy.  Operators may be unary
or binary, left- or right-associative.  Parse actions can also be
attached to operator expressions. The generated parser will also
recognize the use of parentheses to override operator precedences
(see example below).

Note: if you define a deep operator list, you may see performance
issues when using infixNotation. See
:class:`ParserElement.enablePackrat` for a mechanism to potentially
improve your parser performance.

Parameters:
 - baseExpr - expression representing the most basic element for the
   nested
 - opList - list of tuples, one for each operator precedence level
   in the expression grammar; each tuple is of the form ``(opExpr,
   numTerms, rightLeftAssoc, parseAction)``, where:

   - opExpr is the pyparsing expression for the operator; may also
     be a string, which will be converted to a Literal; if numTerms
     is 3, opExpr is a tuple of two expressions, for the two
     operators separating the 3 terms
   - numTerms is the number of terms for this operator (must be 1,
     2, or 3)
   - rightLeftAssoc is the indicator whether the operator is right
     or left associative, using the pyparsing-defined constants
     ``opAssoc.RIGHT`` and ``opAssoc.LEFT``.
   - parseAction is the parse action to be associated with
     expressions matching this operator expression (the parse action
     tuple member may be omitted); if the parse action is passed
     a tuple or list of functions, this is equivalent to calling
     ``setParseAction(*fn)``
     (:class:`ParserElement.setParseAction`)
 - lpar - expression for matching left-parentheses
   (default= ``Suppress('(')``)
 - rpar - expression for matching right-parentheses
   (default= ``Suppress(')')``)

Example::

    # simple example of four-function arithmetic with ints and
    # variable names
    integer = pyparsing_common.signed_integer
    varname = pyparsing_common.identifier

    arith_expr = infixNotation(integer | varname,
        [
        ('-', 1, opAssoc.RIGHT),
        (oneOf('* /'), 2, opAssoc.LEFT),
        (oneOf('+ -'), 2, opAssoc.LEFT),
        ])

    arith_expr.runTests('''
        5+3*6
        (5+3)*6
        -2--11
        ''', fullDump=False)

prints::

    5+3*6
    [[5, '+', [3, '*', 6]]]

    (5+3)*6
    [[[5, '+', 3], '*', 6]]

    -2--11
    [[['-', 2], '-', ['-', 11]]]
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a4b96d613a62571b4c813681f5d785150}\label{namespacepyparsing_a4b96d613a62571b4c813681f5d785150}} 
\index{pyparsing@{pyparsing}!line@{line}}
\index{line@{line}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{line()}{line()}}
{\footnotesize\ttfamily def pyparsing.\+line (\begin{DoxyParamCaption}\item[{}]{loc,  }\item[{}]{strg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the line of text containing loc within a string, counting newlines as line separators.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_ab41b88fb8292745d6460e7363ce459d8}\label{namespacepyparsing_ab41b88fb8292745d6460e7363ce459d8}} 
\index{pyparsing@{pyparsing}!lineno@{lineno}}
\index{lineno@{lineno}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{lineno()}{lineno()}}
{\footnotesize\ttfamily def pyparsing.\+lineno (\begin{DoxyParamCaption}\item[{}]{loc,  }\item[{}]{strg }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns current line number within a string, counting newlines as line separators.
The first line is number 1.

Note - the default parsing behavior is to expand tabs in the input string
before starting the parsing process.  See :class:`ParserElement.parseString`
for more information on parsing strings containing ``<TAB>`` s, and
suggested methods to maintain a consistent view of the parsed string, the
parse location, and line and column positions within the parsed string.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a745ff2c112643ae0bb8649a56eaf51cf}\label{namespacepyparsing_a745ff2c112643ae0bb8649a56eaf51cf}} 
\index{pyparsing@{pyparsing}!located\+Expr@{located\+Expr}}
\index{located\+Expr@{located\+Expr}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{located\+Expr()}{locatedExpr()}}
{\footnotesize\ttfamily def pyparsing.\+located\+Expr (\begin{DoxyParamCaption}\item[{}]{expr }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to decorate a returned token with its starting and ending
locations in the input string.

This helper adds the following results names:

 - locn_start = location where matched expression begins
 - locn_end = location where matched expression ends
 - value = the actual parsed results

Be careful if the input text contains ``<TAB>`` characters, you
may want to call :class:`ParserElement.parseWithTabs`

Example::

    wd = Word(alphas)
    for match in locatedExpr(wd).searchString("ljsdf123lksdjjf123lkkjj1222"):
        print(match)

prints::

    [[0, 'ljsdf', 5]]
    [[8, 'lksdjjf', 15]]
    [[18, 'lkkjj', 23]]
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_acd02ec882992514110dd9f188328d5be}\label{namespacepyparsing_acd02ec882992514110dd9f188328d5be}} 
\index{pyparsing@{pyparsing}!make\+H\+T\+M\+L\+Tags@{make\+H\+T\+M\+L\+Tags}}
\index{make\+H\+T\+M\+L\+Tags@{make\+H\+T\+M\+L\+Tags}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{make\+H\+T\+M\+L\+Tags()}{makeHTMLTags()}}
{\footnotesize\ttfamily def pyparsing.\+make\+H\+T\+M\+L\+Tags (\begin{DoxyParamCaption}\item[{}]{tag\+Str }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to construct opening and closing tag expressions for HTML,
given a tag name. Matches tags in either upper or lower case,
attributes with namespaces and with quoted or unquoted values.

Example::

    text = '<td>More info at the <a href="https://github.com/pyparsing/pyparsing/wiki">pyparsing</a> wiki page</td>'
    # makeHTMLTags returns pyparsing expressions for the opening and
    # closing tags as a 2-tuple
    a, a_end = makeHTMLTags("A")
    link_expr = a + SkipTo(a_end)("link_text") + a_end

    for link in link_expr.searchString(text):
        # attributes in the <A> tag (like "href" shown here) are
        # also accessible as named results
        print(link.link_text, '->', link.href)

prints::

    pyparsing -> https://github.com/pyparsing/pyparsing/wiki
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a15935de52b21b1c342e0ed68e7bac2d6}\label{namespacepyparsing_a15935de52b21b1c342e0ed68e7bac2d6}} 
\index{pyparsing@{pyparsing}!make\+X\+M\+L\+Tags@{make\+X\+M\+L\+Tags}}
\index{make\+X\+M\+L\+Tags@{make\+X\+M\+L\+Tags}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{make\+X\+M\+L\+Tags()}{makeXMLTags()}}
{\footnotesize\ttfamily def pyparsing.\+make\+X\+M\+L\+Tags (\begin{DoxyParamCaption}\item[{}]{tag\+Str }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to construct opening and closing tag expressions for XML,
given a tag name. Matches tags only in the given upper/lower case.

Example: similar to :class:`makeHTMLTags`
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a561346d6568db7e83c52dc807f8c243d}\label{namespacepyparsing_a561346d6568db7e83c52dc807f8c243d}} 
\index{pyparsing@{pyparsing}!match\+Only\+At\+Col@{match\+Only\+At\+Col}}
\index{match\+Only\+At\+Col@{match\+Only\+At\+Col}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{match\+Only\+At\+Col()}{matchOnlyAtCol()}}
{\footnotesize\ttfamily def pyparsing.\+match\+Only\+At\+Col (\begin{DoxyParamCaption}\item[{}]{n }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper method for defining parse actions that require matching at
a specific column in the input text.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a3b5fd9941a3576d6b7345bddce6dc0c3}\label{namespacepyparsing_a3b5fd9941a3576d6b7345bddce6dc0c3}} 
\index{pyparsing@{pyparsing}!match\+Previous\+Expr@{match\+Previous\+Expr}}
\index{match\+Previous\+Expr@{match\+Previous\+Expr}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{match\+Previous\+Expr()}{matchPreviousExpr()}}
{\footnotesize\ttfamily def pyparsing.\+match\+Previous\+Expr (\begin{DoxyParamCaption}\item[{}]{expr }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to define an expression that is indirectly defined from
the tokens matched in a previous expression, that is, it looks for
a 'repeat' of a previous expression.  For example::

    first = Word(nums)
    second = matchPreviousExpr(first)
    matchExpr = first + ":" + second

will match ``"1:1"``, but not ``"1:2"``.  Because this
matches by expressions, will *not* match the leading ``"1:1"``
in ``"1:10"``; the expressions are evaluated first, and then
compared, so ``"1"`` is compared with ``"10"``. Do *not* use
with packrat parsing enabled.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a08768339b63e29777dc0a552147ccf30}\label{namespacepyparsing_a08768339b63e29777dc0a552147ccf30}} 
\index{pyparsing@{pyparsing}!match\+Previous\+Literal@{match\+Previous\+Literal}}
\index{match\+Previous\+Literal@{match\+Previous\+Literal}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{match\+Previous\+Literal()}{matchPreviousLiteral()}}
{\footnotesize\ttfamily def pyparsing.\+match\+Previous\+Literal (\begin{DoxyParamCaption}\item[{}]{expr }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to define an expression that is indirectly defined from
the tokens matched in a previous expression, that is, it looks for
a 'repeat' of a previous expression.  For example::

    first = Word(nums)
    second = matchPreviousLiteral(first)
    matchExpr = first + ":" + second

will match ``"1:1"``, but not ``"1:2"``.  Because this
matches a previous literal, will also match the leading
``"1:1"`` in ``"1:10"``. If this is not desired, use
:class:`matchPreviousExpr`. Do *not* use with packrat parsing
enabled.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a9c52168a8f25a43675d7ee8d271332cb}\label{namespacepyparsing_a9c52168a8f25a43675d7ee8d271332cb}} 
\index{pyparsing@{pyparsing}!nested\+Expr@{nested\+Expr}}
\index{nested\+Expr@{nested\+Expr}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{nested\+Expr()}{nestedExpr()}}
{\footnotesize\ttfamily def pyparsing.\+nested\+Expr (\begin{DoxyParamCaption}\item[{}]{opener = {\ttfamily \char`\"{}(\char`\"{},~closer=\char`\"{})\char`\"{}},  }\item[{}]{content = {\ttfamily None},  }\item[{}]{ignore\+Expr = {\ttfamily quotedString.copy()} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper method for defining nested lists enclosed in opening and
closing delimiters ("(" and ")" are the default).

Parameters:
 - opener - opening character for a nested list
   (default= ``"("``); can also be a pyparsing expression
 - closer - closing character for a nested list
   (default= ``")"``); can also be a pyparsing expression
 - content - expression for items within the nested lists
   (default= ``None``)
 - ignoreExpr - expression for ignoring opening and closing
   delimiters (default= :class:`quotedString`)

If an expression is not provided for the content argument, the
nested expression will capture all whitespace-delimited content
between delimiters as a list of separate values.

Use the ``ignoreExpr`` argument to define expressions that may
contain opening or closing characters that should not be treated as
opening or closing characters for nesting, such as quotedString or
a comment expression.  Specify multiple expressions using an
:class:`Or` or :class:`MatchFirst`. The default is
:class:`quotedString`, but if no expressions are to be ignored, then
pass ``None`` for this argument.

Example::

    data_type = oneOf("void int short long char float double")
    decl_data_type = Combine(data_type + Optional(Word('*')))
    ident = Word(alphas+'_', alphanums+'_')
    number = pyparsing_common.number
    arg = Group(decl_data_type + ident)
    LPAR, RPAR = map(Suppress, "()")

    code_body = nestedExpr('{', '}', ignoreExpr=(quotedString | cStyleComment))

    c_function = (decl_data_type("type")
                  + ident("name")
                  + LPAR + Optional(delimitedList(arg), [])("args") + RPAR
                  + code_body("body"))
    c_function.ignore(cStyleComment)

    source_code = '''
        int is_odd(int x) {
            return (x%2);
        }

        int dec_to_hex(char hchar) {
            if (hchar >= '0' && hchar <= '9') {
                return (ord(hchar)-ord('0'));
            } else {
                return (10+ord(hchar)-ord('A'));
            }
        }
    '''
    for func in c_function.searchString(source_code):
        print("%(name)s (%(type)s) args: %(args)s" % func)


prints::

    is_odd (int) args: [['int', 'x']]
    dec_to_hex (int) args: [['char', 'hchar']]
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a07c627d849577b15ab1b5da26df30982}\label{namespacepyparsing_a07c627d849577b15ab1b5da26df30982}} 
\index{pyparsing@{pyparsing}!null\+Debug\+Action@{null\+Debug\+Action}}
\index{null\+Debug\+Action@{null\+Debug\+Action}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{null\+Debug\+Action()}{nullDebugAction()}}
{\footnotesize\ttfamily def pyparsing.\+null\+Debug\+Action (\begin{DoxyParamCaption}\item[{}]{args }\end{DoxyParamCaption})}

\begin{DoxyVerb}'Do-nothing' debug action, to suppress debugging output during parsing.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a98720c0a7307da8e72d225755faeea30}\label{namespacepyparsing_a98720c0a7307da8e72d225755faeea30}} 
\index{pyparsing@{pyparsing}!one\+Of@{one\+Of}}
\index{one\+Of@{one\+Of}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{one\+Of()}{oneOf()}}
{\footnotesize\ttfamily def pyparsing.\+one\+Of (\begin{DoxyParamCaption}\item[{}]{strs,  }\item[{}]{caseless = {\ttfamily False},  }\item[{}]{use\+Regex = {\ttfamily True},  }\item[{}]{as\+Keyword = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to quickly define a set of alternative Literals, and makes
sure to do longest-first testing when there is a conflict,
regardless of the input order, but returns
a :class:`MatchFirst` for best performance.

Parameters:

 - strs - a string of space-delimited literals, or a collection of
   string literals
 - caseless - (default= ``False``) - treat all literals as
   caseless
 - useRegex - (default= ``True``) - as an optimization, will
   generate a Regex object; otherwise, will generate
   a :class:`MatchFirst` object (if ``caseless=True`` or ``asKeyword=True``, or if
   creating a :class:`Regex` raises an exception)
 - asKeyword - (default=``False``) - enforce Keyword-style matching on the
   generated expressions

Example::

    comp_oper = oneOf("< = > <= >= !=")
    var = Word(alphas)
    number = Word(nums)
    term = var | number
    comparison_expr = term + comp_oper + term
    print(comparison_expr.searchString("B = 12  AA=23 B<=AA AA>12"))

prints::

    [['B', '=', '12'], ['AA', '=', '23'], ['B', '<=', 'AA'], ['AA', '>', '12']]
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_ae35d76fb7539167de55fee44a601aabf}\label{namespacepyparsing_ae35d76fb7539167de55fee44a601aabf}} 
\index{pyparsing@{pyparsing}!original\+Text\+For@{original\+Text\+For}}
\index{original\+Text\+For@{original\+Text\+For}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{original\+Text\+For()}{originalTextFor()}}
{\footnotesize\ttfamily def pyparsing.\+original\+Text\+For (\begin{DoxyParamCaption}\item[{}]{expr,  }\item[{}]{as\+String = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to return the original, untokenized text for a given
expression.  Useful to restore the parsed fields of an HTML start
tag into the raw tag text itself, or to revert separate tokens with
intervening whitespace back to the original matching input text. By
default, returns astring containing the original parsed text.

If the optional ``asString`` argument is passed as
``False``, then the return value is
a :class:`ParseResults` containing any results names that
were originally matched, and a single token containing the original
matched text from the input string.  So if the expression passed to
:class:`originalTextFor` contains expressions with defined
results names, you must set ``asString`` to ``False`` if you
want to preserve those results name values.

Example::

    src = "this is test <b> bold <i>text</i> </b> normal text "
    for tag in ("b", "i"):
        opener, closer = makeHTMLTags(tag)
        patt = originalTextFor(opener + SkipTo(closer) + closer)
        print(patt.searchString(src)[0])

prints::

    ['<b> bold <i>text</i> </b>']
    ['<i>text</i>']
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a343049ca4aeee44db41864846afb2f9b}\label{namespacepyparsing_a343049ca4aeee44db41864846afb2f9b}} 
\index{pyparsing@{pyparsing}!remove\+Quotes@{remove\+Quotes}}
\index{remove\+Quotes@{remove\+Quotes}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{remove\+Quotes()}{removeQuotes()}}
{\footnotesize\ttfamily def pyparsing.\+remove\+Quotes (\begin{DoxyParamCaption}\item[{}]{s,  }\item[{}]{l,  }\item[{}]{t }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper parse action for removing quotation marks from parsed
quoted strings.

Example::

    # by default, quotation marks are included in parsed results
    quotedString.parseString("'Now is the Winter of our Discontent'") # -> ["'Now is the Winter of our Discontent'"]

    # use removeQuotes to strip quotation marks from parsed results
    quotedString.setParseAction(removeQuotes)
    quotedString.parseString("'Now is the Winter of our Discontent'") # -> ["Now is the Winter of our Discontent"]
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a6bdc3e8bb15795f14ddf563e1ca764b3}\label{namespacepyparsing_a6bdc3e8bb15795f14ddf563e1ca764b3}} 
\index{pyparsing@{pyparsing}!replace\+H\+T\+M\+L\+Entity@{replace\+H\+T\+M\+L\+Entity}}
\index{replace\+H\+T\+M\+L\+Entity@{replace\+H\+T\+M\+L\+Entity}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{replace\+H\+T\+M\+L\+Entity()}{replaceHTMLEntity()}}
{\footnotesize\ttfamily def pyparsing.\+replace\+H\+T\+M\+L\+Entity (\begin{DoxyParamCaption}\item[{}]{t }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper parser action to replace common HTML entities with their special characters\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a495a53dce17529eb7ae084dfe3a0acc4}\label{namespacepyparsing_a495a53dce17529eb7ae084dfe3a0acc4}} 
\index{pyparsing@{pyparsing}!replace\+With@{replace\+With}}
\index{replace\+With@{replace\+With}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{replace\+With()}{replaceWith()}}
{\footnotesize\ttfamily def pyparsing.\+replace\+With (\begin{DoxyParamCaption}\item[{}]{repl\+Str }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper method for common parse actions that simply return
a literal value.  Especially useful when used with
:class:`transformString<ParserElement.transformString>` ().

Example::

    num = Word(nums).setParseAction(lambda toks: int(toks[0]))
    na = oneOf("N/A NA").setParseAction(replaceWith(math.nan))
    term = na | num

    OneOrMore(term).parseString("324 234 N/A 234") # -> [324, 234, nan, 234]
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a189051e4dd15d661d3e577ef5490d716}\label{namespacepyparsing_a189051e4dd15d661d3e577ef5490d716}} 
\index{pyparsing@{pyparsing}!srange@{srange}}
\index{srange@{srange}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{srange()}{srange()}}
{\footnotesize\ttfamily def pyparsing.\+srange (\begin{DoxyParamCaption}\item[{}]{s }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to easily define string ranges for use in Word
construction. Borrows syntax from regexp '[]' string range
definitions::

    srange("[0-9]")   -> "0123456789"
    srange("[a-z]")   -> "abcdefghijklmnopqrstuvwxyz"
    srange("[a-z$_]") -> "abcdefghijklmnopqrstuvwxyz$_"

The input string must be enclosed in []'s, and the returned string
is the expanded character set joined into a single string. The
values enclosed in the []'s may be:

 - a single character
 - an escaped character with a leading backslash (such as ``\-``
   or ``\]``)
 - an escaped hex character with a leading ``'\x'``
   (``\x21``, which is a ``'!'`` character) (``\0x##``
   is also supported for backwards compatibility)
 - an escaped octal character with a leading ``'\0'``
   (``\041``, which is a ``'!'`` character)
 - a range of any of the above, separated by a dash (``'a-z'``,
   etc.)
 - any combination of the above (``'aeiouy'``,
   ``'a-zA-Z0-9_$'``, etc.)
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a4f2b3f96efca0c41fda874a8f9389555}\label{namespacepyparsing_a4f2b3f96efca0c41fda874a8f9389555}} 
\index{pyparsing@{pyparsing}!token\+Map@{token\+Map}}
\index{token\+Map@{token\+Map}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{token\+Map()}{tokenMap()}}
{\footnotesize\ttfamily def pyparsing.\+token\+Map (\begin{DoxyParamCaption}\item[{}]{func,  }\item[{}]{args }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to define a parse action by mapping a function to all
elements of a ParseResults list. If any additional args are passed,
they are forwarded to the given function as additional arguments
after the token, as in
``hex_integer = Word(hexnums).setParseAction(tokenMap(int, 16))``,
which will convert the parsed data to an integer using base 16.

Example (compare the last to example in :class:`ParserElement.transformString`::

    hex_ints = OneOrMore(Word(hexnums)).setParseAction(tokenMap(int, 16))
    hex_ints.runTests('''
        00 11 22 aa FF 0a 0d 1a
        ''')

    upperword = Word(alphas).setParseAction(tokenMap(str.upper))
    OneOrMore(upperword).runTests('''
        my kingdom for a horse
        ''')

    wd = Word(alphas).setParseAction(tokenMap(str.title))
    OneOrMore(wd).setParseAction(' '.join).runTests('''
        now is the winter of our discontent made glorious summer by this sun of york
        ''')

prints::

    00 11 22 aa FF 0a 0d 1a
    [0, 17, 34, 170, 255, 10, 13, 26]

    my kingdom for a horse
    ['MY', 'KINGDOM', 'FOR', 'A', 'HORSE']

    now is the winter of our discontent made glorious summer by this sun of york
    ['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York']
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a90995c5cae27231b18d57f49d55db206}\label{namespacepyparsing_a90995c5cae27231b18d57f49d55db206}} 
\index{pyparsing@{pyparsing}!trace\+Parse\+Action@{trace\+Parse\+Action}}
\index{trace\+Parse\+Action@{trace\+Parse\+Action}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{trace\+Parse\+Action()}{traceParseAction()}}
{\footnotesize\ttfamily def pyparsing.\+trace\+Parse\+Action (\begin{DoxyParamCaption}\item[{}]{f }\end{DoxyParamCaption})}

\begin{DoxyVerb}Decorator for debugging parse actions.

When the parse action is called, this decorator will print
``">> entering method-name(line:<current_source_line>, <parse_location>, <matched_tokens>)"``.
When the parse action completes, the decorator will print
``"<<"`` followed by the returned value, or any exception that the parse action raised.

Example::

    wd = Word(alphas)

    @traceParseAction
    def remove_duplicate_chars(tokens):
        return ''.join(sorted(set(''.join(tokens))))

    wds = OneOrMore(wd).setParseAction(remove_duplicate_chars)
    print(wds.parseString("slkdjs sld sldd sdlf sdljf"))

prints::

    >>entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {}))
    <<leaving remove_duplicate_chars (ret: 'dfjkls')
    ['dfjkls']
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a88118fadaa81fc84f4c5a2c3a9ca4205}\label{namespacepyparsing_a88118fadaa81fc84f4c5a2c3a9ca4205}} 
\index{pyparsing@{pyparsing}!ungroup@{ungroup}}
\index{ungroup@{ungroup}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{ungroup()}{ungroup()}}
{\footnotesize\ttfamily def pyparsing.\+ungroup (\begin{DoxyParamCaption}\item[{}]{expr }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to undo pyparsing's default grouping of And expressions,
even if all but one are non-empty.
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_ada8651dcae5c5d931d803b9e9a63e1e9}\label{namespacepyparsing_ada8651dcae5c5d931d803b9e9a63e1e9}} 
\index{pyparsing@{pyparsing}!with\+Attribute@{with\+Attribute}}
\index{with\+Attribute@{with\+Attribute}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{with\+Attribute()}{withAttribute()}}
{\footnotesize\ttfamily def pyparsing.\+with\+Attribute (\begin{DoxyParamCaption}\item[{}]{args,  }\item[{}]{attr\+Dict }\end{DoxyParamCaption})}

\begin{DoxyVerb}Helper to create a validating parse action to be used with start
tags created with :class:`makeXMLTags` or
:class:`makeHTMLTags`. Use ``withAttribute`` to qualify
a starting tag with a required attribute value, to avoid false
matches on common tags such as ``<TD>`` or ``<DIV>``.

Call ``withAttribute`` with a series of attribute names and
values. Specify the list of filter attributes names and values as:

 - keyword arguments, as in ``(align="right")``, or
 - as an explicit dict with ``**`` operator, when an attribute
   name is also a Python reserved word, as in ``**{"class":"Customer", "align":"right"}``
 - a list of name-value tuples, as in ``(("ns1:class", "Customer"), ("ns2:align", "right"))``

For attribute names with a namespace prefix, you must use the second
form.  Attribute names are matched insensitive to upper/lower case.

If just testing for ``class`` (with or without a namespace), use
:class:`withClass`.

To verify that the attribute exists, but without specifying a value,
pass ``withAttribute.ANY_VALUE`` as the value.

Example::

    html = '''
        <div>
        Some text
        <div type="grid">1 4 0 1 0</div>
        <div type="graph">1,3 2,3 1,1</div>
        <div>this has no type</div>
        </div>

    '''
    div,div_end = makeHTMLTags("div")

    # only match div tag having a type attribute with value "grid"
    div_grid = div().setParseAction(withAttribute(type="grid"))
    grid_expr = div_grid + SkipTo(div | div_end)("body")
    for grid_header in grid_expr.searchString(html):
        print(grid_header.body)

    # construct a match with any div tag having a type attribute, regardless of the value
    div_any_type = div().setParseAction(withAttribute(type=withAttribute.ANY_VALUE))
    div_expr = div_any_type + SkipTo(div | div_end)("body")
    for div_header in div_expr.searchString(html):
        print(div_header.body)

prints::

    1 4 0 1 0

    1 4 0 1 0
    1,3 2,3 1,1
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a7e7ce66cc9889c783c6d086ffd29eec9}\label{namespacepyparsing_a7e7ce66cc9889c783c6d086ffd29eec9}} 
\index{pyparsing@{pyparsing}!with\+Class@{with\+Class}}
\index{with\+Class@{with\+Class}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{with\+Class()}{withClass()}}
{\footnotesize\ttfamily def pyparsing.\+with\+Class (\begin{DoxyParamCaption}\item[{}]{classname,  }\item[{}]{namespace = {\ttfamily \textquotesingle{}\textquotesingle{}} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Simplified version of :class:`withAttribute` when
matching on a div class - made difficult because ``class`` is
a reserved word in Python.

Example::

    html = '''
        <div>
        Some text
        <div class="grid">1 4 0 1 0</div>
        <div class="graph">1,3 2,3 1,1</div>
        <div>this &lt;div&gt; has no class</div>
        </div>

    '''
    div,div_end = makeHTMLTags("div")
    div_grid = div().setParseAction(withClass("grid"))

    grid_expr = div_grid + SkipTo(div | div_end)("body")
    for grid_header in grid_expr.searchString(html):
        print(grid_header.body)

    div_any_type = div().setParseAction(withClass(withAttribute.ANY_VALUE))
    div_expr = div_any_type + SkipTo(div | div_end)("body")
    for div_header in div_expr.searchString(html):
        print(div_header.body)

prints::

    1 4 0 1 0

    1 4 0 1 0
    1,3 2,3 1,1
\end{DoxyVerb}
 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespacepyparsing_ab4563dfe6c41c6e5f5ac641f3264882a}\label{namespacepyparsing_ab4563dfe6c41c6e5f5ac641f3264882a}} 
\index{pyparsing@{pyparsing}!alphanums@{alphanums}}
\index{alphanums@{alphanums}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{alphanums}{alphanums}}
{\footnotesize\ttfamily pyparsing.\+alphanums}

\mbox{\Hypertarget{namespacepyparsing_a7ea525fb202cede10838006336a1bce3}\label{namespacepyparsing_a7ea525fb202cede10838006336a1bce3}} 
\index{pyparsing@{pyparsing}!alphas@{alphas}}
\index{alphas@{alphas}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{alphas}{alphas}}
{\footnotesize\ttfamily pyparsing.\+alphas}

\mbox{\Hypertarget{namespacepyparsing_af6acfb83e599b4f2faf002a272701618}\label{namespacepyparsing_af6acfb83e599b4f2faf002a272701618}} 
\index{pyparsing@{pyparsing}!alphas8bit@{alphas8bit}}
\index{alphas8bit@{alphas8bit}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{alphas8bit}{alphas8bit}}
{\footnotesize\ttfamily pyparsing.\+alphas8bit}

\mbox{\Hypertarget{namespacepyparsing_a4d942e48b9a8f74387a2fc26b3f7ad9a}\label{namespacepyparsing_a4d942e48b9a8f74387a2fc26b3f7ad9a}} 
\index{pyparsing@{pyparsing}!any\+Close\+Tag@{any\+Close\+Tag}}
\index{any\+Close\+Tag@{any\+Close\+Tag}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{any\+Close\+Tag}{anyCloseTag}}
{\footnotesize\ttfamily pyparsing.\+any\+Close\+Tag}

\mbox{\Hypertarget{namespacepyparsing_a4aae3dfc90ea1f18670821f07458e9cb}\label{namespacepyparsing_a4aae3dfc90ea1f18670821f07458e9cb}} 
\index{pyparsing@{pyparsing}!any\+Open\+Tag@{any\+Open\+Tag}}
\index{any\+Open\+Tag@{any\+Open\+Tag}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{any\+Open\+Tag}{anyOpenTag}}
{\footnotesize\ttfamily pyparsing.\+any\+Open\+Tag}

\mbox{\Hypertarget{namespacepyparsing_a6c68e6b7f8abb69c2e4bf97f737501e4}\label{namespacepyparsing_a6c68e6b7f8abb69c2e4bf97f737501e4}} 
\index{pyparsing@{pyparsing}!basestring@{basestring}}
\index{basestring@{basestring}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{basestring}{basestring}}
{\footnotesize\ttfamily pyparsing.\+basestring}

\mbox{\Hypertarget{namespacepyparsing_a36ef0f31029c711e127c908399dd04bb}\label{namespacepyparsing_a36ef0f31029c711e127c908399dd04bb}} 
\index{pyparsing@{pyparsing}!collect\+\_\+all\+\_\+\+And\+\_\+tokens@{collect\+\_\+all\+\_\+\+And\+\_\+tokens}}
\index{collect\+\_\+all\+\_\+\+And\+\_\+tokens@{collect\+\_\+all\+\_\+\+And\+\_\+tokens}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{collect\+\_\+all\+\_\+\+And\+\_\+tokens}{collect\_all\_And\_tokens}}
{\footnotesize\ttfamily pyparsing.\+collect\+\_\+all\+\_\+\+And\+\_\+tokens}

\begin{DoxyVerb}A cross-version compatibility configuration for pyparsing features that will be
released in a future version. By setting values in this configuration to True,
those features can be enabled in prior versions for compatibility development
and testing.

 - collect_all_And_tokens - flag to enable fix for Issue #63 that fixes erroneous grouping
   of results names when an And expression is nested within an Or or MatchFirst; set to
   True to enable bugfix released in pyparsing 2.3.0, or False to preserve
   pre-2.3.0 handling of named results
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_a39b7738fa924d5b7f5e7d618b7977288}\label{namespacepyparsing_a39b7738fa924d5b7f5e7d618b7977288}} 
\index{pyparsing@{pyparsing}!column\+Name@{column\+Name}}
\index{column\+Name@{column\+Name}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{column\+Name}{columnName}}
{\footnotesize\ttfamily pyparsing.\+column\+Name}

\mbox{\Hypertarget{namespacepyparsing_a62e51d98617e05187ba5fd6cf5921d7b}\label{namespacepyparsing_a62e51d98617e05187ba5fd6cf5921d7b}} 
\index{pyparsing@{pyparsing}!column\+Name\+List@{column\+Name\+List}}
\index{column\+Name\+List@{column\+Name\+List}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{column\+Name\+List}{columnNameList}}
{\footnotesize\ttfamily pyparsing.\+column\+Name\+List}

\mbox{\Hypertarget{namespacepyparsing_af132d884d4b4dff49793ed88314e000a}\label{namespacepyparsing_af132d884d4b4dff49793ed88314e000a}} 
\index{pyparsing@{pyparsing}!column\+Spec@{column\+Spec}}
\index{column\+Spec@{column\+Spec}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{column\+Spec}{columnSpec}}
{\footnotesize\ttfamily pyparsing.\+column\+Spec}

\mbox{\Hypertarget{namespacepyparsing_a0126ec62225fec124646aff2b8e03a09}\label{namespacepyparsing_a0126ec62225fec124646aff2b8e03a09}} 
\index{pyparsing@{pyparsing}!combine@{combine}}
\index{combine@{combine}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{combine}{combine}}
{\footnotesize\ttfamily pyparsing.\+combine}

\mbox{\Hypertarget{namespacepyparsing_ab20829dba0badd12b633306b6e947568}\label{namespacepyparsing_ab20829dba0badd12b633306b6e947568}} 
\index{pyparsing@{pyparsing}!comma\+Separated\+List@{comma\+Separated\+List}}
\index{comma\+Separated\+List@{comma\+Separated\+List}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{comma\+Separated\+List}{commaSeparatedList}}
{\footnotesize\ttfamily pyparsing.\+comma\+Separated\+List}

\mbox{\Hypertarget{namespacepyparsing_a6d28fa11d5129a845c510f8b1c95d5db}\label{namespacepyparsing_a6d28fa11d5129a845c510f8b1c95d5db}} 
\index{pyparsing@{pyparsing}!common\+H\+T\+M\+L\+Entity@{common\+H\+T\+M\+L\+Entity}}
\index{common\+H\+T\+M\+L\+Entity@{common\+H\+T\+M\+L\+Entity}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{common\+H\+T\+M\+L\+Entity}{commonHTMLEntity}}
{\footnotesize\ttfamily pyparsing.\+common\+H\+T\+M\+L\+Entity}

\mbox{\Hypertarget{namespacepyparsing_ad628fe6a4713164892174183fdf408c4}\label{namespacepyparsing_ad628fe6a4713164892174183fdf408c4}} 
\index{pyparsing@{pyparsing}!cpp\+Style\+Comment@{cpp\+Style\+Comment}}
\index{cpp\+Style\+Comment@{cpp\+Style\+Comment}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{cpp\+Style\+Comment}{cppStyleComment}}
{\footnotesize\ttfamily pyparsing.\+cpp\+Style\+Comment}

\mbox{\Hypertarget{namespacepyparsing_a6e3b9caf64e1ab2062eb456c83fd60bb}\label{namespacepyparsing_a6e3b9caf64e1ab2062eb456c83fd60bb}} 
\index{pyparsing@{pyparsing}!c\+Style\+Comment@{c\+Style\+Comment}}
\index{c\+Style\+Comment@{c\+Style\+Comment}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{c\+Style\+Comment}{cStyleComment}}
{\footnotesize\ttfamily pyparsing.\+c\+Style\+Comment}

\mbox{\Hypertarget{namespacepyparsing_ab8f938666ea40119a8419a8cabca3eee}\label{namespacepyparsing_ab8f938666ea40119a8419a8cabca3eee}} 
\index{pyparsing@{pyparsing}!dbl\+Quoted\+String@{dbl\+Quoted\+String}}
\index{dbl\+Quoted\+String@{dbl\+Quoted\+String}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{dbl\+Quoted\+String}{dblQuotedString}}
{\footnotesize\ttfamily pyparsing.\+dbl\+Quoted\+String}

\mbox{\Hypertarget{namespacepyparsing_a78f004a9a6f08bdd699b70210724a9b2}\label{namespacepyparsing_a78f004a9a6f08bdd699b70210724a9b2}} 
\index{pyparsing@{pyparsing}!dbl\+Slash\+Comment@{dbl\+Slash\+Comment}}
\index{dbl\+Slash\+Comment@{dbl\+Slash\+Comment}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{dbl\+Slash\+Comment}{dblSlashComment}}
{\footnotesize\ttfamily pyparsing.\+dbl\+Slash\+Comment}

\mbox{\Hypertarget{namespacepyparsing_af718ddc22535044334309aa6db3c8bb9}\label{namespacepyparsing_af718ddc22535044334309aa6db3c8bb9}} 
\index{pyparsing@{pyparsing}!default@{default}}
\index{default@{default}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{default}{default}}
{\footnotesize\ttfamily pyparsing.\+default}

\mbox{\Hypertarget{namespacepyparsing_ae22271fdc1f1b5617ad49da27880d980}\label{namespacepyparsing_ae22271fdc1f1b5617ad49da27880d980}} 
\index{pyparsing@{pyparsing}!downcase\+Tokens@{downcase\+Tokens}}
\index{downcase\+Tokens@{downcase\+Tokens}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{downcase\+Tokens}{downcaseTokens}}
{\footnotesize\ttfamily pyparsing.\+downcase\+Tokens}

\mbox{\Hypertarget{namespacepyparsing_af77587cc29467c9ee7feb01c8cc71445}\label{namespacepyparsing_af77587cc29467c9ee7feb01c8cc71445}} 
\index{pyparsing@{pyparsing}!empty@{empty}}
\index{empty@{empty}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{empty}{empty}}
{\footnotesize\ttfamily pyparsing.\+empty}

\mbox{\Hypertarget{namespacepyparsing_a5dd424478354cea2c2a4eec9e762fd23}\label{namespacepyparsing_a5dd424478354cea2c2a4eec9e762fd23}} 
\index{pyparsing@{pyparsing}!enable\+\_\+debug\+\_\+on\+\_\+named\+\_\+expressions@{enable\+\_\+debug\+\_\+on\+\_\+named\+\_\+expressions}}
\index{enable\+\_\+debug\+\_\+on\+\_\+named\+\_\+expressions@{enable\+\_\+debug\+\_\+on\+\_\+named\+\_\+expressions}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{enable\+\_\+debug\+\_\+on\+\_\+named\+\_\+expressions}{enable\_debug\_on\_named\_expressions}}
{\footnotesize\ttfamily pyparsing.\+enable\+\_\+debug\+\_\+on\+\_\+named\+\_\+expressions}

\mbox{\Hypertarget{namespacepyparsing_a832e22d9e8c149774782b6f58d10278f}\label{namespacepyparsing_a832e22d9e8c149774782b6f58d10278f}} 
\index{pyparsing@{pyparsing}!exact@{exact}}
\index{exact@{exact}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{exact}{exact}}
{\footnotesize\ttfamily pyparsing.\+exact}

\mbox{\Hypertarget{namespacepyparsing_a74a0d58c5c3028ec3baa9b4db4a9a9f0}\label{namespacepyparsing_a74a0d58c5c3028ec3baa9b4db4a9a9f0}} 
\index{pyparsing@{pyparsing}!exclude\+Chars@{exclude\+Chars}}
\index{exclude\+Chars@{exclude\+Chars}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{exclude\+Chars}{excludeChars}}
{\footnotesize\ttfamily pyparsing.\+exclude\+Chars}

\mbox{\Hypertarget{namespacepyparsing_ab4ff54360a77decc8f7a39f8a09e781b}\label{namespacepyparsing_ab4ff54360a77decc8f7a39f8a09e781b}} 
\index{pyparsing@{pyparsing}!from\+Token@{from\+Token}}
\index{from\+Token@{from\+Token}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{from\+Token}{fromToken}}
{\footnotesize\ttfamily pyparsing.\+from\+Token}

\mbox{\Hypertarget{namespacepyparsing_acb57794a1fe02811f6033bb6f89f3ccb}\label{namespacepyparsing_acb57794a1fe02811f6033bb6f89f3ccb}} 
\index{pyparsing@{pyparsing}!hexnums@{hexnums}}
\index{hexnums@{hexnums}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{hexnums}{hexnums}}
{\footnotesize\ttfamily pyparsing.\+hexnums}

\mbox{\Hypertarget{namespacepyparsing_a31d6b3c2621c7ee5fce8a4f4ff920826}\label{namespacepyparsing_a31d6b3c2621c7ee5fce8a4f4ff920826}} 
\index{pyparsing@{pyparsing}!html\+Comment@{html\+Comment}}
\index{html\+Comment@{html\+Comment}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{html\+Comment}{htmlComment}}
{\footnotesize\ttfamily pyparsing.\+html\+Comment}

\mbox{\Hypertarget{namespacepyparsing_ac1f47b83b95624ba10c0fe5884afa784}\label{namespacepyparsing_ac1f47b83b95624ba10c0fe5884afa784}} 
\index{pyparsing@{pyparsing}!ident@{ident}}
\index{ident@{ident}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{ident}{ident}}
{\footnotesize\ttfamily pyparsing.\+ident}

\mbox{\Hypertarget{namespacepyparsing_aaf99577452dceda33ce9a94cac87bdc7}\label{namespacepyparsing_aaf99577452dceda33ce9a94cac87bdc7}} 
\index{pyparsing@{pyparsing}!java\+Style\+Comment@{java\+Style\+Comment}}
\index{java\+Style\+Comment@{java\+Style\+Comment}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{java\+Style\+Comment}{javaStyleComment}}
{\footnotesize\ttfamily pyparsing.\+java\+Style\+Comment}

\mbox{\Hypertarget{namespacepyparsing_a4483dde0dd5ecb74c34ae9a7af941236}\label{namespacepyparsing_a4483dde0dd5ecb74c34ae9a7af941236}} 
\index{pyparsing@{pyparsing}!L\+E\+FT@{L\+E\+FT}}
\index{L\+E\+FT@{L\+E\+FT}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{L\+E\+FT}{LEFT}}
{\footnotesize\ttfamily pyparsing.\+L\+E\+FT}

\mbox{\Hypertarget{namespacepyparsing_a042457c4400ee7d4cbc47498d08a7373}\label{namespacepyparsing_a042457c4400ee7d4cbc47498d08a7373}} 
\index{pyparsing@{pyparsing}!line\+End@{line\+End}}
\index{line\+End@{line\+End}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{line\+End}{lineEnd}}
{\footnotesize\ttfamily pyparsing.\+line\+End}

\mbox{\Hypertarget{namespacepyparsing_a2b04510cc30ccec2e272684c835b4d0c}\label{namespacepyparsing_a2b04510cc30ccec2e272684c835b4d0c}} 
\index{pyparsing@{pyparsing}!line\+Start@{line\+Start}}
\index{line\+Start@{line\+Start}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{line\+Start}{lineStart}}
{\footnotesize\ttfamily pyparsing.\+line\+Start}

\mbox{\Hypertarget{namespacepyparsing_a5a54a159f2739470343562de3a9079a7}\label{namespacepyparsing_a5a54a159f2739470343562de3a9079a7}} 
\index{pyparsing@{pyparsing}!nums@{nums}}
\index{nums@{nums}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{nums}{nums}}
{\footnotesize\ttfamily pyparsing.\+nums}

\mbox{\Hypertarget{namespacepyparsing_a2c8744b10e3c348dea440d54cae878d5}\label{namespacepyparsing_a2c8744b10e3c348dea440d54cae878d5}} 
\index{pyparsing@{pyparsing}!op\+Assoc@{op\+Assoc}}
\index{op\+Assoc@{op\+Assoc}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{op\+Assoc}{opAssoc}}
{\footnotesize\ttfamily pyparsing.\+op\+Assoc}

\mbox{\Hypertarget{namespacepyparsing_a87d6136009560b41a09d42269b7982d8}\label{namespacepyparsing_a87d6136009560b41a09d42269b7982d8}} 
\index{pyparsing@{pyparsing}!operator\+Precedence@{operator\+Precedence}}
\index{operator\+Precedence@{operator\+Precedence}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{operator\+Precedence}{operatorPrecedence}}
{\footnotesize\ttfamily pyparsing.\+operator\+Precedence}

\mbox{\Hypertarget{namespacepyparsing_ad8c4f09cc517099e759be4c94403f9b4}\label{namespacepyparsing_ad8c4f09cc517099e759be4c94403f9b4}} 
\index{pyparsing@{pyparsing}!printables@{printables}}
\index{printables@{printables}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{printables}{printables}}
{\footnotesize\ttfamily pyparsing.\+printables}

\mbox{\Hypertarget{namespacepyparsing_aa6f0bafa554b716a30eacdc87bc2b127}\label{namespacepyparsing_aa6f0bafa554b716a30eacdc87bc2b127}} 
\index{pyparsing@{pyparsing}!punc8bit@{punc8bit}}
\index{punc8bit@{punc8bit}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{punc8bit}{punc8bit}}
{\footnotesize\ttfamily pyparsing.\+punc8bit}

\mbox{\Hypertarget{namespacepyparsing_a1e1385063b54a6e3461c11bb1c85c72f}\label{namespacepyparsing_a1e1385063b54a6e3461c11bb1c85c72f}} 
\index{pyparsing@{pyparsing}!P\+Y\+\_\+3@{P\+Y\+\_\+3}}
\index{P\+Y\+\_\+3@{P\+Y\+\_\+3}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{P\+Y\+\_\+3}{PY\_3}}
{\footnotesize\ttfamily pyparsing.\+P\+Y\+\_\+3}

\mbox{\Hypertarget{namespacepyparsing_abf3cd0b4b911951b53e88978b03b2d7e}\label{namespacepyparsing_abf3cd0b4b911951b53e88978b03b2d7e}} 
\index{pyparsing@{pyparsing}!python\+Style\+Comment@{python\+Style\+Comment}}
\index{python\+Style\+Comment@{python\+Style\+Comment}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{python\+Style\+Comment}{pythonStyleComment}}
{\footnotesize\ttfamily pyparsing.\+python\+Style\+Comment}

\mbox{\Hypertarget{namespacepyparsing_ae8adf871b3e4f03a1f441f0616841ef2}\label{namespacepyparsing_ae8adf871b3e4f03a1f441f0616841ef2}} 
\index{pyparsing@{pyparsing}!quoted\+String@{quoted\+String}}
\index{quoted\+String@{quoted\+String}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{quoted\+String}{quotedString}}
{\footnotesize\ttfamily pyparsing.\+quoted\+String}

\mbox{\Hypertarget{namespacepyparsing_a602ae0487c529c04f859bb13c0d8a50f}\label{namespacepyparsing_a602ae0487c529c04f859bb13c0d8a50f}} 
\index{pyparsing@{pyparsing}!range@{range}}
\index{range@{range}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{range}{range}}
{\footnotesize\ttfamily pyparsing.\+range}

\mbox{\Hypertarget{namespacepyparsing_a1629e0f70e54804d41c13c042c99d7c9}\label{namespacepyparsing_a1629e0f70e54804d41c13c042c99d7c9}} 
\index{pyparsing@{pyparsing}!rest\+Of\+Line@{rest\+Of\+Line}}
\index{rest\+Of\+Line@{rest\+Of\+Line}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{rest\+Of\+Line}{restOfLine}}
{\footnotesize\ttfamily pyparsing.\+rest\+Of\+Line}

\mbox{\Hypertarget{namespacepyparsing_a76212e2a2b806de1ea2565168c9f68d8}\label{namespacepyparsing_a76212e2a2b806de1ea2565168c9f68d8}} 
\index{pyparsing@{pyparsing}!R\+I\+G\+HT@{R\+I\+G\+HT}}
\index{R\+I\+G\+HT@{R\+I\+G\+HT}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{R\+I\+G\+HT}{RIGHT}}
{\footnotesize\ttfamily pyparsing.\+R\+I\+G\+HT}

\mbox{\Hypertarget{namespacepyparsing_a40b34d438ee87b3e8ae2e84f371f0e4d}\label{namespacepyparsing_a40b34d438ee87b3e8ae2e84f371f0e4d}} 
\index{pyparsing@{pyparsing}!select\+Token@{select\+Token}}
\index{select\+Token@{select\+Token}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{select\+Token}{selectToken}}
{\footnotesize\ttfamily pyparsing.\+select\+Token}

\mbox{\Hypertarget{namespacepyparsing_a1c5f0ce91e25d989ae22e23242e98f3a}\label{namespacepyparsing_a1c5f0ce91e25d989ae22e23242e98f3a}} 
\index{pyparsing@{pyparsing}!sgl\+Quoted\+String@{sgl\+Quoted\+String}}
\index{sgl\+Quoted\+String@{sgl\+Quoted\+String}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{sgl\+Quoted\+String}{sglQuotedString}}
{\footnotesize\ttfamily pyparsing.\+sgl\+Quoted\+String}

\mbox{\Hypertarget{namespacepyparsing_a6247ca830771f5336f5595ce38aae4e5}\label{namespacepyparsing_a6247ca830771f5336f5595ce38aae4e5}} 
\index{pyparsing@{pyparsing}!simple\+S\+QL@{simple\+S\+QL}}
\index{simple\+S\+QL@{simple\+S\+QL}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{simple\+S\+QL}{simpleSQL}}
{\footnotesize\ttfamily pyparsing.\+simple\+S\+QL}

\mbox{\Hypertarget{namespacepyparsing_a1784680ba17a7229153f90c437d5fe39}\label{namespacepyparsing_a1784680ba17a7229153f90c437d5fe39}} 
\index{pyparsing@{pyparsing}!single\+Arg\+Builtins@{single\+Arg\+Builtins}}
\index{single\+Arg\+Builtins@{single\+Arg\+Builtins}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{single\+Arg\+Builtins}{singleArgBuiltins}}
{\footnotesize\ttfamily pyparsing.\+single\+Arg\+Builtins}

\mbox{\Hypertarget{namespacepyparsing_a703772e5be771c9f8d299cbffaf84a5c}\label{namespacepyparsing_a703772e5be771c9f8d299cbffaf84a5c}} 
\index{pyparsing@{pyparsing}!string\+End@{string\+End}}
\index{string\+End@{string\+End}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{string\+End}{stringEnd}}
{\footnotesize\ttfamily pyparsing.\+string\+End}

\mbox{\Hypertarget{namespacepyparsing_a67f47d95cd52b3975fe581d9a7f8ab29}\label{namespacepyparsing_a67f47d95cd52b3975fe581d9a7f8ab29}} 
\index{pyparsing@{pyparsing}!string\+Start@{string\+Start}}
\index{string\+Start@{string\+Start}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{string\+Start}{stringStart}}
{\footnotesize\ttfamily pyparsing.\+string\+Start}

\mbox{\Hypertarget{namespacepyparsing_a07e6a30780a15263d8cb84c17a229a69}\label{namespacepyparsing_a07e6a30780a15263d8cb84c17a229a69}} 
\index{pyparsing@{pyparsing}!system\+\_\+version@{system\+\_\+version}}
\index{system\+\_\+version@{system\+\_\+version}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{system\+\_\+version}{system\_version}}
{\footnotesize\ttfamily pyparsing.\+system\+\_\+version}

\mbox{\Hypertarget{namespacepyparsing_a99b6235d1239f50a062716d8e1df305a}\label{namespacepyparsing_a99b6235d1239f50a062716d8e1df305a}} 
\index{pyparsing@{pyparsing}!table\+Name@{table\+Name}}
\index{table\+Name@{table\+Name}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{table\+Name}{tableName}}
{\footnotesize\ttfamily pyparsing.\+table\+Name}

\mbox{\Hypertarget{namespacepyparsing_a7fa9d94a72a7f9f75d582cce8539e11c}\label{namespacepyparsing_a7fa9d94a72a7f9f75d582cce8539e11c}} 
\index{pyparsing@{pyparsing}!table\+Name\+List@{table\+Name\+List}}
\index{table\+Name\+List@{table\+Name\+List}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{table\+Name\+List}{tableNameList}}
{\footnotesize\ttfamily pyparsing.\+table\+Name\+List}

\mbox{\Hypertarget{namespacepyparsing_a6fb3beeb55235aeb9620d7c12b47dab4}\label{namespacepyparsing_a6fb3beeb55235aeb9620d7c12b47dab4}} 
\index{pyparsing@{pyparsing}!unichr@{unichr}}
\index{unichr@{unichr}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{unichr}{unichr}}
{\footnotesize\ttfamily pyparsing.\+unichr}

\mbox{\Hypertarget{namespacepyparsing_a26795664953d67ad5c7ed1828e11aa6b}\label{namespacepyparsing_a26795664953d67ad5c7ed1828e11aa6b}} 
\index{pyparsing@{pyparsing}!unicode@{unicode}}
\index{unicode@{unicode}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{unicode}{unicode}}
{\footnotesize\ttfamily pyparsing.\+unicode}

\mbox{\Hypertarget{namespacepyparsing_a63ab3f5b3ec40c82f883f2b187a4059a}\label{namespacepyparsing_a63ab3f5b3ec40c82f883f2b187a4059a}} 
\index{pyparsing@{pyparsing}!unicode\+String@{unicode\+String}}
\index{unicode\+String@{unicode\+String}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{unicode\+String}{unicodeString}}
{\footnotesize\ttfamily pyparsing.\+unicode\+String}

\mbox{\Hypertarget{namespacepyparsing_a87da767bd1f40e1004abf38d62e37162}\label{namespacepyparsing_a87da767bd1f40e1004abf38d62e37162}} 
\index{pyparsing@{pyparsing}!upcase\+Tokens@{upcase\+Tokens}}
\index{upcase\+Tokens@{upcase\+Tokens}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{upcase\+Tokens}{upcaseTokens}}
{\footnotesize\ttfamily pyparsing.\+upcase\+Tokens}

\mbox{\Hypertarget{namespacepyparsing_a7d99f94ef00c20cbfc7c636536123ad3}\label{namespacepyparsing_a7d99f94ef00c20cbfc7c636536123ad3}} 
\index{pyparsing@{pyparsing}!warn\+\_\+multiple\+\_\+tokens\+\_\+in\+\_\+named\+\_\+alternation@{warn\+\_\+multiple\+\_\+tokens\+\_\+in\+\_\+named\+\_\+alternation}}
\index{warn\+\_\+multiple\+\_\+tokens\+\_\+in\+\_\+named\+\_\+alternation@{warn\+\_\+multiple\+\_\+tokens\+\_\+in\+\_\+named\+\_\+alternation}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{warn\+\_\+multiple\+\_\+tokens\+\_\+in\+\_\+named\+\_\+alternation}{warn\_multiple\_tokens\_in\_named\_alternation}}
{\footnotesize\ttfamily pyparsing.\+warn\+\_\+multiple\+\_\+tokens\+\_\+in\+\_\+named\+\_\+alternation}

\begin{DoxyVerb}Diagnostic configuration (all default to False)
 - warn_multiple_tokens_in_named_alternation - flag to enable warnings when a results
   name is defined on a MatchFirst or Or expression with one or more And subexpressions
   (only warns if __compat__.collect_all_And_tokens is False)
 - warn_ungrouped_named_tokens_in_collection - flag to enable warnings when a results
   name is defined on a containing expression with ungrouped subexpressions that also
   have results names
 - warn_name_set_on_empty_Forward - flag to enable warnings whan a Forward is defined
   with a results name, but has no contents defined
 - warn_on_multiple_string_args_to_oneof - flag to enable warnings whan oneOf is
   incorrectly called with multiple str arguments
 - enable_debug_on_named_expressions - flag to auto-enable debug on all subsequent
   calls to ParserElement.setName()
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacepyparsing_abd7b3ceae5de7e98982573176ca2ffa1}\label{namespacepyparsing_abd7b3ceae5de7e98982573176ca2ffa1}} 
\index{pyparsing@{pyparsing}!warn\+\_\+name\+\_\+set\+\_\+on\+\_\+empty\+\_\+\+Forward@{warn\+\_\+name\+\_\+set\+\_\+on\+\_\+empty\+\_\+\+Forward}}
\index{warn\+\_\+name\+\_\+set\+\_\+on\+\_\+empty\+\_\+\+Forward@{warn\+\_\+name\+\_\+set\+\_\+on\+\_\+empty\+\_\+\+Forward}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{warn\+\_\+name\+\_\+set\+\_\+on\+\_\+empty\+\_\+\+Forward}{warn\_name\_set\_on\_empty\_Forward}}
{\footnotesize\ttfamily pyparsing.\+warn\+\_\+name\+\_\+set\+\_\+on\+\_\+empty\+\_\+\+Forward}

\mbox{\Hypertarget{namespacepyparsing_a54dcb097557af387ec19dc45be5b0f28}\label{namespacepyparsing_a54dcb097557af387ec19dc45be5b0f28}} 
\index{pyparsing@{pyparsing}!warn\+\_\+on\+\_\+multiple\+\_\+string\+\_\+args\+\_\+to\+\_\+oneof@{warn\+\_\+on\+\_\+multiple\+\_\+string\+\_\+args\+\_\+to\+\_\+oneof}}
\index{warn\+\_\+on\+\_\+multiple\+\_\+string\+\_\+args\+\_\+to\+\_\+oneof@{warn\+\_\+on\+\_\+multiple\+\_\+string\+\_\+args\+\_\+to\+\_\+oneof}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{warn\+\_\+on\+\_\+multiple\+\_\+string\+\_\+args\+\_\+to\+\_\+oneof}{warn\_on\_multiple\_string\_args\_to\_oneof}}
{\footnotesize\ttfamily pyparsing.\+warn\+\_\+on\+\_\+multiple\+\_\+string\+\_\+args\+\_\+to\+\_\+oneof}

\mbox{\Hypertarget{namespacepyparsing_a2613eebe20756859399b13cd478b2f22}\label{namespacepyparsing_a2613eebe20756859399b13cd478b2f22}} 
\index{pyparsing@{pyparsing}!warn\+\_\+ungrouped\+\_\+named\+\_\+tokens\+\_\+in\+\_\+collection@{warn\+\_\+ungrouped\+\_\+named\+\_\+tokens\+\_\+in\+\_\+collection}}
\index{warn\+\_\+ungrouped\+\_\+named\+\_\+tokens\+\_\+in\+\_\+collection@{warn\+\_\+ungrouped\+\_\+named\+\_\+tokens\+\_\+in\+\_\+collection}!pyparsing@{pyparsing}}
\subsubsection{\texorpdfstring{warn\+\_\+ungrouped\+\_\+named\+\_\+tokens\+\_\+in\+\_\+collection}{warn\_ungrouped\_named\_tokens\_in\_collection}}
{\footnotesize\ttfamily pyparsing.\+warn\+\_\+ungrouped\+\_\+named\+\_\+tokens\+\_\+in\+\_\+collection}

