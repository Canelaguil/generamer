\hypertarget{namespacenumpy_1_1lib_1_1__iotools}{}\section{numpy.\+lib.\+\_\+iotools Namespace Reference}
\label{namespacenumpy_1_1lib_1_1__iotools}\index{numpy.\+lib.\+\_\+iotools@{numpy.\+lib.\+\_\+iotools}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classnumpy_1_1lib_1_1__iotools_1_1ConversionWarning}{Conversion\+Warning}
\item 
class \hyperlink{classnumpy_1_1lib_1_1__iotools_1_1ConverterError}{Converter\+Error}
\item 
class \hyperlink{classnumpy_1_1lib_1_1__iotools_1_1ConverterLockError}{Converter\+Lock\+Error}
\item 
class \hyperlink{classnumpy_1_1lib_1_1__iotools_1_1LineSplitter}{Line\+Splitter}
\item 
class \hyperlink{classnumpy_1_1lib_1_1__iotools_1_1NameValidator}{Name\+Validator}
\item 
class \hyperlink{classnumpy_1_1lib_1_1__iotools_1_1StringConverter}{String\+Converter}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1__iotools_a963397b6c785faf85aa430b490365798}{has\+\_\+nested\+\_\+fields} (ndtype)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1__iotools_ae64e910fdeae338f1f962ff03efb841e}{flatten\+\_\+dtype} (ndtype, flatten\+\_\+base=False)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1__iotools_a4ecb79a687b0f134273b11e96703f23f}{str2bool} (value)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1__iotools_ac490a3a791ed204e47c9c50f704ac40e}{easy\+\_\+dtype} (ndtype, names=None, defaultfmt=\char`\"{}f\%i\char`\"{}, validationargs)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}A collection of functions designed to help I/O with ascii files.\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_ac490a3a791ed204e47c9c50f704ac40e}\label{namespacenumpy_1_1lib_1_1__iotools_ac490a3a791ed204e47c9c50f704ac40e}} 
\index{numpy\+::lib\+::\+\_\+iotools@{numpy\+::lib\+::\+\_\+iotools}!easy\+\_\+dtype@{easy\+\_\+dtype}}
\index{easy\+\_\+dtype@{easy\+\_\+dtype}!numpy\+::lib\+::\+\_\+iotools@{numpy\+::lib\+::\+\_\+iotools}}
\subsubsection{\texorpdfstring{easy\+\_\+dtype()}{easy\_dtype()}}
{\footnotesize\ttfamily def numpy.\+lib.\+\_\+iotools.\+easy\+\_\+dtype (\begin{DoxyParamCaption}\item[{}]{ndtype,  }\item[{}]{names = {\ttfamily None},  }\item[{}]{defaultfmt = {\ttfamily \char`\"{}f\%i\char`\"{}},  }\item[{}]{validationargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convenience function to create a `np.dtype` object.

The function processes the input `dtype` and matches it with the given
names.

Parameters
----------
ndtype : var
    Definition of the dtype. Can be any string or dictionary recognized
    by the `np.dtype` function, or a sequence of types.
names : str or sequence, optional
    Sequence of strings to use as field names for a structured dtype.
    For convenience, `names` can be a string of a comma-separated list
    of names.
defaultfmt : str, optional
    Format string used to define missing names, such as ``"f%i"``
    (default) or ``"fields_%02i"``.
validationargs : optional
    A series of optional arguments used to initialize a
    `NameValidator`.

Examples
--------
>>> np.lib._iotools.easy_dtype(float)
dtype('float64')
>>> np.lib._iotools.easy_dtype("i4, f8")
dtype([('f0', '<i4'), ('f1', '<f8')])
>>> np.lib._iotools.easy_dtype("i4, f8", defaultfmt="field_%03i")
dtype([('field_000', '<i4'), ('field_001', '<f8')])

>>> np.lib._iotools.easy_dtype((int, float, float), names="a,b,c")
dtype([('a', '<i8'), ('b', '<f8'), ('c', '<f8')])
>>> np.lib._iotools.easy_dtype(float, names="a,b,c")
dtype([('a', '<f8'), ('b', '<f8'), ('c', '<f8')])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_ae64e910fdeae338f1f962ff03efb841e}\label{namespacenumpy_1_1lib_1_1__iotools_ae64e910fdeae338f1f962ff03efb841e}} 
\index{numpy\+::lib\+::\+\_\+iotools@{numpy\+::lib\+::\+\_\+iotools}!flatten\+\_\+dtype@{flatten\+\_\+dtype}}
\index{flatten\+\_\+dtype@{flatten\+\_\+dtype}!numpy\+::lib\+::\+\_\+iotools@{numpy\+::lib\+::\+\_\+iotools}}
\subsubsection{\texorpdfstring{flatten\+\_\+dtype()}{flatten\_dtype()}}
{\footnotesize\ttfamily def numpy.\+lib.\+\_\+iotools.\+flatten\+\_\+dtype (\begin{DoxyParamCaption}\item[{}]{ndtype,  }\item[{}]{flatten\+\_\+base = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Unpack a structured data-type by collapsing nested fields and/or fields
with a shape.

Note that the field names are lost.

Parameters
----------
ndtype : dtype
    The datatype to collapse
flatten_base : bool, optional
   If True, transform a field with a shape into several fields. Default is
   False.

Examples
--------
>>> dt = np.dtype([('name', 'S4'), ('x', float), ('y', float),
...                ('block', int, (2, 3))])
>>> np.lib._iotools.flatten_dtype(dt)
[dtype('S4'), dtype('float64'), dtype('float64'), dtype('int64')]
>>> np.lib._iotools.flatten_dtype(dt, flatten_base=True)
[dtype('S4'),
 dtype('float64'),
 dtype('float64'),
 dtype('int64'),
 dtype('int64'),
 dtype('int64'),
 dtype('int64'),
 dtype('int64'),
 dtype('int64')]\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_a963397b6c785faf85aa430b490365798}\label{namespacenumpy_1_1lib_1_1__iotools_a963397b6c785faf85aa430b490365798}} 
\index{numpy\+::lib\+::\+\_\+iotools@{numpy\+::lib\+::\+\_\+iotools}!has\+\_\+nested\+\_\+fields@{has\+\_\+nested\+\_\+fields}}
\index{has\+\_\+nested\+\_\+fields@{has\+\_\+nested\+\_\+fields}!numpy\+::lib\+::\+\_\+iotools@{numpy\+::lib\+::\+\_\+iotools}}
\subsubsection{\texorpdfstring{has\+\_\+nested\+\_\+fields()}{has\_nested\_fields()}}
{\footnotesize\ttfamily def numpy.\+lib.\+\_\+iotools.\+has\+\_\+nested\+\_\+fields (\begin{DoxyParamCaption}\item[{}]{ndtype }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns whether one or several fields of a dtype are nested.

Parameters
----------
ndtype : dtype
    Data-type of a structured array.

Raises
------
AttributeError
    If `ndtype` does not have a `names` attribute.

Examples
--------
>>> dt = np.dtype([('name', 'S4'), ('x', float), ('y', float)])
>>> np.lib._iotools.has_nested_fields(dt)
False\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1__iotools_a4ecb79a687b0f134273b11e96703f23f}\label{namespacenumpy_1_1lib_1_1__iotools_a4ecb79a687b0f134273b11e96703f23f}} 
\index{numpy\+::lib\+::\+\_\+iotools@{numpy\+::lib\+::\+\_\+iotools}!str2bool@{str2bool}}
\index{str2bool@{str2bool}!numpy\+::lib\+::\+\_\+iotools@{numpy\+::lib\+::\+\_\+iotools}}
\subsubsection{\texorpdfstring{str2bool()}{str2bool()}}
{\footnotesize\ttfamily def numpy.\+lib.\+\_\+iotools.\+str2bool (\begin{DoxyParamCaption}\item[{}]{value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Tries to transform a string supposed to represent a boolean to a boolean.

Parameters
----------
value : str
    The string that is transformed to a boolean.

Returns
-------
boolval : bool
    The boolean representation of `value`.

Raises
------
ValueError
    If the string is not 'True' or 'False' (case independent)

Examples
--------
>>> np.lib._iotools.str2bool('TRUE')
True
>>> np.lib._iotools.str2bool('false')
False\end{DoxyVerb}
 