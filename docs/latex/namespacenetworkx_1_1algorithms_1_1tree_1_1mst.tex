\hypertarget{namespacenetworkx_1_1algorithms_1_1tree_1_1mst}{}\section{networkx.\+algorithms.\+tree.\+mst Namespace Reference}
\label{namespacenetworkx_1_1algorithms_1_1tree_1_1mst}\index{networkx.\+algorithms.\+tree.\+mst@{networkx.\+algorithms.\+tree.\+mst}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_adc998046a90df96d250698a10380b53b}{boruvka\+\_\+mst\+\_\+edges} (G, minimum=True, weight=\char`\"{}weight\char`\"{}, keys=False, data=True, ignore\+\_\+nan=False)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a625cf66f46805703dd2c3fd26a33c689}{kruskal\+\_\+mst\+\_\+edges} (G, minimum, weight=\char`\"{}weight\char`\"{}, keys=True, data=True, ignore\+\_\+nan=False)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_afcb5cc4ca6b18390fbea4b2f2a64055b}{prim\+\_\+mst\+\_\+edges} (G, minimum, weight=\char`\"{}weight\char`\"{}, keys=True, data=True, ignore\+\_\+nan=False)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_ac8a6ab0fd620af1803b6ff0f2ade3898}{minimum\+\_\+spanning\+\_\+edges} (G, algorithm=\char`\"{}kruskal\char`\"{}, weight=\char`\"{}weight\char`\"{}, keys=True, data=True, ignore\+\_\+nan=False)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_affed092b6a627eb15629fe61ff1bec9d}{maximum\+\_\+spanning\+\_\+edges} (G, algorithm=\char`\"{}kruskal\char`\"{}, weight=\char`\"{}weight\char`\"{}, keys=True, data=True, ignore\+\_\+nan=False)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a50a0a335c8a2c0b9b52a659372939b48}{minimum\+\_\+spanning\+\_\+tree} (G, weight=\char`\"{}weight\char`\"{}, algorithm=\char`\"{}kruskal\char`\"{}, ignore\+\_\+nan=False)
\item 
def \hyperlink{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a990316971314e3505f15fc5b5976017a}{maximum\+\_\+spanning\+\_\+tree} (G, weight=\char`\"{}weight\char`\"{}, algorithm=\char`\"{}kruskal\char`\"{}, ignore\+\_\+nan=False)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a96a659ccaadb2fb6d06e9c3e7e702cec}{A\+L\+G\+O\+R\+I\+T\+H\+MS}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Algorithms for calculating min/max spanning trees/forests.\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_adc998046a90df96d250698a10380b53b}\label{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_adc998046a90df96d250698a10380b53b}} 
\index{networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}!boruvka\+\_\+mst\+\_\+edges@{boruvka\+\_\+mst\+\_\+edges}}
\index{boruvka\+\_\+mst\+\_\+edges@{boruvka\+\_\+mst\+\_\+edges}!networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}}
\subsubsection{\texorpdfstring{boruvka\+\_\+mst\+\_\+edges()}{boruvka\_mst\_edges()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+tree.\+mst.\+boruvka\+\_\+mst\+\_\+edges (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{minimum = {\ttfamily True},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{keys = {\ttfamily False},  }\item[{}]{data = {\ttfamily True},  }\item[{}]{ignore\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Iterate over edges of a Borůvka's algorithm min/max spanning tree.

Parameters
----------
G : NetworkX Graph
    The edges of `G` must have distinct weights,
    otherwise the edges may not form a tree.

minimum : bool (default: True)
    Find the minimum (True) or maximum (False) spanning tree.

weight : string (default: 'weight')
    The name of the edge attribute holding the edge weights.

keys : bool (default: True)
    This argument is ignored since this function is not
    implemented for multigraphs; it exists only for consistency
    with the other minimum spanning tree functions.

data : bool (default: True)
    Flag for whether to yield edge attribute dicts.
    If True, yield edges `(u, v, d)`, where `d` is the attribute dict.
    If False, yield edges `(u, v)`.

ignore_nan : bool (default: False)
    If a NaN is found as an edge weight normally an exception is raised.
    If `ignore_nan is True` then that edge is ignored instead.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a625cf66f46805703dd2c3fd26a33c689}\label{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a625cf66f46805703dd2c3fd26a33c689}} 
\index{networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}!kruskal\+\_\+mst\+\_\+edges@{kruskal\+\_\+mst\+\_\+edges}}
\index{kruskal\+\_\+mst\+\_\+edges@{kruskal\+\_\+mst\+\_\+edges}!networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}}
\subsubsection{\texorpdfstring{kruskal\+\_\+mst\+\_\+edges()}{kruskal\_mst\_edges()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+tree.\+mst.\+kruskal\+\_\+mst\+\_\+edges (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{minimum,  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{keys = {\ttfamily True},  }\item[{}]{data = {\ttfamily True},  }\item[{}]{ignore\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Iterate over edges of a Kruskal's algorithm min/max spanning tree.

Parameters
----------
G : NetworkX Graph
    The graph holding the tree of interest.

minimum : bool (default: True)
    Find the minimum (True) or maximum (False) spanning tree.

weight : string (default: 'weight')
    The name of the edge attribute holding the edge weights.

keys : bool (default: True)
    If `G` is a multigraph, `keys` controls whether edge keys ar yielded.
    Otherwise `keys` is ignored.

data : bool (default: True)
    Flag for whether to yield edge attribute dicts.
    If True, yield edges `(u, v, d)`, where `d` is the attribute dict.
    If False, yield edges `(u, v)`.

ignore_nan : bool (default: False)
    If a NaN is found as an edge weight normally an exception is raised.
    If `ignore_nan is True` then that edge is ignored instead.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_affed092b6a627eb15629fe61ff1bec9d}\label{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_affed092b6a627eb15629fe61ff1bec9d}} 
\index{networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}!maximum\+\_\+spanning\+\_\+edges@{maximum\+\_\+spanning\+\_\+edges}}
\index{maximum\+\_\+spanning\+\_\+edges@{maximum\+\_\+spanning\+\_\+edges}!networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}}
\subsubsection{\texorpdfstring{maximum\+\_\+spanning\+\_\+edges()}{maximum\_spanning\_edges()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+tree.\+mst.\+maximum\+\_\+spanning\+\_\+edges (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{algorithm = {\ttfamily \char`\"{}kruskal\char`\"{}},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{keys = {\ttfamily True},  }\item[{}]{data = {\ttfamily True},  }\item[{}]{ignore\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate edges in a maximum spanning forest of an undirected
weighted graph.

A maximum spanning tree is a subgraph of the graph (a tree)
with the maximum possible sum of edge weights.  A spanning forest is a
union of the spanning trees for each connected component of the graph.

Parameters
----------
G : undirected Graph
   An undirected graph. If `G` is connected, then the algorithm finds a
   spanning tree. Otherwise, a spanning forest is found.

algorithm : string
   The algorithm to use when finding a maximum spanning tree. Valid
   choices are 'kruskal', 'prim', or 'boruvka'. The default is 'kruskal'.

weight : string
   Edge data key to use for weight (default 'weight').

keys : bool
   Whether to yield edge key in multigraphs in addition to the edge.
   If `G` is not a multigraph, this is ignored.

data : bool, optional
   If True yield the edge data along with the edge.

ignore_nan : bool (default: False)
    If a NaN is found as an edge weight normally an exception is raised.
    If `ignore_nan is True` then that edge is ignored instead.

Returns
-------
edges : iterator
   An iterator over edges in a maximum spanning tree of `G`.
   Edges connecting nodes `u` and `v` are represented as tuples:
   `(u, v, k, d)` or `(u, v, k)` or `(u, v, d)` or `(u, v)`

   If `G` is a multigraph, `keys` indicates whether the edge key `k` will
   be reported in the third position in the edge tuple. `data` indicates
   whether the edge datadict `d` will appear at the end of the edge tuple.

   If `G` is not a multigraph, the tuples are `(u, v, d)` if `data` is True
   or `(u, v)` if `data` is False.

Examples
--------
>>> from networkx.algorithms import tree

Find maximum spanning edges by Kruskal's algorithm

>>> G = nx.cycle_graph(4)
>>> G.add_edge(0, 3, weight=2)
>>> mst = tree.maximum_spanning_edges(G, algorithm="kruskal", data=False)
>>> edgelist = list(mst)
>>> sorted(sorted(e) for e in edgelist)
[[0, 1], [0, 3], [1, 2]]

Find maximum spanning edges by Prim's algorithm

>>> G = nx.cycle_graph(4)
>>> G.add_edge(0, 3, weight=2)  # assign weight 2 to edge 0-3
>>> mst = tree.maximum_spanning_edges(G, algorithm="prim", data=False)
>>> edgelist = list(mst)
>>> sorted(sorted(e) for e in edgelist)
[[0, 1], [0, 3], [2, 3]]

Notes
-----
For Borůvka's algorithm, each edge must have a weight attribute, and
each edge weight must be distinct.

For the other algorithms, if the graph edges do not have a weight
attribute a default weight of 1 will be used.

Modified code from David Eppstein, April 2006
http://www.ics.uci.edu/~eppstein/PADS/
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a990316971314e3505f15fc5b5976017a}\label{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a990316971314e3505f15fc5b5976017a}} 
\index{networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}!maximum\+\_\+spanning\+\_\+tree@{maximum\+\_\+spanning\+\_\+tree}}
\index{maximum\+\_\+spanning\+\_\+tree@{maximum\+\_\+spanning\+\_\+tree}!networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}}
\subsubsection{\texorpdfstring{maximum\+\_\+spanning\+\_\+tree()}{maximum\_spanning\_tree()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+tree.\+mst.\+maximum\+\_\+spanning\+\_\+tree (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{algorithm = {\ttfamily \char`\"{}kruskal\char`\"{}},  }\item[{}]{ignore\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a maximum spanning tree or forest on an undirected graph `G`.

Parameters
----------
G : undirected graph
    An undirected graph. If `G` is connected, then the algorithm finds a
    spanning tree. Otherwise, a spanning forest is found.

weight : str
   Data key to use for edge weights.

algorithm : string
   The algorithm to use when finding a maximum spanning tree. Valid
   choices are 'kruskal', 'prim', or 'boruvka'. The default is
   'kruskal'.

ignore_nan : bool (default: False)
    If a NaN is found as an edge weight normally an exception is raised.
    If `ignore_nan is True` then that edge is ignored instead.


Returns
-------
G : NetworkX Graph
   A maximum spanning tree or forest.


Examples
--------
>>> G = nx.cycle_graph(4)
>>> G.add_edge(0, 3, weight=2)
>>> T = nx.maximum_spanning_tree(G)
>>> sorted(T.edges(data=True))
[(0, 1, {}), (0, 3, {'weight': 2}), (1, 2, {})]


Notes
-----
For Borůvka's algorithm, each edge must have a weight attribute, and
each edge weight must be distinct.

For the other algorithms, if the graph edges do not have a weight
attribute a default weight of 1 will be used.

There may be more than one tree with the same minimum or maximum weight.
See :mod:`networkx.tree.recognition` for more detailed definitions.

Isolated nodes with self-loops are in the tree as edgeless isolated nodes.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_ac8a6ab0fd620af1803b6ff0f2ade3898}\label{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_ac8a6ab0fd620af1803b6ff0f2ade3898}} 
\index{networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}!minimum\+\_\+spanning\+\_\+edges@{minimum\+\_\+spanning\+\_\+edges}}
\index{minimum\+\_\+spanning\+\_\+edges@{minimum\+\_\+spanning\+\_\+edges}!networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}}
\subsubsection{\texorpdfstring{minimum\+\_\+spanning\+\_\+edges()}{minimum\_spanning\_edges()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+tree.\+mst.\+minimum\+\_\+spanning\+\_\+edges (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{algorithm = {\ttfamily \char`\"{}kruskal\char`\"{}},  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{keys = {\ttfamily True},  }\item[{}]{data = {\ttfamily True},  }\item[{}]{ignore\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Generate edges in a minimum spanning forest of an undirected
weighted graph.

A minimum spanning tree is a subgraph of the graph (a tree)
with the minimum sum of edge weights.  A spanning forest is a
union of the spanning trees for each connected component of the graph.

Parameters
----------
G : undirected Graph
   An undirected graph. If `G` is connected, then the algorithm finds a
   spanning tree. Otherwise, a spanning forest is found.

algorithm : string
   The algorithm to use when finding a minimum spanning tree. Valid
   choices are 'kruskal', 'prim', or 'boruvka'. The default is 'kruskal'.

weight : string
   Edge data key to use for weight (default 'weight').

keys : bool
   Whether to yield edge key in multigraphs in addition to the edge.
   If `G` is not a multigraph, this is ignored.

data : bool, optional
   If True yield the edge data along with the edge.

ignore_nan : bool (default: False)
    If a NaN is found as an edge weight normally an exception is raised.
    If `ignore_nan is True` then that edge is ignored instead.

Returns
-------
edges : iterator
   An iterator over edges in a maximum spanning tree of `G`.
   Edges connecting nodes `u` and `v` are represented as tuples:
   `(u, v, k, d)` or `(u, v, k)` or `(u, v, d)` or `(u, v)`

   If `G` is a multigraph, `keys` indicates whether the edge key `k` will
   be reported in the third position in the edge tuple. `data` indicates
   whether the edge datadict `d` will appear at the end of the edge tuple.

   If `G` is not a multigraph, the tuples are `(u, v, d)` if `data` is True
   or `(u, v)` if `data` is False.

Examples
--------
>>> from networkx.algorithms import tree

Find minimum spanning edges by Kruskal's algorithm

>>> G = nx.cycle_graph(4)
>>> G.add_edge(0, 3, weight=2)
>>> mst = tree.minimum_spanning_edges(G, algorithm="kruskal", data=False)
>>> edgelist = list(mst)
>>> sorted(sorted(e) for e in edgelist)
[[0, 1], [1, 2], [2, 3]]

Find minimum spanning edges by Prim's algorithm

>>> G = nx.cycle_graph(4)
>>> G.add_edge(0, 3, weight=2)
>>> mst = tree.minimum_spanning_edges(G, algorithm="prim", data=False)
>>> edgelist = list(mst)
>>> sorted(sorted(e) for e in edgelist)
[[0, 1], [1, 2], [2, 3]]

Notes
-----
For Borůvka's algorithm, each edge must have a weight attribute, and
each edge weight must be distinct.

For the other algorithms, if the graph edges do not have a weight
attribute a default weight of 1 will be used.

Modified code from David Eppstein, April 2006
http://www.ics.uci.edu/~eppstein/PADS/\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a50a0a335c8a2c0b9b52a659372939b48}\label{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a50a0a335c8a2c0b9b52a659372939b48}} 
\index{networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}!minimum\+\_\+spanning\+\_\+tree@{minimum\+\_\+spanning\+\_\+tree}}
\index{minimum\+\_\+spanning\+\_\+tree@{minimum\+\_\+spanning\+\_\+tree}!networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}}
\subsubsection{\texorpdfstring{minimum\+\_\+spanning\+\_\+tree()}{minimum\_spanning\_tree()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+tree.\+mst.\+minimum\+\_\+spanning\+\_\+tree (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{algorithm = {\ttfamily \char`\"{}kruskal\char`\"{}},  }\item[{}]{ignore\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a minimum spanning tree or forest on an undirected graph `G`.

Parameters
----------
G : undirected graph
    An undirected graph. If `G` is connected, then the algorithm finds a
    spanning tree. Otherwise, a spanning forest is found.

weight : str
   Data key to use for edge weights.

algorithm : string
   The algorithm to use when finding a minimum spanning tree. Valid
   choices are 'kruskal', 'prim', or 'boruvka'. The default is
   'kruskal'.

ignore_nan : bool (default: False)
    If a NaN is found as an edge weight normally an exception is raised.
    If `ignore_nan is True` then that edge is ignored instead.

Returns
-------
G : NetworkX Graph
   A minimum spanning tree or forest.

Examples
--------
>>> G = nx.cycle_graph(4)
>>> G.add_edge(0, 3, weight=2)
>>> T = nx.minimum_spanning_tree(G)
>>> sorted(T.edges(data=True))
[(0, 1, {}), (1, 2, {}), (2, 3, {})]


Notes
-----
For Borůvka's algorithm, each edge must have a weight attribute, and
each edge weight must be distinct.

For the other algorithms, if the graph edges do not have a weight
attribute a default weight of 1 will be used.

There may be more than one tree with the same minimum or maximum weight.
See :mod:`networkx.tree.recognition` for more detailed definitions.

Isolated nodes with self-loops are in the tree as edgeless isolated nodes.\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_afcb5cc4ca6b18390fbea4b2f2a64055b}\label{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_afcb5cc4ca6b18390fbea4b2f2a64055b}} 
\index{networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}!prim\+\_\+mst\+\_\+edges@{prim\+\_\+mst\+\_\+edges}}
\index{prim\+\_\+mst\+\_\+edges@{prim\+\_\+mst\+\_\+edges}!networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}}
\subsubsection{\texorpdfstring{prim\+\_\+mst\+\_\+edges()}{prim\_mst\_edges()}}
{\footnotesize\ttfamily def networkx.\+algorithms.\+tree.\+mst.\+prim\+\_\+mst\+\_\+edges (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{minimum,  }\item[{}]{weight = {\ttfamily \char`\"{}weight\char`\"{}},  }\item[{}]{keys = {\ttfamily True},  }\item[{}]{data = {\ttfamily True},  }\item[{}]{ignore\+\_\+nan = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Iterate over edges of Prim's algorithm min/max spanning tree.

Parameters
----------
G : NetworkX Graph
    The graph holding the tree of interest.

minimum : bool (default: True)
    Find the minimum (True) or maximum (False) spanning tree.

weight : string (default: 'weight')
    The name of the edge attribute holding the edge weights.

keys : bool (default: True)
    If `G` is a multigraph, `keys` controls whether edge keys ar yielded.
    Otherwise `keys` is ignored.

data : bool (default: True)
    Flag for whether to yield edge attribute dicts.
    If True, yield edges `(u, v, d)`, where `d` is the attribute dict.
    If False, yield edges `(u, v)`.

ignore_nan : bool (default: False)
    If a NaN is found as an edge weight normally an exception is raised.
    If `ignore_nan is True` then that edge is ignored instead.\end{DoxyVerb}
 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a96a659ccaadb2fb6d06e9c3e7e702cec}\label{namespacenetworkx_1_1algorithms_1_1tree_1_1mst_a96a659ccaadb2fb6d06e9c3e7e702cec}} 
\index{networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}!A\+L\+G\+O\+R\+I\+T\+H\+MS@{A\+L\+G\+O\+R\+I\+T\+H\+MS}}
\index{A\+L\+G\+O\+R\+I\+T\+H\+MS@{A\+L\+G\+O\+R\+I\+T\+H\+MS}!networkx\+::algorithms\+::tree\+::mst@{networkx\+::algorithms\+::tree\+::mst}}
\subsubsection{\texorpdfstring{A\+L\+G\+O\+R\+I\+T\+H\+MS}{ALGORITHMS}}
{\footnotesize\ttfamily networkx.\+algorithms.\+tree.\+mst.\+A\+L\+G\+O\+R\+I\+T\+H\+MS}

