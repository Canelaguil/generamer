\hypertarget{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom}{}\section{matplotlib.\+tri.\+triinterpolate.\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom Class Reference}
\label{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom}\index{matplotlib.\+tri.\+triinterpolate.\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom@{matplotlib.\+tri.\+triinterpolate.\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom}}


Inheritance diagram for matplotlib.\+tri.\+triinterpolate.\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=209pt]{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for matplotlib.\+tri.\+triinterpolate.\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=209pt]{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom_affbd1a1763ce76316a123fb9f15f6cdb}{compute\+\_\+dz} (self)
\item 
def \hyperlink{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom_a16ec5b0c62ead2e5c291a8285ebdbf64}{compute\+\_\+geom\+\_\+weights} (self)
\item 
def \hyperlink{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom_a3b459fb71ceda04299deddac8f6283c4}{compute\+\_\+geom\+\_\+grads} (self)
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\begin{DoxyVerb}Fast 'geometric' approximation, recommended for large arrays.\end{DoxyVerb}
 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom_affbd1a1763ce76316a123fb9f15f6cdb}\label{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom_affbd1a1763ce76316a123fb9f15f6cdb}} 
\index{matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom@{matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom}!compute\+\_\+dz@{compute\+\_\+dz}}
\index{compute\+\_\+dz@{compute\+\_\+dz}!matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom@{matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom}}
\subsubsection{\texorpdfstring{compute\+\_\+dz()}{compute\_dz()}}
{\footnotesize\ttfamily def matplotlib.\+tri.\+triinterpolate.\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom.\+compute\+\_\+dz (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}self.df is computed as weighted average of _triangles sharing a common
node. On each triangle itri f is first assumed linear (= ~f), which
allows to compute d~f[itri]
Then the following approximation of df nodal values is then proposed:
    f[ipt] = SUM ( w[itri] x d~f[itri] , for itri sharing apex ipt)
The weighted coeff. w[itri] are proportional to the angle of the
triangle itri at apex ipt
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom_a3b459fb71ceda04299deddac8f6283c4}\label{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom_a3b459fb71ceda04299deddac8f6283c4}} 
\index{matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom@{matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom}!compute\+\_\+geom\+\_\+grads@{compute\+\_\+geom\+\_\+grads}}
\index{compute\+\_\+geom\+\_\+grads@{compute\+\_\+geom\+\_\+grads}!matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom@{matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom}}
\subsubsection{\texorpdfstring{compute\+\_\+geom\+\_\+grads()}{compute\_geom\_grads()}}
{\footnotesize\ttfamily def matplotlib.\+tri.\+triinterpolate.\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom.\+compute\+\_\+geom\+\_\+grads (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute the (global) gradient component of f assumed linear (~f).
returns array df of shape (nelems, 2)
df[ielem].dM[ielem] = dz[ielem] i.e. df = dz x dM = dM.T^-1 x dz
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom_a16ec5b0c62ead2e5c291a8285ebdbf64}\label{classmatplotlib_1_1tri_1_1triinterpolate_1_1__DOF__estimator__geom_a16ec5b0c62ead2e5c291a8285ebdbf64}} 
\index{matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom@{matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom}!compute\+\_\+geom\+\_\+weights@{compute\+\_\+geom\+\_\+weights}}
\index{compute\+\_\+geom\+\_\+weights@{compute\+\_\+geom\+\_\+weights}!matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom@{matplotlib\+::tri\+::triinterpolate\+::\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom}}
\subsubsection{\texorpdfstring{compute\+\_\+geom\+\_\+weights()}{compute\_geom\_weights()}}
{\footnotesize\ttfamily def matplotlib.\+tri.\+triinterpolate.\+\_\+\+D\+O\+F\+\_\+estimator\+\_\+geom.\+compute\+\_\+geom\+\_\+weights (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Build the (nelems, 3) weights coeffs of _triangles angles,
renormalized so that np.sum(weights, axis=1) == np.ones(nelems)
\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
venv/lib/python3.\+9/site-\/packages/matplotlib/tri/\hyperlink{triinterpolate_8py}{triinterpolate.\+py}\end{DoxyCompactItemize}
