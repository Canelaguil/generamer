\hypertarget{classmatplotlib_1_1path_1_1Path}{}\section{matplotlib.\+path.\+Path Class Reference}
\label{classmatplotlib_1_1path_1_1Path}\index{matplotlib.\+path.\+Path@{matplotlib.\+path.\+Path}}


Inheritance diagram for matplotlib.\+path.\+Path\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=220pt]{classmatplotlib_1_1path_1_1Path__inherit__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_af8e0afa74a11ecee7181f3a873fa9428}{\+\_\+\+\_\+init\+\_\+\+\_\+} (self, \hyperlink{classmatplotlib_1_1path_1_1Path_a16d8c6332dee86b7ccd33eda804c5943}{vertices}, \hyperlink{classmatplotlib_1_1path_1_1Path_aee6db254a0fd529648c4c1d7d427f637}{codes}=None, \+\_\+interpolation\+\_\+steps=1, closed=False, \hyperlink{classmatplotlib_1_1path_1_1Path_aaed6949dcf8a429992d3056abf8e2bc8}{readonly}=False)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a16d8c6332dee86b7ccd33eda804c5943}{vertices} (self)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a9fb4403d765b7c184105742f91300db9}{vertices} (self, vertices)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_aee6db254a0fd529648c4c1d7d427f637}{codes} (self)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_ae94bddf115167ef56631291d82946e5e}{codes} (self, codes)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a8cd5b4312362adf7f2cf937bdab1c177}{simplify\+\_\+threshold} (self)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_aaf9de7febc75199ff89ebec8a0e295d6}{simplify\+\_\+threshold} (self, threshold)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_ac6c55e72a1c976f2d7a5d59aea72428d}{should\+\_\+simplify} (self)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a90f9d1a0e75bd36f6e2183d2897a4fab}{should\+\_\+simplify} (self, should\+\_\+simplify)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_aaed6949dcf8a429992d3056abf8e2bc8}{readonly} (self)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a3d005b67cbba55a28f08072ef82887c7}{\+\_\+\+\_\+copy\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a14a6e83724ed670db368be135dffb704}{\+\_\+\+\_\+deepcopy\+\_\+\+\_\+} (self, memo=None)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a082efc37cf9eaabafb4e1300fa2ed7df}{make\+\_\+compound\+\_\+path\+\_\+from\+\_\+polys} (cls, XY)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a7d24e4d289747430ff11d550d89be076}{make\+\_\+compound\+\_\+path} (cls, args)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a09fbe795ff19e1f7c646f5c9e7a936ba}{\+\_\+\+\_\+repr\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a068953400e461d8790541cb2ab31df96}{\+\_\+\+\_\+len\+\_\+\+\_\+} (self)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a350ad8cb300705d284206e471a2776ab}{iter\+\_\+segments} (self, transform=None, remove\+\_\+nans=True, clip=None, snap=False, stroke\+\_\+width=1.\+0, simplify=None, curves=True, sketch=None)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a94de6154f565d95e26c57eab8aeec81e}{iter\+\_\+bezier} (self, kwargs)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_abce61e4078ff3c4d78f453cfa2295330}{cleaned} (self, transform=None, remove\+\_\+nans=False, clip=None, quantize=False, simplify=False, curves=False, stroke\+\_\+width=1.\+0, snap=False, sketch=None)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_acbbb3e1212913372ed4f428314404c92}{transformed} (self, transform)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a4e421167fb76e408649b79f4ba4f11f5}{contains\+\_\+point} (self, point, transform=None, radius=0.\+0)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a0a8e16efd366cb77c64aeda4de05444d}{contains\+\_\+points} (self, points, transform=None, radius=0.\+0)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_aff9468aab8094f1dff2fa551c60297a5}{contains\+\_\+path} (self, path, transform=None)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_ab62f364556740604c202f1453184212c}{get\+\_\+extents} (self, transform=None, kwargs)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a6281e51d8ac1a760cadc0c8209a7da9d}{intersects\+\_\+path} (self, other, filled=True)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a7fe543c6509ef4d0896638c9284d9274}{intersects\+\_\+bbox} (self, bbox, filled=True)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_aa92af2b6ec93ee82dcf60757ef308f00}{interpolated} (self, steps)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a8bc3f213058dc56411ad019efbe74acb}{to\+\_\+polygons} (self, transform=None, width=0, height=0, closed\+\_\+only=True)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a57ee8ff0d3ce3c4fd418b88185881bcd}{unit\+\_\+rectangle} (cls)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a922129b6b590f2a951baa32c1615f110}{unit\+\_\+regular\+\_\+polygon} (cls, num\+Vertices)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_ae2b4fc8eeb290b8708e80a7a0c159f26}{unit\+\_\+regular\+\_\+star} (cls, num\+Vertices, inner\+Circle=0.\+5)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a34d0d3657f364ed9e06190c8a0efea7a}{unit\+\_\+regular\+\_\+asterisk} (cls, num\+Vertices)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a8e59114bca03a98af3c350a61eb0e6fc}{unit\+\_\+circle} (cls)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a2e8e8b67f94962b815605930f7a79789}{circle} (cls, center=(0., 0.), radius=1., \hyperlink{classmatplotlib_1_1path_1_1Path_aaed6949dcf8a429992d3056abf8e2bc8}{readonly}=False)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a54b3bec2a795959ce6ddeeb5d30a6db3}{unit\+\_\+circle\+\_\+righthalf} (cls)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a831c0ae14915703ed6f7a45d761dbf71}{arc} (cls, theta1, theta2, n=None, is\+\_\+wedge=False)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_ae2412176d4ed34f94addd95f00ffa696}{wedge} (cls, theta1, theta2, n=None)
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a9cadda4af3011a672a4c2bde5f396446}{clip\+\_\+to\+\_\+bbox} (self, bbox, inside=True)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classmatplotlib_1_1path_1_1Path_a974fa9fa2569e5e79ef9bc3adf3a2e4a}{hatch} (hatchpattern, density=6)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_a89ee1cccd6a24fe1f278d18d77d84438}{code\+\_\+type}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_a9c0f0350d40f9d676f842f7a191cea97}{S\+T\+OP}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_ab9e9c539ff8aa6ea04fbe89d48e20221}{M\+O\+V\+E\+TO}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_af32d8730490de4520b4ef5d4b4a85a96}{L\+I\+N\+E\+TO}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_a8fd69ee9fc2a1051a8d67d12910bab4e}{C\+U\+R\+V\+E3}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_aec98baae7ae38e7a0ae680fc945f051e}{C\+U\+R\+V\+E4}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_a02575b90932a2331c8e95fce7b11848c}{C\+L\+O\+S\+E\+P\+O\+LY}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_a2a774a55a2a3a2a45aee32b83609f36e}{N\+U\+M\+\_\+\+V\+E\+R\+T\+I\+C\+E\+S\+\_\+\+F\+O\+R\+\_\+\+C\+O\+DE}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_a1d7b1c4c674a0f49a14a8e63cb077d80}{copy}
\item 
\hyperlink{classmatplotlib_1_1path_1_1Path_ae9b78245ec8753fe8b5c84755a5f36f3}{deepcopy}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}A series of possibly disconnected, possibly closed, line and curve
segments.

The underlying storage is made up of two parallel numpy arrays:

- *vertices*: an Nx2 float array of vertices
- *codes*: an N-length uint8 array of vertex types, or None

These two arrays always have the same length in the first
dimension.  For example, to represent a cubic curve, you must
provide three vertices as well as three codes ``CURVE3``.

The code types are:

- ``STOP``   :  1 vertex (ignored)
    A marker for the end of the entire path (currently not required and
    ignored)

- ``MOVETO`` :  1 vertex
    Pick up the pen and move to the given vertex.

- ``LINETO`` :  1 vertex
    Draw a line from the current position to the given vertex.

- ``CURVE3`` :  1 control point, 1 endpoint
    Draw a quadratic Bezier curve from the current position, with the given
    control point, to the given end point.

- ``CURVE4`` :  2 control points, 1 endpoint
    Draw a cubic Bezier curve from the current position, with the given
    control points, to the given end point.

- ``CLOSEPOLY`` : 1 vertex (ignored)
    Draw a line segment to the start point of the current polyline.

If *codes* is None, it is interpreted as a ``MOVETO`` followed by a series
of ``LINETO``.

Users of Path objects should not access the vertices and codes arrays
directly.  Instead, they should use `iter_segments` or `cleaned` to get the
vertex/code pairs.  This helps, in particular, to consistently handle the
case of *codes* being None.

Some behavior of Path objects can be controlled by rcParams. See the
rcParams whose keys start with 'path.'.

.. note::

    The vertices and codes arrays should be treated as
    immutable -- there are a number of optimizations and assumptions
    made up front in the constructor that will not change when the
    data changes.
\end{DoxyVerb}
 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_af8e0afa74a11ecee7181f3a873fa9428}\label{classmatplotlib_1_1path_1_1Path_af8e0afa74a11ecee7181f3a873fa9428}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+init\+\_\+\+\_\+()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{vertices,  }\item[{}]{codes = {\ttfamily None},  }\item[{}]{\+\_\+interpolation\+\_\+steps = {\ttfamily 1},  }\item[{}]{closed = {\ttfamily False},  }\item[{}]{readonly = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Create a new path with the given vertices and codes.

Parameters
----------
vertices : (N, 2) array-like
    The path vertices, as an array, masked array or sequence of pairs.
    Masked values, if any, will be converted to NaNs, which are then
    handled correctly by the Agg PathIterator and other consumers of
    path data, such as :meth:`iter_segments`.
codes : array-like or None, optional
    n-length array integers representing the codes of the path.
    If not None, codes must be the same length as vertices.
    If None, *vertices* will be treated as a series of line segments.
_interpolation_steps : int, optional
    Used as a hint to certain projections, such as Polar, that this
    path should be linearly interpolated immediately before drawing.
    This attribute is primarily an implementation detail and is not
    intended for public use.
closed : bool, optional
    If *codes* is None and closed is True, vertices will be treated as
    line segments of a closed polygon.  Note that the last vertex will
    then be ignored (as the corresponding code will be set to
    CLOSEPOLY).
readonly : bool, optional
    Makes the path behave in an immutable way and sets the vertices
    and codes as read-only arrays.
\end{DoxyVerb}
 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a3d005b67cbba55a28f08072ef82887c7}\label{classmatplotlib_1_1path_1_1Path_a3d005b67cbba55a28f08072ef82887c7}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!\+\_\+\+\_\+copy\+\_\+\+\_\+@{\+\_\+\+\_\+copy\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+copy\+\_\+\+\_\+@{\+\_\+\+\_\+copy\+\_\+\+\_\+}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+copy\+\_\+\+\_\+()}{\_\_copy\_\_()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+\_\+\+\_\+copy\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a shallow copy of the `Path`, which will share the
vertices and codes with the source `Path`.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a14a6e83724ed670db368be135dffb704}\label{classmatplotlib_1_1path_1_1Path_a14a6e83724ed670db368be135dffb704}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!\+\_\+\+\_\+deepcopy\+\_\+\+\_\+@{\+\_\+\+\_\+deepcopy\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+deepcopy\+\_\+\+\_\+@{\+\_\+\+\_\+deepcopy\+\_\+\+\_\+}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+deepcopy\+\_\+\+\_\+()}{\_\_deepcopy\_\_()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+\_\+\+\_\+deepcopy\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{memo = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a deepcopy of the `Path`.  The `Path` will not be
readonly, even if the source `Path` is.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a068953400e461d8790541cb2ab31df96}\label{classmatplotlib_1_1path_1_1Path_a068953400e461d8790541cb2ab31df96}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!\+\_\+\+\_\+len\+\_\+\+\_\+@{\+\_\+\+\_\+len\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+len\+\_\+\+\_\+@{\+\_\+\+\_\+len\+\_\+\+\_\+}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+len\+\_\+\+\_\+()}{\_\_len\_\_()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+\_\+\+\_\+len\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a09fbe795ff19e1f7c646f5c9e7a936ba}\label{classmatplotlib_1_1path_1_1Path_a09fbe795ff19e1f7c646f5c9e7a936ba}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!\+\_\+\+\_\+repr\+\_\+\+\_\+@{\+\_\+\+\_\+repr\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+repr\+\_\+\+\_\+@{\+\_\+\+\_\+repr\+\_\+\+\_\+}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+repr\+\_\+\+\_\+()}{\_\_repr\_\_()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+\_\+\+\_\+repr\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a831c0ae14915703ed6f7a45d761dbf71}\label{classmatplotlib_1_1path_1_1Path_a831c0ae14915703ed6f7a45d761dbf71}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!arc@{arc}}
\index{arc@{arc}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{arc()}{arc()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+arc (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{theta1,  }\item[{}]{theta2,  }\item[{}]{n = {\ttfamily None},  }\item[{}]{is\+\_\+wedge = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the unit circle arc from angles *theta1* to *theta2* (in
degrees).

*theta2* is unwrapped to produce the shortest arc within 360 degrees.
That is, if *theta2* > *theta1* + 360, the arc will be from *theta1* to
*theta2* - 360 and not a full circle plus some extra overlap.

If *n* is provided, it is the number of spline segments to make.
If *n* is not provided, the number of spline segments is
determined based on the delta between *theta1* and *theta2*.

   Masionobe, L.  2003.  `Drawing an elliptical arc using
   polylines, quadratic or cubic Bezier curves
   <http://www.spaceroots.org/documents/ellipse/index.html>`_.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a2e8e8b67f94962b815605930f7a79789}\label{classmatplotlib_1_1path_1_1Path_a2e8e8b67f94962b815605930f7a79789}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!circle@{circle}}
\index{circle@{circle}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{circle()}{circle()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+circle (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{center = {\ttfamily (0.,~0.)},  }\item[{}]{radius = {\ttfamily 1.},  }\item[{}]{readonly = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a `Path` representing a circle of a given radius and center.

Parameters
----------
center : (float, float), default: (0, 0)
    The center of the circle.
radius : float, default: 1
    The radius of the circle.
readonly : bool
    Whether the created path should have the "readonly" argument
    set when creating the Path instance.

Notes
-----
The circle is approximated using 8 cubic Bezier curves, as described in

  Lancaster, Don.  `Approximating a Circle or an Ellipse Using Four
  Bezier Cubic Splines <https://www.tinaja.com/glib/ellipse4.pdf>`_.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_abce61e4078ff3c4d78f453cfa2295330}\label{classmatplotlib_1_1path_1_1Path_abce61e4078ff3c4d78f453cfa2295330}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!cleaned@{cleaned}}
\index{cleaned@{cleaned}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{cleaned()}{cleaned()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+cleaned (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{transform = {\ttfamily None},  }\item[{}]{remove\+\_\+nans = {\ttfamily False},  }\item[{}]{clip = {\ttfamily None},  }\item[{}]{quantize = {\ttfamily False},  }\item[{}]{simplify = {\ttfamily False},  }\item[{}]{curves = {\ttfamily False},  }\item[{}]{stroke\+\_\+width = {\ttfamily 1.0},  }\item[{}]{snap = {\ttfamily False},  }\item[{}]{sketch = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a new Path with vertices and codes cleaned according to the
parameters.

See Also
--------
Path.iter_segments : for details of the keyword arguments.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a9cadda4af3011a672a4c2bde5f396446}\label{classmatplotlib_1_1path_1_1Path_a9cadda4af3011a672a4c2bde5f396446}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!clip\+\_\+to\+\_\+bbox@{clip\+\_\+to\+\_\+bbox}}
\index{clip\+\_\+to\+\_\+bbox@{clip\+\_\+to\+\_\+bbox}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{clip\+\_\+to\+\_\+bbox()}{clip\_to\_bbox()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+clip\+\_\+to\+\_\+bbox (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{bbox,  }\item[{}]{inside = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Clip the path to the given bounding box.

The path must be made up of one or more closed polygons.  This
algorithm will not behave correctly for unclosed paths.

If *inside* is `True`, clip to the inside of the box, otherwise
to the outside of the box.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_aee6db254a0fd529648c4c1d7d427f637}\label{classmatplotlib_1_1path_1_1Path_aee6db254a0fd529648c4c1d7d427f637}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!codes@{codes}}
\index{codes@{codes}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{codes()}{codes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+codes (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}The list of codes in the `Path` as a 1D numpy array.  Each
code is one of `STOP`, `MOVETO`, `LINETO`, `CURVE3`, `CURVE4`
or `CLOSEPOLY`.  For codes that correspond to more than one
vertex (`CURVE3` and `CURVE4`), that code will be repeated so
that the length of `self.vertices` and `self.codes` is always
the same.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_ae94bddf115167ef56631291d82946e5e}\label{classmatplotlib_1_1path_1_1Path_ae94bddf115167ef56631291d82946e5e}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!codes@{codes}}
\index{codes@{codes}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{codes()}{codes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+codes (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{codes }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_aff9468aab8094f1dff2fa551c60297a5}\label{classmatplotlib_1_1path_1_1Path_aff9468aab8094f1dff2fa551c60297a5}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!contains\+\_\+path@{contains\+\_\+path}}
\index{contains\+\_\+path@{contains\+\_\+path}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{contains\+\_\+path()}{contains\_path()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+contains\+\_\+path (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{path,  }\item[{}]{transform = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return whether this (closed) path completely contains the given path.

If *transform* is not ``None``, the path will be transformed before
checking for containment.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a4e421167fb76e408649b79f4ba4f11f5}\label{classmatplotlib_1_1path_1_1Path_a4e421167fb76e408649b79f4ba4f11f5}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!contains\+\_\+point@{contains\+\_\+point}}
\index{contains\+\_\+point@{contains\+\_\+point}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{contains\+\_\+point()}{contains\_point()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+contains\+\_\+point (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{point,  }\item[{}]{transform = {\ttfamily None},  }\item[{}]{radius = {\ttfamily 0.0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return whether the area enclosed by the path contains the given point.

The path is always treated as closed; i.e. if the last code is not
CLOSEPOLY an implicit segment connecting the last vertex to the first
vertex is assumed.

Parameters
----------
point : (float, float)
    The point (x, y) to check.
transform : `matplotlib.transforms.Transform`, optional
    If not ``None``, *point* will be compared to ``self`` transformed
    by *transform*; i.e. for a correct check, *transform* should
    transform the path into the coordinate system of *point*.
radius : float, default: 0
    Add an additional margin on the path in coordinates of *point*.
    The path is extended tangentially by *radius/2*; i.e. if you would
    draw the path with a linewidth of *radius*, all points on the line
    would still be considered to be contained in the area. Conversely,
    negative values shrink the area: Points on the imaginary line
    will be considered outside the area.

Returns
-------
bool

Notes
-----
The current algorithm has some limitations:

- The result is undefined for points exactly at the boundary
  (i.e. at the path shifted by *radius/2*).
- The result is undefined if there is no enclosed area, i.e. all
  vertices are on a straight line.
- If bounding lines start to cross each other due to *radius* shift,
  the result is not guaranteed to be correct.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a0a8e16efd366cb77c64aeda4de05444d}\label{classmatplotlib_1_1path_1_1Path_a0a8e16efd366cb77c64aeda4de05444d}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!contains\+\_\+points@{contains\+\_\+points}}
\index{contains\+\_\+points@{contains\+\_\+points}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{contains\+\_\+points()}{contains\_points()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+contains\+\_\+points (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{points,  }\item[{}]{transform = {\ttfamily None},  }\item[{}]{radius = {\ttfamily 0.0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return whether the area enclosed by the path contains the given points.

The path is always treated as closed; i.e. if the last code is not
CLOSEPOLY an implicit segment connecting the last vertex to the first
vertex is assumed.

Parameters
----------
points : (N, 2) array
    The points to check. Columns contain x and y values.
transform : `matplotlib.transforms.Transform`, optional
    If not ``None``, *points* will be compared to ``self`` transformed
    by *transform*; i.e. for a correct check, *transform* should
    transform the path into the coordinate system of *points*.
radius : float, default: 0
    Add an additional margin on the path in coordinates of *points*.
    The path is extended tangentially by *radius/2*; i.e. if you would
    draw the path with a linewidth of *radius*, all points on the line
    would still be considered to be contained in the area. Conversely,
    negative values shrink the area: Points on the imaginary line
    will be considered outside the area.

Returns
-------
length-N bool array

Notes
-----
The current algorithm has some limitations:

- The result is undefined for points exactly at the boundary
  (i.e. at the path shifted by *radius/2*).
- The result is undefined if there is no enclosed area, i.e. all
  vertices are on a straight line.
- If bounding lines start to cross each other due to *radius* shift,
  the result is not guaranteed to be correct.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_ab62f364556740604c202f1453184212c}\label{classmatplotlib_1_1path_1_1Path_ab62f364556740604c202f1453184212c}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!get\+\_\+extents@{get\+\_\+extents}}
\index{get\+\_\+extents@{get\+\_\+extents}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{get\+\_\+extents()}{get\_extents()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+get\+\_\+extents (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{transform = {\ttfamily None},  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Get Bbox of the path.

Parameters
----------
transform : matplotlib.transforms.Transform, optional
    Transform to apply to path before computing extents, if any.
**kwargs
    Forwarded to `.iter_bezier`.

Returns
-------
matplotlib.transforms.Bbox
    The extents of the path Bbox([[xmin, ymin], [xmax, ymax]])
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a974fa9fa2569e5e79ef9bc3adf3a2e4a}\label{classmatplotlib_1_1path_1_1Path_a974fa9fa2569e5e79ef9bc3adf3a2e4a}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!hatch@{hatch}}
\index{hatch@{hatch}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{hatch()}{hatch()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+hatch (\begin{DoxyParamCaption}\item[{}]{hatchpattern,  }\item[{}]{density = {\ttfamily 6} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

\begin{DoxyVerb}Given a hatch specifier, *hatchpattern*, generates a Path that
can be used in a repeated hatching pattern.  *density* is the
number of lines per unit square.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_aa92af2b6ec93ee82dcf60757ef308f00}\label{classmatplotlib_1_1path_1_1Path_aa92af2b6ec93ee82dcf60757ef308f00}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!interpolated@{interpolated}}
\index{interpolated@{interpolated}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{interpolated()}{interpolated()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+interpolated (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{steps }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a new path resampled to length N x steps.

Codes other than LINETO are not handled correctly.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a7fe543c6509ef4d0896638c9284d9274}\label{classmatplotlib_1_1path_1_1Path_a7fe543c6509ef4d0896638c9284d9274}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!intersects\+\_\+bbox@{intersects\+\_\+bbox}}
\index{intersects\+\_\+bbox@{intersects\+\_\+bbox}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{intersects\+\_\+bbox()}{intersects\_bbox()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+intersects\+\_\+bbox (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{bbox,  }\item[{}]{filled = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return whether this path intersects a given `~.transforms.Bbox`.

If *filled* is True, then this also returns True if the path completely
encloses the `.Bbox` (i.e., the path is treated as filled).

The bounding box is always considered filled.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a6281e51d8ac1a760cadc0c8209a7da9d}\label{classmatplotlib_1_1path_1_1Path_a6281e51d8ac1a760cadc0c8209a7da9d}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!intersects\+\_\+path@{intersects\+\_\+path}}
\index{intersects\+\_\+path@{intersects\+\_\+path}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{intersects\+\_\+path()}{intersects\_path()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+intersects\+\_\+path (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{other,  }\item[{}]{filled = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return whether if this path intersects another given path.

If *filled* is True, then this also returns True if one path completely
encloses the other (i.e., the paths are treated as filled).
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a94de6154f565d95e26c57eab8aeec81e}\label{classmatplotlib_1_1path_1_1Path_a94de6154f565d95e26c57eab8aeec81e}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!iter\+\_\+bezier@{iter\+\_\+bezier}}
\index{iter\+\_\+bezier@{iter\+\_\+bezier}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{iter\+\_\+bezier()}{iter\_bezier()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+iter\+\_\+bezier (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Iterate over each bezier curve (lines included) in a Path.

Parameters
----------
**kwargs
    Forwarded to `.iter_segments`.

Yields
------
B : matplotlib.bezier.BezierSegment
    The bezier curves that make up the current path. Note in particular
    that freestanding points are bezier curves of order 0, and lines
    are bezier curves of order 1 (with two control points).
code : Path.code_type
    The code describing what kind of curve is being returned.
    Path.MOVETO, Path.LINETO, Path.CURVE3, Path.CURVE4 correspond to
    bezier curves with 1, 2, 3, and 4 control points (respectively).
    Path.CLOSEPOLY is a Path.LINETO with the control points correctly
    chosen based on the start/end points of the current stroke.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a350ad8cb300705d284206e471a2776ab}\label{classmatplotlib_1_1path_1_1Path_a350ad8cb300705d284206e471a2776ab}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!iter\+\_\+segments@{iter\+\_\+segments}}
\index{iter\+\_\+segments@{iter\+\_\+segments}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{iter\+\_\+segments()}{iter\_segments()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+iter\+\_\+segments (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{transform = {\ttfamily None},  }\item[{}]{remove\+\_\+nans = {\ttfamily True},  }\item[{}]{clip = {\ttfamily None},  }\item[{}]{snap = {\ttfamily False},  }\item[{}]{stroke\+\_\+width = {\ttfamily 1.0},  }\item[{}]{simplify = {\ttfamily None},  }\item[{}]{curves = {\ttfamily True},  }\item[{}]{sketch = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Iterate over all curve segments in the path.

Each iteration returns a pair ``(vertices, code)``, where ``vertices``
is a sequence of 1-3 coordinate pairs, and ``code`` is a `Path` code.

Additionally, this method can provide a number of standard cleanups and
conversions to the path.

Parameters
----------
transform : None or :class:`~matplotlib.transforms.Transform`
    If not None, the given affine transformation will be applied to the
    path.
remove_nans : bool, optional
    Whether to remove all NaNs from the path and skip over them using
    MOVETO commands.
clip : None or (float, float, float, float), optional
    If not None, must be a four-tuple (x1, y1, x2, y2)
    defining a rectangle in which to clip the path.
snap : None or bool, optional
    If True, snap all nodes to pixels; if False, don't snap them.
    If None, snap if the path contains only segments
    parallel to the x or y axes, and no more than 1024 of them.
stroke_width : float, optional
    The width of the stroke being drawn (used for path snapping).
simplify : None or bool, optional
    Whether to simplify the path by removing vertices
    that do not affect its appearance.  If None, use the
    :attr:`should_simplify` attribute.  See also :rc:`path.simplify`
    and :rc:`path.simplify_threshold`.
curves : bool, optional
    If True, curve segments will be returned as curve segments.
    If False, all curves will be converted to line segments.
sketch : None or sequence, optional
    If not None, must be a 3-tuple of the form
    (scale, length, randomness), representing the sketch parameters.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a7d24e4d289747430ff11d550d89be076}\label{classmatplotlib_1_1path_1_1Path_a7d24e4d289747430ff11d550d89be076}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!make\+\_\+compound\+\_\+path@{make\+\_\+compound\+\_\+path}}
\index{make\+\_\+compound\+\_\+path@{make\+\_\+compound\+\_\+path}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{make\+\_\+compound\+\_\+path()}{make\_compound\_path()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+make\+\_\+compound\+\_\+path (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{args }\end{DoxyParamCaption})}

\begin{DoxyVerb}Make a compound path from a list of Path objects. Blindly removes all
Path.STOP control points.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a082efc37cf9eaabafb4e1300fa2ed7df}\label{classmatplotlib_1_1path_1_1Path_a082efc37cf9eaabafb4e1300fa2ed7df}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!make\+\_\+compound\+\_\+path\+\_\+from\+\_\+polys@{make\+\_\+compound\+\_\+path\+\_\+from\+\_\+polys}}
\index{make\+\_\+compound\+\_\+path\+\_\+from\+\_\+polys@{make\+\_\+compound\+\_\+path\+\_\+from\+\_\+polys}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{make\+\_\+compound\+\_\+path\+\_\+from\+\_\+polys()}{make\_compound\_path\_from\_polys()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+make\+\_\+compound\+\_\+path\+\_\+from\+\_\+polys (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{XY }\end{DoxyParamCaption})}

\begin{DoxyVerb}Make a compound path object to draw a number
of polygons with equal numbers of sides XY is a (numpolys x
numsides x 2) numpy array of vertices.  Return object is a
:class:`Path`

.. plot:: gallery/misc/histogram_path.py\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_aaed6949dcf8a429992d3056abf8e2bc8}\label{classmatplotlib_1_1path_1_1Path_aaed6949dcf8a429992d3056abf8e2bc8}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!readonly@{readonly}}
\index{readonly@{readonly}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{readonly()}{readonly()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+readonly (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}`True` if the `Path` is read-only.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_ac6c55e72a1c976f2d7a5d59aea72428d}\label{classmatplotlib_1_1path_1_1Path_ac6c55e72a1c976f2d7a5d59aea72428d}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!should\+\_\+simplify@{should\+\_\+simplify}}
\index{should\+\_\+simplify@{should\+\_\+simplify}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{should\+\_\+simplify()}{should\_simplify()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+should\+\_\+simplify (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}`True` if the vertices array should be simplified.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a90f9d1a0e75bd36f6e2183d2897a4fab}\label{classmatplotlib_1_1path_1_1Path_a90f9d1a0e75bd36f6e2183d2897a4fab}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!should\+\_\+simplify@{should\+\_\+simplify}}
\index{should\+\_\+simplify@{should\+\_\+simplify}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{should\+\_\+simplify()}{should\_simplify()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+should\+\_\+simplify (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{should\+\_\+simplify }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a8cd5b4312362adf7f2cf937bdab1c177}\label{classmatplotlib_1_1path_1_1Path_a8cd5b4312362adf7f2cf937bdab1c177}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!simplify\+\_\+threshold@{simplify\+\_\+threshold}}
\index{simplify\+\_\+threshold@{simplify\+\_\+threshold}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{simplify\+\_\+threshold()}{simplify\_threshold()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+simplify\+\_\+threshold (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}The fraction of a pixel difference below which vertices will
be simplified out.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_aaf9de7febc75199ff89ebec8a0e295d6}\label{classmatplotlib_1_1path_1_1Path_aaf9de7febc75199ff89ebec8a0e295d6}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!simplify\+\_\+threshold@{simplify\+\_\+threshold}}
\index{simplify\+\_\+threshold@{simplify\+\_\+threshold}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{simplify\+\_\+threshold()}{simplify\_threshold()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+simplify\+\_\+threshold (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{threshold }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a8bc3f213058dc56411ad019efbe74acb}\label{classmatplotlib_1_1path_1_1Path_a8bc3f213058dc56411ad019efbe74acb}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!to\+\_\+polygons@{to\+\_\+polygons}}
\index{to\+\_\+polygons@{to\+\_\+polygons}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{to\+\_\+polygons()}{to\_polygons()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+to\+\_\+polygons (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{transform = {\ttfamily None},  }\item[{}]{width = {\ttfamily 0},  }\item[{}]{height = {\ttfamily 0},  }\item[{}]{closed\+\_\+only = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert this path to a list of polygons or polylines.  Each
polygon/polyline is an Nx2 array of vertices.  In other words,
each polygon has no ``MOVETO`` instructions or curves.  This
is useful for displaying in backends that do not support
compound paths or Bezier curves.

If *width* and *height* are both non-zero then the lines will
be simplified so that vertices outside of (0, 0), (width,
height) will be clipped.

If *closed_only* is `True` (default), only closed polygons,
with the last point being the same as the first point, will be
returned.  Any unclosed polylines in the path will be
explicitly closed.  If *closed_only* is `False`, any unclosed
polygons in the path will be returned as unclosed polygons,
and the closed polygons will be returned explicitly closed by
setting the last point to the same as the first point.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_acbbb3e1212913372ed4f428314404c92}\label{classmatplotlib_1_1path_1_1Path_acbbb3e1212913372ed4f428314404c92}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!transformed@{transformed}}
\index{transformed@{transformed}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{transformed()}{transformed()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+transformed (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{transform }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a transformed copy of the path.

See Also
--------
matplotlib.transforms.TransformedPath
    A specialized path class that will cache the transformed result and
    automatically update when the transform changes.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a8e59114bca03a98af3c350a61eb0e6fc}\label{classmatplotlib_1_1path_1_1Path_a8e59114bca03a98af3c350a61eb0e6fc}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!unit\+\_\+circle@{unit\+\_\+circle}}
\index{unit\+\_\+circle@{unit\+\_\+circle}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{unit\+\_\+circle()}{unit\_circle()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+unit\+\_\+circle (\begin{DoxyParamCaption}\item[{}]{cls }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the readonly :class:`Path` of the unit circle.

For most cases, :func:`Path.circle` will be what you want.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a54b3bec2a795959ce6ddeeb5d30a6db3}\label{classmatplotlib_1_1path_1_1Path_a54b3bec2a795959ce6ddeeb5d30a6db3}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!unit\+\_\+circle\+\_\+righthalf@{unit\+\_\+circle\+\_\+righthalf}}
\index{unit\+\_\+circle\+\_\+righthalf@{unit\+\_\+circle\+\_\+righthalf}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{unit\+\_\+circle\+\_\+righthalf()}{unit\_circle\_righthalf()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+unit\+\_\+circle\+\_\+righthalf (\begin{DoxyParamCaption}\item[{}]{cls }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a `Path` of the right half of a unit circle.

See `Path.circle` for the reference on the approximation used.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a57ee8ff0d3ce3c4fd418b88185881bcd}\label{classmatplotlib_1_1path_1_1Path_a57ee8ff0d3ce3c4fd418b88185881bcd}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!unit\+\_\+rectangle@{unit\+\_\+rectangle}}
\index{unit\+\_\+rectangle@{unit\+\_\+rectangle}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{unit\+\_\+rectangle()}{unit\_rectangle()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+unit\+\_\+rectangle (\begin{DoxyParamCaption}\item[{}]{cls }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a `Path` instance of the unit rectangle from (0, 0) to (1, 1).
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a34d0d3657f364ed9e06190c8a0efea7a}\label{classmatplotlib_1_1path_1_1Path_a34d0d3657f364ed9e06190c8a0efea7a}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!unit\+\_\+regular\+\_\+asterisk@{unit\+\_\+regular\+\_\+asterisk}}
\index{unit\+\_\+regular\+\_\+asterisk@{unit\+\_\+regular\+\_\+asterisk}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{unit\+\_\+regular\+\_\+asterisk()}{unit\_regular\_asterisk()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+unit\+\_\+regular\+\_\+asterisk (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{num\+Vertices }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a :class:`Path` for a unit regular asterisk with the given
numVertices and radius of 1.0, centered at (0, 0).
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a922129b6b590f2a951baa32c1615f110}\label{classmatplotlib_1_1path_1_1Path_a922129b6b590f2a951baa32c1615f110}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!unit\+\_\+regular\+\_\+polygon@{unit\+\_\+regular\+\_\+polygon}}
\index{unit\+\_\+regular\+\_\+polygon@{unit\+\_\+regular\+\_\+polygon}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{unit\+\_\+regular\+\_\+polygon()}{unit\_regular\_polygon()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+unit\+\_\+regular\+\_\+polygon (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{num\+Vertices }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a :class:`Path` instance for a unit regular polygon with the
given *numVertices* such that the circumscribing circle has radius 1.0,
centered at (0, 0).
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_ae2b4fc8eeb290b8708e80a7a0c159f26}\label{classmatplotlib_1_1path_1_1Path_ae2b4fc8eeb290b8708e80a7a0c159f26}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!unit\+\_\+regular\+\_\+star@{unit\+\_\+regular\+\_\+star}}
\index{unit\+\_\+regular\+\_\+star@{unit\+\_\+regular\+\_\+star}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{unit\+\_\+regular\+\_\+star()}{unit\_regular\_star()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+unit\+\_\+regular\+\_\+star (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{num\+Vertices,  }\item[{}]{inner\+Circle = {\ttfamily 0.5} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a :class:`Path` for a unit regular star with the given
numVertices and radius of 1.0, centered at (0, 0).
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a16d8c6332dee86b7ccd33eda804c5943}\label{classmatplotlib_1_1path_1_1Path_a16d8c6332dee86b7ccd33eda804c5943}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!vertices@{vertices}}
\index{vertices@{vertices}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{vertices()}{vertices()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+vertices (\begin{DoxyParamCaption}\item[{}]{self }\end{DoxyParamCaption})}

\begin{DoxyVerb}The list of vertices in the `Path` as an Nx2 numpy array.
\end{DoxyVerb}
 \mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a9fb4403d765b7c184105742f91300db9}\label{classmatplotlib_1_1path_1_1Path_a9fb4403d765b7c184105742f91300db9}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!vertices@{vertices}}
\index{vertices@{vertices}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{vertices()}{vertices()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+vertices (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{vertices }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_ae2412176d4ed34f94addd95f00ffa696}\label{classmatplotlib_1_1path_1_1Path_ae2412176d4ed34f94addd95f00ffa696}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!wedge@{wedge}}
\index{wedge@{wedge}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{wedge()}{wedge()}}
{\footnotesize\ttfamily def matplotlib.\+path.\+Path.\+wedge (\begin{DoxyParamCaption}\item[{}]{cls,  }\item[{}]{theta1,  }\item[{}]{theta2,  }\item[{}]{n = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Return the unit circle wedge from angles *theta1* to *theta2* (in
degrees).

*theta2* is unwrapped to produce the shortest wedge within 360 degrees.
That is, if *theta2* > *theta1* + 360, the wedge will be from *theta1*
to *theta2* - 360 and not a full circle plus some extra overlap.

If *n* is provided, it is the number of spline segments to make.
If *n* is not provided, the number of spline segments is
determined based on the delta between *theta1* and *theta2*.

See `Path.arc` for the reference on the approximation used.
\end{DoxyVerb}
 

\subsection{Member Data Documentation}
\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a02575b90932a2331c8e95fce7b11848c}\label{classmatplotlib_1_1path_1_1Path_a02575b90932a2331c8e95fce7b11848c}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!C\+L\+O\+S\+E\+P\+O\+LY@{C\+L\+O\+S\+E\+P\+O\+LY}}
\index{C\+L\+O\+S\+E\+P\+O\+LY@{C\+L\+O\+S\+E\+P\+O\+LY}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{C\+L\+O\+S\+E\+P\+O\+LY}{CLOSEPOLY}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+C\+L\+O\+S\+E\+P\+O\+LY\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a89ee1cccd6a24fe1f278d18d77d84438}\label{classmatplotlib_1_1path_1_1Path_a89ee1cccd6a24fe1f278d18d77d84438}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!code\+\_\+type@{code\+\_\+type}}
\index{code\+\_\+type@{code\+\_\+type}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{code\+\_\+type}{code\_type}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+code\+\_\+type\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a1d7b1c4c674a0f49a14a8e63cb077d80}\label{classmatplotlib_1_1path_1_1Path_a1d7b1c4c674a0f49a14a8e63cb077d80}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!copy@{copy}}
\index{copy@{copy}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{copy}{copy}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+copy\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a8fd69ee9fc2a1051a8d67d12910bab4e}\label{classmatplotlib_1_1path_1_1Path_a8fd69ee9fc2a1051a8d67d12910bab4e}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!C\+U\+R\+V\+E3@{C\+U\+R\+V\+E3}}
\index{C\+U\+R\+V\+E3@{C\+U\+R\+V\+E3}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{C\+U\+R\+V\+E3}{CURVE3}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+C\+U\+R\+V\+E3\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_aec98baae7ae38e7a0ae680fc945f051e}\label{classmatplotlib_1_1path_1_1Path_aec98baae7ae38e7a0ae680fc945f051e}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!C\+U\+R\+V\+E4@{C\+U\+R\+V\+E4}}
\index{C\+U\+R\+V\+E4@{C\+U\+R\+V\+E4}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{C\+U\+R\+V\+E4}{CURVE4}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+C\+U\+R\+V\+E4\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_ae9b78245ec8753fe8b5c84755a5f36f3}\label{classmatplotlib_1_1path_1_1Path_ae9b78245ec8753fe8b5c84755a5f36f3}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!deepcopy@{deepcopy}}
\index{deepcopy@{deepcopy}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{deepcopy}{deepcopy}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+deepcopy\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_af32d8730490de4520b4ef5d4b4a85a96}\label{classmatplotlib_1_1path_1_1Path_af32d8730490de4520b4ef5d4b4a85a96}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!L\+I\+N\+E\+TO@{L\+I\+N\+E\+TO}}
\index{L\+I\+N\+E\+TO@{L\+I\+N\+E\+TO}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{L\+I\+N\+E\+TO}{LINETO}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+L\+I\+N\+E\+TO\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_ab9e9c539ff8aa6ea04fbe89d48e20221}\label{classmatplotlib_1_1path_1_1Path_ab9e9c539ff8aa6ea04fbe89d48e20221}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!M\+O\+V\+E\+TO@{M\+O\+V\+E\+TO}}
\index{M\+O\+V\+E\+TO@{M\+O\+V\+E\+TO}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{M\+O\+V\+E\+TO}{MOVETO}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+M\+O\+V\+E\+TO\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a2a774a55a2a3a2a45aee32b83609f36e}\label{classmatplotlib_1_1path_1_1Path_a2a774a55a2a3a2a45aee32b83609f36e}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!N\+U\+M\+\_\+\+V\+E\+R\+T\+I\+C\+E\+S\+\_\+\+F\+O\+R\+\_\+\+C\+O\+DE@{N\+U\+M\+\_\+\+V\+E\+R\+T\+I\+C\+E\+S\+\_\+\+F\+O\+R\+\_\+\+C\+O\+DE}}
\index{N\+U\+M\+\_\+\+V\+E\+R\+T\+I\+C\+E\+S\+\_\+\+F\+O\+R\+\_\+\+C\+O\+DE@{N\+U\+M\+\_\+\+V\+E\+R\+T\+I\+C\+E\+S\+\_\+\+F\+O\+R\+\_\+\+C\+O\+DE}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{N\+U\+M\+\_\+\+V\+E\+R\+T\+I\+C\+E\+S\+\_\+\+F\+O\+R\+\_\+\+C\+O\+DE}{NUM\_VERTICES\_FOR\_CODE}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+N\+U\+M\+\_\+\+V\+E\+R\+T\+I\+C\+E\+S\+\_\+\+F\+O\+R\+\_\+\+C\+O\+DE\hspace{0.3cm}{\ttfamily [static]}}

\mbox{\Hypertarget{classmatplotlib_1_1path_1_1Path_a9c0f0350d40f9d676f842f7a191cea97}\label{classmatplotlib_1_1path_1_1Path_a9c0f0350d40f9d676f842f7a191cea97}} 
\index{matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}!S\+T\+OP@{S\+T\+OP}}
\index{S\+T\+OP@{S\+T\+OP}!matplotlib\+::path\+::\+Path@{matplotlib\+::path\+::\+Path}}
\subsubsection{\texorpdfstring{S\+T\+OP}{STOP}}
{\footnotesize\ttfamily matplotlib.\+path.\+Path.\+S\+T\+OP\hspace{0.3cm}{\ttfamily [static]}}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
venv/lib/python3.\+9/site-\/packages/matplotlib/\hyperlink{path_8py}{path.\+py}\end{DoxyCompactItemize}
