\hypertarget{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator}{}\section{matplotlib.\+tri.\+triinterpolate.\+Cubic\+Tri\+Interpolator Class Reference}
\label{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator}\index{matplotlib.\+tri.\+triinterpolate.\+Cubic\+Tri\+Interpolator@{matplotlib.\+tri.\+triinterpolate.\+Cubic\+Tri\+Interpolator}}


Inheritance diagram for matplotlib.\+tri.\+triinterpolate.\+Cubic\+Tri\+Interpolator\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=209pt]{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for matplotlib.\+tri.\+triinterpolate.\+Cubic\+Tri\+Interpolator\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=209pt]{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator_a0c3d78be256683e57f25356c1fc7fc5f}{\+\_\+\+\_\+init\+\_\+\+\_\+} (self, triangulation, z, kind=\textquotesingle{}min\+\_\+E\textquotesingle{}, trifinder=None, dz=None)
\item 
def \hyperlink{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator_acd8339c691a476835149466fa3e0fcd4}{\+\_\+\+\_\+call\+\_\+\+\_\+} (self, x, y)
\item 
def \hyperlink{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator_a16ac27d3a77ed963eaaca315f1304a27}{gradient} (self, x, y)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}Cubic interpolator on a triangular grid.

In one-dimension - on a segment - a cubic interpolating function is
defined by the values of the function and its derivative at both ends.
This is almost the same in 2D inside a triangle, except that the values
of the function and its 2 derivatives have to be defined at each triangle
node.

The CubicTriInterpolator takes the value of the function at each node -
provided by the user - and internally computes the value of the
derivatives, resulting in a smooth interpolation.
(As a special feature, the user can also impose the value of the
derivatives at each node, but this is not supposed to be the common
usage.)

Parameters
----------
triangulation : `~matplotlib.tri.Triangulation`
    The triangulation to interpolate over.
z : (npoints,) array-like
    Array of values, defined at grid points, to interpolate between.
kind : {'min_E', 'geom', 'user'}, optional
    Choice of the smoothing algorithm, in order to compute
    the interpolant derivatives (defaults to 'min_E'):

    - if 'min_E': (default) The derivatives at each node is computed
      to minimize a bending energy.
    - if 'geom': The derivatives at each node is computed as a
      weighted average of relevant triangle normals. To be used for
      speed optimization (large grids).
    - if 'user': The user provides the argument *dz*, no computation
      is hence needed.

trifinder : `~matplotlib.tri.TriFinder`, optional
    If not specified, the Triangulation's default TriFinder will
    be used by calling `.Triangulation.get_trifinder`.
dz : tuple of array-likes (dzdx, dzdy), optional
    Used only if  *kind* ='user'. In this case *dz* must be provided as
    (dzdx, dzdy) where dzdx, dzdy are arrays of the same shape as *z* and
    are the interpolant first derivatives at the *triangulation* points.

Methods
-------
`__call__` (x, y) : Returns interpolated values at (x, y) points.
`gradient` (x, y) : Returns interpolated derivatives at (x, y) points.

Notes
-----
This note is a bit technical and details how the cubic interpolation is
computed.

The interpolation is based on a Clough-Tocher subdivision scheme of
the *triangulation* mesh (to make it clearer, each triangle of the
grid will be divided in 3 child-triangles, and on each child triangle
the interpolated function is a cubic polynomial of the 2 coordinates).
This technique originates from FEM (Finite Element Method) analysis;
the element used is a reduced Hsieh-Clough-Tocher (HCT)
element. Its shape functions are described in [1]_.
The assembled function is guaranteed to be C1-smooth, i.e. it is
continuous and its first derivatives are also continuous (this
is easy to show inside the triangles but is also true when crossing the
edges).

In the default case (*kind* ='min_E'), the interpolant minimizes a
curvature energy on the functional space generated by the HCT element
shape functions - with imposed values but arbitrary derivatives at each
node. The minimized functional is the integral of the so-called total
curvature (implementation based on an algorithm from [2]_ - PCG sparse
solver):

    .. math::

        E(z) = \frac{1}{2} \int_{\Omega} \left(
            \left( \frac{\partial^2{z}}{\partial{x}^2} \right)^2 +
            \left( \frac{\partial^2{z}}{\partial{y}^2} \right)^2 +
            2\left( \frac{\partial^2{z}}{\partial{y}\partial{x}} \right)^2
        \right) dx\,dy

If the case *kind* ='geom' is chosen by the user, a simple geometric
approximation is used (weighted average of the triangle normal
vectors), which could improve speed on very large grids.

References
----------
.. [1] Michel Bernadou, Kamal Hassan, "Basis functions for general
    Hsieh-Clough-Tocher triangles, complete or reduced.",
    International Journal for Numerical Methods in Engineering,
    17(5):784 - 789. 2.01.
.. [2] C.T. Kelley, "Iterative Methods for Optimization".\end{DoxyVerb}
 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator_a0c3d78be256683e57f25356c1fc7fc5f}\label{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator_a0c3d78be256683e57f25356c1fc7fc5f}} 
\index{matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator@{matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator}!\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+init\+\_\+\+\_\+@{\+\_\+\+\_\+init\+\_\+\+\_\+}!matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator@{matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+init\+\_\+\+\_\+()}{\_\_init\_\_()}}
{\footnotesize\ttfamily def matplotlib.\+tri.\+triinterpolate.\+Cubic\+Tri\+Interpolator.\+\_\+\+\_\+init\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{triangulation,  }\item[{}]{z,  }\item[{}]{kind = {\ttfamily \textquotesingle{}min\+\_\+E\textquotesingle{}},  }\item[{}]{trifinder = {\ttfamily None},  }\item[{}]{dz = {\ttfamily None} }\end{DoxyParamCaption})}



\subsection{Member Function Documentation}
\mbox{\Hypertarget{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator_acd8339c691a476835149466fa3e0fcd4}\label{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator_acd8339c691a476835149466fa3e0fcd4}} 
\index{matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator@{matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator}!\+\_\+\+\_\+call\+\_\+\+\_\+@{\+\_\+\+\_\+call\+\_\+\+\_\+}}
\index{\+\_\+\+\_\+call\+\_\+\+\_\+@{\+\_\+\+\_\+call\+\_\+\+\_\+}!matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator@{matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator}}
\subsubsection{\texorpdfstring{\+\_\+\+\_\+call\+\_\+\+\_\+()}{\_\_call\_\_()}}
{\footnotesize\ttfamily def matplotlib.\+tri.\+triinterpolate.\+Cubic\+Tri\+Interpolator.\+\_\+\+\_\+call\+\_\+\+\_\+ (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{x,  }\item[{}]{y }\end{DoxyParamCaption})}

\mbox{\Hypertarget{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator_a16ac27d3a77ed963eaaca315f1304a27}\label{classmatplotlib_1_1tri_1_1triinterpolate_1_1CubicTriInterpolator_a16ac27d3a77ed963eaaca315f1304a27}} 
\index{matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator@{matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator}!gradient@{gradient}}
\index{gradient@{gradient}!matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator@{matplotlib\+::tri\+::triinterpolate\+::\+Cubic\+Tri\+Interpolator}}
\subsubsection{\texorpdfstring{gradient()}{gradient()}}
{\footnotesize\ttfamily def matplotlib.\+tri.\+triinterpolate.\+Cubic\+Tri\+Interpolator.\+gradient (\begin{DoxyParamCaption}\item[{}]{self,  }\item[{}]{x,  }\item[{}]{y }\end{DoxyParamCaption})}



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
venv/lib/python3.\+9/site-\/packages/matplotlib/tri/\hyperlink{triinterpolate_8py}{triinterpolate.\+py}\end{DoxyCompactItemize}
