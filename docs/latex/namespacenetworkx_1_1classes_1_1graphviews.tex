\hypertarget{namespacenetworkx_1_1classes_1_1graphviews}{}\section{networkx.\+classes.\+graphviews Namespace Reference}
\label{namespacenetworkx_1_1classes_1_1graphviews}\index{networkx.\+classes.\+graphviews@{networkx.\+classes.\+graphviews}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenetworkx_1_1classes_1_1graphviews_a874b4e1287fcca8fa8eeda3d1926c10c}{generic\+\_\+graph\+\_\+view} (G, create\+\_\+using=None)
\item 
def \hyperlink{namespacenetworkx_1_1classes_1_1graphviews_a33dcd3d967dd7ca14ad2bb823e4e831b}{subgraph\+\_\+view} (G, filter\+\_\+node=no\+\_\+filter, filter\+\_\+edge=no\+\_\+filter)
\item 
def \hyperlink{namespacenetworkx_1_1classes_1_1graphviews_a88278e8cd74c849cf5208ea8b14ad499}{reverse\+\_\+view} (G)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\begin{DoxyVerb}View of Graphs as SubGraph, Reverse, Directed, Undirected.

In some algorithms it is convenient to temporarily morph
a graph to exclude some nodes or edges. It should be better
to do that via a view than to remove and then re-add.
In other algorithms it is convenient to temporarily morph
a graph to reverse directed edges, or treat a directed graph
as undirected, etc. This module provides those graph views.

The resulting views are essentially read-only graphs that
report data from the orignal graph object. We provide an
attribute G._graph which points to the underlying graph object.

Note: Since graphviews look like graphs, one can end up with
view-of-view-of-view chains. Be careful with chains because
they become very slow with about 15 nested views.
For the common simple case of node induced subgraphs created
from the graph class, we short-cut the chain by returning a
subgraph of the original graph directly rather than a subgraph
of a subgraph. We are careful not to disrupt any edge filter in
the middle subgraph. In general, determining how to short-cut
the chain is tricky and much harder with restricted_views than
with induced subgraphs.
Often it is easiest to use .copy() to avoid chains.
\end{DoxyVerb}
 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenetworkx_1_1classes_1_1graphviews_a874b4e1287fcca8fa8eeda3d1926c10c}\label{namespacenetworkx_1_1classes_1_1graphviews_a874b4e1287fcca8fa8eeda3d1926c10c}} 
\index{networkx\+::classes\+::graphviews@{networkx\+::classes\+::graphviews}!generic\+\_\+graph\+\_\+view@{generic\+\_\+graph\+\_\+view}}
\index{generic\+\_\+graph\+\_\+view@{generic\+\_\+graph\+\_\+view}!networkx\+::classes\+::graphviews@{networkx\+::classes\+::graphviews}}
\subsubsection{\texorpdfstring{generic\+\_\+graph\+\_\+view()}{generic\_graph\_view()}}
{\footnotesize\ttfamily def networkx.\+classes.\+graphviews.\+generic\+\_\+graph\+\_\+view (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{create\+\_\+using = {\ttfamily None} }\end{DoxyParamCaption})}

\mbox{\Hypertarget{namespacenetworkx_1_1classes_1_1graphviews_a88278e8cd74c849cf5208ea8b14ad499}\label{namespacenetworkx_1_1classes_1_1graphviews_a88278e8cd74c849cf5208ea8b14ad499}} 
\index{networkx\+::classes\+::graphviews@{networkx\+::classes\+::graphviews}!reverse\+\_\+view@{reverse\+\_\+view}}
\index{reverse\+\_\+view@{reverse\+\_\+view}!networkx\+::classes\+::graphviews@{networkx\+::classes\+::graphviews}}
\subsubsection{\texorpdfstring{reverse\+\_\+view()}{reverse\_view()}}
{\footnotesize\ttfamily def networkx.\+classes.\+graphviews.\+reverse\+\_\+view (\begin{DoxyParamCaption}\item[{}]{G }\end{DoxyParamCaption})}

\begin{DoxyVerb}View of `G` with edge directions reversed

`reverse_view` returns a read-only view of the input graph where
edge directions are reversed.

Identical to digraph.reverse(copy=False)

Parameters
----------
G : networkx.DiGraph

Returns
-------
graph : networkx.DiGraph

Examples
--------
>>> G = nx.DiGraph()
>>> G.add_edge(1, 2)
>>> G.add_edge(2, 3)
>>> G.edges()
OutEdgeView([(1, 2), (2, 3)])

>>> view = nx.reverse_view(G)
>>> view.edges()
OutEdgeView([(2, 1), (3, 2)])
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenetworkx_1_1classes_1_1graphviews_a33dcd3d967dd7ca14ad2bb823e4e831b}\label{namespacenetworkx_1_1classes_1_1graphviews_a33dcd3d967dd7ca14ad2bb823e4e831b}} 
\index{networkx\+::classes\+::graphviews@{networkx\+::classes\+::graphviews}!subgraph\+\_\+view@{subgraph\+\_\+view}}
\index{subgraph\+\_\+view@{subgraph\+\_\+view}!networkx\+::classes\+::graphviews@{networkx\+::classes\+::graphviews}}
\subsubsection{\texorpdfstring{subgraph\+\_\+view()}{subgraph\_view()}}
{\footnotesize\ttfamily def networkx.\+classes.\+graphviews.\+subgraph\+\_\+view (\begin{DoxyParamCaption}\item[{}]{G,  }\item[{}]{filter\+\_\+node = {\ttfamily no\+\_\+filter},  }\item[{}]{filter\+\_\+edge = {\ttfamily no\+\_\+filter} }\end{DoxyParamCaption})}

\begin{DoxyVerb}View of `G` applying a filter on nodes and edges.

`subgraph_view` provides a read-only view of the input graph that excludes
nodes and edges based on the outcome of two filter functions `filter_node`
and `filter_edge`.

The `filter_node` function takes one argument --- the node --- and returns
`True` if the node should be included in the subgraph, and `False` if it
should not be included.

The `filter_edge` function takes two (or three arguments if `G` is a
multi-graph) --- the nodes describing an edge, plus the edge-key if
parallel edges are possible --- and returns `True` if the edge should be
included in the subgraph, and `False` if it should not be included.

Both node and edge filter functions are called on graph elements as they
are queried, meaning there is no up-front cost to creating the view.

Parameters
----------
G : networkx.Graph
    A directed/undirected graph/multigraph

filter_node : callable, optional
    A function taking a node as input, which returns `True` if the node
    should appear in the view.

filter_edge : callable, optional
    A function taking as input the two nodes describing an edge (plus the
    edge-key if `G` is a multi-graph), which returns `True` if the edge
    should appear in the view.

Returns
-------
graph : networkx.Graph
    A read-only graph view of the input graph.

Examples
--------
>>> G = nx.path_graph(6)

Filter functions operate on the node, and return `True` if the node should
appear in the view:

>>> def filter_node(n1):
...     return n1 != 5
...
>>> view = nx.subgraph_view(G, filter_node=filter_node)
>>> view.nodes()
NodeView((0, 1, 2, 3, 4))

We can use a closure pattern to filter graph elements based on additional
data --- for example, filtering on edge data attached to the graph:

>>> G[3][4]["cross_me"] = False
>>> def filter_edge(n1, n2):
...     return G[n1][n2].get("cross_me", True)
...
>>> view = nx.subgraph_view(G, filter_edge=filter_edge)
>>> view.edges()
EdgeView([(0, 1), (1, 2), (2, 3), (4, 5)])

>>> view = nx.subgraph_view(G, filter_node=filter_node, filter_edge=filter_edge,)
>>> view.nodes()
NodeView((0, 1, 2, 3, 4))
>>> view.edges()
EdgeView([(0, 1), (1, 2), (2, 3)])
\end{DoxyVerb}
 