\hypertarget{namespacenumpy_1_1lib_1_1shape__base}{}\section{numpy.\+lib.\+shape\+\_\+base Namespace Reference}
\label{namespacenumpy_1_1lib_1_1shape__base}\index{numpy.\+lib.\+shape\+\_\+base@{numpy.\+lib.\+shape\+\_\+base}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_ac830db13ae6ed5702e2650b263dd479a}{take\+\_\+along\+\_\+axis} (arr, indices, axis)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a5c29e300011aff7533c045e73e7ce424}{put\+\_\+along\+\_\+axis} (arr, indices, values, axis)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a5f60485d92eeebf40d74ade43051bef2}{apply\+\_\+along\+\_\+axis} (func1d, axis, arr, args, kwargs)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_ab25caaa9d9aad7a2495f5bf8dd5672b3}{apply\+\_\+over\+\_\+axes} (func, a, axes)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_ab6c13a41184cfe5841e1e8d50a06a8f1}{expand\+\_\+dims} (a, axis)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a223be1f5270e217c41528fbec2131c43}{column\+\_\+stack} (tup)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a0bed809dc8726e451e41ee6b77577ddb}{dstack} (tup)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a783a47e5d4c03f1ed6276f74b3b538c1}{array\+\_\+split} (ary, indices\+\_\+or\+\_\+sections, axis=0)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_add2346abe66e81efc9bc958f18abf3d9}{split} (ary, indices\+\_\+or\+\_\+sections, axis=0)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a92089da3ec9c284aae7450f6fc98b701}{hsplit} (ary, indices\+\_\+or\+\_\+sections)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a24b4c2509402097020e58f4e855c303f}{vsplit} (ary, indices\+\_\+or\+\_\+sections)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a3e9f077fad5afa6186a0e5bb79eae429}{dsplit} (ary, indices\+\_\+or\+\_\+sections)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_ad23034fce52191e2a66250d5811f9516}{get\+\_\+array\+\_\+prepare} (args)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a56de37acb0e84e4c44c5d9eb2503ae1a}{get\+\_\+array\+\_\+wrap} (args)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_af6e6226bca1c5438f27665971f916196}{kron} (a, b)
\item 
def \hyperlink{namespacenumpy_1_1lib_1_1shape__base_a04f3685035c7fa6527780bab898b8a7f}{tile} (A, reps)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\hyperlink{namespacenumpy_1_1lib_1_1shape__base_ad9a2d886baff0bea9193f85485a753a1}{array\+\_\+function\+\_\+dispatch}
\item 
\hyperlink{namespacenumpy_1_1lib_1_1shape__base_ab703b799ede8879a02e521346f5a25c5}{module}
\item 
\hyperlink{namespacenumpy_1_1lib_1_1shape__base_a87dc9cba9a65818cea26b0b308bdde12}{row\+\_\+stack}
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a5f60485d92eeebf40d74ade43051bef2}\label{namespacenumpy_1_1lib_1_1shape__base_a5f60485d92eeebf40d74ade43051bef2}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!apply\+\_\+along\+\_\+axis@{apply\+\_\+along\+\_\+axis}}
\index{apply\+\_\+along\+\_\+axis@{apply\+\_\+along\+\_\+axis}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{apply\+\_\+along\+\_\+axis()}{apply\_along\_axis()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+apply\+\_\+along\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{func1d,  }\item[{}]{axis,  }\item[{}]{arr,  }\item[{}]{args,  }\item[{}]{kwargs }\end{DoxyParamCaption})}

\begin{DoxyVerb}Apply a function to 1-D slices along the given axis.

Execute `func1d(a, *args, **kwargs)` where `func1d` operates on 1-D arrays
and `a` is a 1-D slice of `arr` along `axis`.

This is equivalent to (but faster than) the following use of `ndindex` and
`s_`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of indices::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            f = func1d(arr[ii + s_[:,] + kk])
            Nj = f.shape
            for jj in ndindex(Nj):
                out[ii + jj + kk] = f[jj]

Equivalently, eliminating the inner loop, this can be expressed as::

    Ni, Nk = a.shape[:axis], a.shape[axis+1:]
    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])

Parameters
----------
func1d : function (M,) -> (Nj...)
    This function should accept 1-D arrays. It is applied to 1-D
    slices of `arr` along the specified axis.
axis : integer
    Axis along which `arr` is sliced.
arr : ndarray (Ni..., M, Nk...)
    Input array.
args : any
    Additional arguments to `func1d`.
kwargs : any
    Additional named arguments to `func1d`.

    .. versionadded:: 1.9.0


Returns
-------
out : ndarray  (Ni..., Nj..., Nk...)
    The output array. The shape of `out` is identical to the shape of
    `arr`, except along the `axis` dimension. This axis is removed, and
    replaced with new dimensions equal to the shape of the return value
    of `func1d`. So if `func1d` returns a scalar `out` will have one
    fewer dimensions than `arr`.

See Also
--------
apply_over_axes : Apply a function repeatedly over multiple axes.

Examples
--------
>>> def my_func(a):
...     \"\"\"Average first and last element of a 1-D array\"\"\"
...     return (a[0] + a[-1]) * 0.5
>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(my_func, 0, b)
array([4., 5., 6.])
>>> np.apply_along_axis(my_func, 1, b)
array([2.,  5.,  8.])

For a function that returns a 1D array, the number of dimensions in
`outarr` is the same as `arr`.

>>> b = np.array([[8,1,7], [4,3,9], [5,2,6]])
>>> np.apply_along_axis(sorted, 1, b)
array([[1, 7, 8],
       [3, 4, 9],
       [2, 5, 6]])

For a function that returns a higher dimensional array, those dimensions
are inserted in place of the `axis` dimension.

>>> b = np.array([[1,2,3], [4,5,6], [7,8,9]])
>>> np.apply_along_axis(np.diag, -1, b)
array([[[1, 0, 0],
        [0, 2, 0],
        [0, 0, 3]],
       [[4, 0, 0],
        [0, 5, 0],
        [0, 0, 6]],
       [[7, 0, 0],
        [0, 8, 0],
        [0, 0, 9]]])
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_ab25caaa9d9aad7a2495f5bf8dd5672b3}\label{namespacenumpy_1_1lib_1_1shape__base_ab25caaa9d9aad7a2495f5bf8dd5672b3}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!apply\+\_\+over\+\_\+axes@{apply\+\_\+over\+\_\+axes}}
\index{apply\+\_\+over\+\_\+axes@{apply\+\_\+over\+\_\+axes}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{apply\+\_\+over\+\_\+axes()}{apply\_over\_axes()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+apply\+\_\+over\+\_\+axes (\begin{DoxyParamCaption}\item[{}]{func,  }\item[{}]{a,  }\item[{}]{axes }\end{DoxyParamCaption})}

\begin{DoxyVerb}Apply a function repeatedly over multiple axes.

`func` is called as `res = func(a, axis)`, where `axis` is the first
element of `axes`.  The result `res` of the function call must have
either the same dimensions as `a` or one less dimension.  If `res`
has one less dimension than `a`, a dimension is inserted before
`axis`.  The call to `func` is then repeated for each axis in `axes`,
with `res` as the first argument.

Parameters
----------
func : function
    This function must take two arguments, `func(a, axis)`.
a : array_like
    Input array.
axes : array_like
    Axes over which `func` is applied; the elements must be integers.

Returns
-------
apply_over_axis : ndarray
    The output array.  The number of dimensions is the same as `a`,
    but the shape can be different.  This depends on whether `func`
    changes the shape of its output with respect to its input.

See Also
--------
apply_along_axis :
    Apply a function to 1-D slices of an array along the given axis.

Notes
-----
This function is equivalent to tuple axis arguments to reorderable ufuncs
with keepdims=True. Tuple axis arguments to ufuncs have been available since
version 1.7.0.

Examples
--------
>>> a = np.arange(24).reshape(2,3,4)
>>> a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

Sum over axes 0 and 2. The result has same number of dimensions
as the original array:

>>> np.apply_over_axes(np.sum, a, [0,2])
array([[[ 60],
        [ 92],
        [124]]])

Tuple axis arguments to ufuncs are equivalent:

>>> np.sum(a, axis=(0,2), keepdims=True)
array([[[ 60],
        [ 92],
        [124]]])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a783a47e5d4c03f1ed6276f74b3b538c1}\label{namespacenumpy_1_1lib_1_1shape__base_a783a47e5d4c03f1ed6276f74b3b538c1}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!array\+\_\+split@{array\+\_\+split}}
\index{array\+\_\+split@{array\+\_\+split}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{array\+\_\+split()}{array\_split()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+array\+\_\+split (\begin{DoxyParamCaption}\item[{}]{ary,  }\item[{}]{indices\+\_\+or\+\_\+sections,  }\item[{}]{axis = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Split an array into multiple sub-arrays.

Please refer to the ``split`` documentation.  The only difference
between these functions is that ``array_split`` allows
`indices_or_sections` to be an integer that does *not* equally
divide the axis. For an array of length l that should be split
into n sections, it returns l % n sub-arrays of size l//n + 1
and the rest of size l//n.

See Also
--------
split : Split array into multiple sub-arrays of equal size.

Examples
--------
>>> x = np.arange(8.0)
>>> np.array_split(x, 3)
[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]

>>> x = np.arange(9)
>>> np.array_split(x, 4)
[array([0, 1, 2]), array([3, 4]), array([5, 6]), array([7, 8])]\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a223be1f5270e217c41528fbec2131c43}\label{namespacenumpy_1_1lib_1_1shape__base_a223be1f5270e217c41528fbec2131c43}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!column\+\_\+stack@{column\+\_\+stack}}
\index{column\+\_\+stack@{column\+\_\+stack}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{column\+\_\+stack()}{column\_stack()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+column\+\_\+stack (\begin{DoxyParamCaption}\item[{}]{tup }\end{DoxyParamCaption})}

\begin{DoxyVerb}Stack 1-D arrays as columns into a 2-D array.

Take a sequence of 1-D arrays and stack them as columns
to make a single 2-D array. 2-D arrays are stacked as-is,
just like with `hstack`.  1-D arrays are turned into 2-D columns
first.

Parameters
----------
tup : sequence of 1-D or 2-D arrays.
    Arrays to stack. All of them must have the same first dimension.

Returns
-------
stacked : 2-D array
    The array formed by stacking the given arrays.

See Also
--------
stack, hstack, vstack, concatenate

Examples
--------
>>> a = np.array((1,2,3))
>>> b = np.array((2,3,4))
>>> np.column_stack((a,b))
array([[1, 2],
       [2, 3],
       [3, 4]])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a3e9f077fad5afa6186a0e5bb79eae429}\label{namespacenumpy_1_1lib_1_1shape__base_a3e9f077fad5afa6186a0e5bb79eae429}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!dsplit@{dsplit}}
\index{dsplit@{dsplit}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{dsplit()}{dsplit()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+dsplit (\begin{DoxyParamCaption}\item[{}]{ary,  }\item[{}]{indices\+\_\+or\+\_\+sections }\end{DoxyParamCaption})}

\begin{DoxyVerb}Split array into multiple sub-arrays along the 3rd axis (depth).

Please refer to the `split` documentation.  `dsplit` is equivalent
to `split` with ``axis=2``, the array is always split along the third
axis provided the array dimension is greater than or equal to 3.

See Also
--------
split : Split an array into multiple sub-arrays of equal size.

Examples
--------
>>> x = np.arange(16.0).reshape(2, 2, 4)
>>> x
array([[[ 0.,   1.,   2.,   3.],
        [ 4.,   5.,   6.,   7.]],
       [[ 8.,   9.,  10.,  11.],
        [12.,  13.,  14.,  15.]]])
>>> np.dsplit(x, 2)
[array([[[ 0.,  1.],
        [ 4.,  5.]],
       [[ 8.,  9.],
        [12., 13.]]]), array([[[ 2.,  3.],
        [ 6.,  7.]],
       [[10., 11.],
        [14., 15.]]])]
>>> np.dsplit(x, np.array([3, 6]))
[array([[[ 0.,   1.,   2.],
        [ 4.,   5.,   6.]],
       [[ 8.,   9.,  10.],
        [12.,  13.,  14.]]]),
 array([[[ 3.],
        [ 7.]],
       [[11.],
        [15.]]]),
array([], shape=(2, 2, 0), dtype=float64)]
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a0bed809dc8726e451e41ee6b77577ddb}\label{namespacenumpy_1_1lib_1_1shape__base_a0bed809dc8726e451e41ee6b77577ddb}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!dstack@{dstack}}
\index{dstack@{dstack}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{dstack()}{dstack()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+dstack (\begin{DoxyParamCaption}\item[{}]{tup }\end{DoxyParamCaption})}

\begin{DoxyVerb}Stack arrays in sequence depth wise (along third axis).

This is equivalent to concatenation along the third axis after 2-D arrays
of shape `(M,N)` have been reshaped to `(M,N,1)` and 1-D arrays of shape
`(N,)` have been reshaped to `(1,N,1)`. Rebuilds arrays divided by
`dsplit`.

This function makes most sense for arrays with up to 3 dimensions. For
instance, for pixel-data with a height (first axis), width (second axis),
and r/g/b channels (third axis). The functions `concatenate`, `stack` and
`block` provide more general stacking and concatenation operations.

Parameters
----------
tup : sequence of arrays
    The arrays must have the same shape along all but the third axis.
    1-D or 2-D arrays must have the same shape.

Returns
-------
stacked : ndarray
    The array formed by stacking the given arrays, will be at least 3-D.

See Also
--------
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
block : Assemble an nd-array from nested lists of blocks.
vstack : Stack arrays in sequence vertically (row wise).
hstack : Stack arrays in sequence horizontally (column wise).
column_stack : Stack 1-D arrays as columns into a 2-D array.
dsplit : Split array along third axis.

Examples
--------
>>> a = np.array((1,2,3))
>>> b = np.array((2,3,4))
>>> np.dstack((a,b))
array([[[1, 2],
        [2, 3],
        [3, 4]]])

>>> a = np.array([[1],[2],[3]])
>>> b = np.array([[2],[3],[4]])
>>> np.dstack((a,b))
array([[[1, 2]],
       [[2, 3]],
       [[3, 4]]])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_ab6c13a41184cfe5841e1e8d50a06a8f1}\label{namespacenumpy_1_1lib_1_1shape__base_ab6c13a41184cfe5841e1e8d50a06a8f1}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!expand\+\_\+dims@{expand\+\_\+dims}}
\index{expand\+\_\+dims@{expand\+\_\+dims}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{expand\+\_\+dims()}{expand\_dims()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+expand\+\_\+dims (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{axis }\end{DoxyParamCaption})}

\begin{DoxyVerb}Expand the shape of an array.

Insert a new axis that will appear at the `axis` position in the expanded
array shape.

Parameters
----------
a : array_like
    Input array.
axis : int or tuple of ints
    Position in the expanded axes where the new axis (or axes) is placed.

    .. deprecated:: 1.13.0
        Passing an axis where ``axis > a.ndim`` will be treated as
        ``axis == a.ndim``, and passing ``axis < -a.ndim - 1`` will
        be treated as ``axis == 0``. This behavior is deprecated.

    .. versionchanged:: 1.18.0
        A tuple of axes is now supported.  Out of range axes as
        described above are now forbidden and raise an `AxisError`.

Returns
-------
result : ndarray
    View of `a` with the number of dimensions increased.

See Also
--------
squeeze : The inverse operation, removing singleton dimensions
reshape : Insert, remove, and combine dimensions, and resize existing ones
doc.indexing, atleast_1d, atleast_2d, atleast_3d

Examples
--------
>>> x = np.array([1, 2])
>>> x.shape
(2,)

The following is equivalent to ``x[np.newaxis, :]`` or ``x[np.newaxis]``:

>>> y = np.expand_dims(x, axis=0)
>>> y
array([[1, 2]])
>>> y.shape
(1, 2)

The following is equivalent to ``x[:, np.newaxis]``:

>>> y = np.expand_dims(x, axis=1)
>>> y
array([[1],
       [2]])
>>> y.shape
(2, 1)

``axis`` may also be a tuple:

>>> y = np.expand_dims(x, axis=(0, 1))
>>> y
array([[[1, 2]]])

>>> y = np.expand_dims(x, axis=(2, 0))
>>> y
array([[[1],
        [2]]])

Note that some examples may use ``None`` instead of ``np.newaxis``.  These
are the same objects:

>>> np.newaxis is None
True\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_ad23034fce52191e2a66250d5811f9516}\label{namespacenumpy_1_1lib_1_1shape__base_ad23034fce52191e2a66250d5811f9516}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!get\+\_\+array\+\_\+prepare@{get\+\_\+array\+\_\+prepare}}
\index{get\+\_\+array\+\_\+prepare@{get\+\_\+array\+\_\+prepare}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{get\+\_\+array\+\_\+prepare()}{get\_array\_prepare()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+get\+\_\+array\+\_\+prepare (\begin{DoxyParamCaption}\item[{}]{args }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the wrapper for the array with the highest priority.

In case of ties, leftmost wins. If no wrapper is found, return None
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a56de37acb0e84e4c44c5d9eb2503ae1a}\label{namespacenumpy_1_1lib_1_1shape__base_a56de37acb0e84e4c44c5d9eb2503ae1a}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!get\+\_\+array\+\_\+wrap@{get\+\_\+array\+\_\+wrap}}
\index{get\+\_\+array\+\_\+wrap@{get\+\_\+array\+\_\+wrap}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{get\+\_\+array\+\_\+wrap()}{get\_array\_wrap()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+get\+\_\+array\+\_\+wrap (\begin{DoxyParamCaption}\item[{}]{args }\end{DoxyParamCaption})}

\begin{DoxyVerb}Find the wrapper for the array with the highest priority.

In case of ties, leftmost wins. If no wrapper is found, return None
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a92089da3ec9c284aae7450f6fc98b701}\label{namespacenumpy_1_1lib_1_1shape__base_a92089da3ec9c284aae7450f6fc98b701}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!hsplit@{hsplit}}
\index{hsplit@{hsplit}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{hsplit()}{hsplit()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+hsplit (\begin{DoxyParamCaption}\item[{}]{ary,  }\item[{}]{indices\+\_\+or\+\_\+sections }\end{DoxyParamCaption})}

\begin{DoxyVerb}Split an array into multiple sub-arrays horizontally (column-wise).

Please refer to the `split` documentation.  `hsplit` is equivalent
to `split` with ``axis=1``, the array is always split along the second
axis regardless of the array dimension.

See Also
--------
split : Split an array into multiple sub-arrays of equal size.

Examples
--------
>>> x = np.arange(16.0).reshape(4, 4)
>>> x
array([[ 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.]])
>>> np.hsplit(x, 2)
[array([[  0.,   1.],
       [  4.,   5.],
       [  8.,   9.],
       [12.,  13.]]),
 array([[  2.,   3.],
       [  6.,   7.],
       [10.,  11.],
       [14.,  15.]])]
>>> np.hsplit(x, np.array([3, 6]))
[array([[ 0.,   1.,   2.],
       [ 4.,   5.,   6.],
       [ 8.,   9.,  10.],
       [12.,  13.,  14.]]),
 array([[ 3.],
       [ 7.],
       [11.],
       [15.]]),
 array([], shape=(4, 0), dtype=float64)]

With a higher dimensional array the split is still along the second axis.

>>> x = np.arange(8.0).reshape(2, 2, 2)
>>> x
array([[[0.,  1.],
        [2.,  3.]],
       [[4.,  5.],
        [6.,  7.]]])
>>> np.hsplit(x, 2)
[array([[[0.,  1.]],
       [[4.,  5.]]]),
 array([[[2.,  3.]],
       [[6.,  7.]]])]\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_af6e6226bca1c5438f27665971f916196}\label{namespacenumpy_1_1lib_1_1shape__base_af6e6226bca1c5438f27665971f916196}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!kron@{kron}}
\index{kron@{kron}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{kron()}{kron()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+kron (\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b }\end{DoxyParamCaption})}

\begin{DoxyVerb}Kronecker product of two arrays.

Computes the Kronecker product, a composite array made of blocks of the
second array scaled by the first.

Parameters
----------
a, b : array_like

Returns
-------
out : ndarray

See Also
--------
outer : The outer product

Notes
-----
The function assumes that the number of dimensions of `a` and `b`
are the same, if necessary prepending the smallest with ones.
If ``a.shape = (r0,r1,..,rN)`` and ``b.shape = (s0,s1,...,sN)``,
the Kronecker product has shape ``(r0*s0, r1*s1, ..., rN*SN)``.
The elements are products of elements from `a` and `b`, organized
explicitly by::

    kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]

where::

    kt = it * st + jt,  t = 0,...,N

In the common 2-D case (N=1), the block structure can be visualized::

    [[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],
     [  ...                              ...   ],
     [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]


Examples
--------
>>> np.kron([1,10,100], [5,6,7])
array([  5,   6,   7, ..., 500, 600, 700])
>>> np.kron([5,6,7], [1,10,100])
array([  5,  50, 500, ...,   7,  70, 700])

>>> np.kron(np.eye(2), np.ones((2,2)))
array([[1.,  1.,  0.,  0.],
       [1.,  1.,  0.,  0.],
       [0.,  0.,  1.,  1.],
       [0.,  0.,  1.,  1.]])

>>> a = np.arange(100).reshape((2,5,2,5))
>>> b = np.arange(24).reshape((2,3,4))
>>> c = np.kron(a,b)
>>> c.shape
(2, 10, 6, 20)
>>> I = (1,3,0,2)
>>> J = (0,2,1)
>>> J1 = (0,) + J             # extend to ndim=4
>>> S1 = (1,) + b.shape
>>> K = tuple(np.array(I) * np.array(S1) + np.array(J1))
>>> c[K] == a[I]*b[J]
True\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a5c29e300011aff7533c045e73e7ce424}\label{namespacenumpy_1_1lib_1_1shape__base_a5c29e300011aff7533c045e73e7ce424}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!put\+\_\+along\+\_\+axis@{put\+\_\+along\+\_\+axis}}
\index{put\+\_\+along\+\_\+axis@{put\+\_\+along\+\_\+axis}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{put\+\_\+along\+\_\+axis()}{put\_along\_axis()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+put\+\_\+along\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{arr,  }\item[{}]{indices,  }\item[{}]{values,  }\item[{}]{axis }\end{DoxyParamCaption})}

\begin{DoxyVerb}Put values into the destination array by matching 1d index and data slices.

This iterates over matching 1d slices oriented along the specified axis in
the index and data arrays, and uses the former to place values into the
latter. These slices can be different lengths.

Functions returning an index along an axis, like `argsort` and
`argpartition`, produce suitable indices for this function.

.. versionadded:: 1.15.0

Parameters
----------
arr : ndarray (Ni..., M, Nk...)
    Destination array.
indices : ndarray (Ni..., J, Nk...)
    Indices to change along each 1d slice of `arr`. This must match the
    dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast
    against `arr`.
values : array_like (Ni..., J, Nk...)
    values to insert at those indices. Its shape and dimension are
    broadcast to match that of `indices`.
axis : int
    The axis to take 1d slices along. If axis is None, the destination
    array is treated as if a flattened 1d view had been created of it.

Notes
-----
This is equivalent to (but faster than) the following use of `ndindex` and
`s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::

    Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
    J = indices.shape[axis]  # Need not equal M

    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            a_1d       = a      [ii + s_[:,] + kk]
            indices_1d = indices[ii + s_[:,] + kk]
            values_1d  = values [ii + s_[:,] + kk]
            for j in range(J):
                a_1d[indices_1d[j]] = values_1d[j]

Equivalently, eliminating the inner loop, the last two lines would be::

            a_1d[indices_1d] = values_1d

See Also
--------
take_along_axis :
    Take values from the input array by matching 1d index and data slices

Examples
--------

For this sample array

>>> a = np.array([[10, 30, 20], [60, 40, 50]])

We can replace the maximum values with:

>>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)
>>> ai
array([[1],
       [0]])
>>> np.put_along_axis(a, ai, 99, axis=1)
>>> a
array([[10, 99, 20],
       [99, 40, 50]])\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_add2346abe66e81efc9bc958f18abf3d9}\label{namespacenumpy_1_1lib_1_1shape__base_add2346abe66e81efc9bc958f18abf3d9}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!split@{split}}
\index{split@{split}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{split()}{split()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+split (\begin{DoxyParamCaption}\item[{}]{ary,  }\item[{}]{indices\+\_\+or\+\_\+sections,  }\item[{}]{axis = {\ttfamily 0} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Split an array into multiple sub-arrays as views into `ary`.

Parameters
----------
ary : ndarray
    Array to be divided into sub-arrays.
indices_or_sections : int or 1-D array
    If `indices_or_sections` is an integer, N, the array will be divided
    into N equal arrays along `axis`.  If such a split is not possible,
    an error is raised.

    If `indices_or_sections` is a 1-D array of sorted integers, the entries
    indicate where along `axis` the array is split.  For example,
    ``[2, 3]`` would, for ``axis=0``, result in

      - ary[:2]
      - ary[2:3]
      - ary[3:]

    If an index exceeds the dimension of the array along `axis`,
    an empty sub-array is returned correspondingly.
axis : int, optional
    The axis along which to split, default is 0.

Returns
-------
sub-arrays : list of ndarrays
    A list of sub-arrays as views into `ary`.

Raises
------
ValueError
    If `indices_or_sections` is given as an integer, but
    a split does not result in equal division.

See Also
--------
array_split : Split an array into multiple sub-arrays of equal or
              near-equal size.  Does not raise an exception if
              an equal division cannot be made.
hsplit : Split array into multiple sub-arrays horizontally (column-wise).
vsplit : Split array into multiple sub-arrays vertically (row wise).
dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
concatenate : Join a sequence of arrays along an existing axis.
stack : Join a sequence of arrays along a new axis.
hstack : Stack arrays in sequence horizontally (column wise).
vstack : Stack arrays in sequence vertically (row wise).
dstack : Stack arrays in sequence depth wise (along third dimension).

Examples
--------
>>> x = np.arange(9.0)
>>> np.split(x, 3)
[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]

>>> x = np.arange(8.0)
>>> np.split(x, [3, 5, 6, 10])
[array([0.,  1.,  2.]),
 array([3.,  4.]),
 array([5.]),
 array([6.,  7.]),
 array([], dtype=float64)]\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_ac830db13ae6ed5702e2650b263dd479a}\label{namespacenumpy_1_1lib_1_1shape__base_ac830db13ae6ed5702e2650b263dd479a}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!take\+\_\+along\+\_\+axis@{take\+\_\+along\+\_\+axis}}
\index{take\+\_\+along\+\_\+axis@{take\+\_\+along\+\_\+axis}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{take\+\_\+along\+\_\+axis()}{take\_along\_axis()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+take\+\_\+along\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{arr,  }\item[{}]{indices,  }\item[{}]{axis }\end{DoxyParamCaption})}

\begin{DoxyVerb}Take values from the input array by matching 1d index and data slices.

This iterates over matching 1d slices oriented along the specified axis in
the index and data arrays, and uses the former to look up values in the
latter. These slices can be different lengths.

Functions returning an index along an axis, like `argsort` and
`argpartition`, produce suitable indices for this function.

.. versionadded:: 1.15.0

Parameters
----------
arr : ndarray (Ni..., M, Nk...)
    Source array
indices : ndarray (Ni..., J, Nk...)
    Indices to take along each 1d slice of `arr`. This must match the
    dimension of arr, but dimensions Ni and Nj only need to broadcast
    against `arr`.
axis : int
    The axis to take 1d slices along. If axis is None, the input array is
    treated as if it had first been flattened to 1d, for consistency with
    `sort` and `argsort`.

Returns
-------
out: ndarray (Ni..., J, Nk...)
    The indexed result.

Notes
-----
This is equivalent to (but faster than) the following use of `ndindex` and
`s_`, which sets each of ``ii`` and ``kk`` to a tuple of indices::

    Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
    J = indices.shape[axis]  # Need not equal M
    out = np.empty(Ni + (J,) + Nk)

    for ii in ndindex(Ni):
        for kk in ndindex(Nk):
            a_1d       = a      [ii + s_[:,] + kk]
            indices_1d = indices[ii + s_[:,] + kk]
            out_1d     = out    [ii + s_[:,] + kk]
            for j in range(J):
                out_1d[j] = a_1d[indices_1d[j]]

Equivalently, eliminating the inner loop, the last two lines would be::

            out_1d[:] = a_1d[indices_1d]

See Also
--------
take : Take along an axis, using the same indices for every 1d slice
put_along_axis :
    Put values into the destination array by matching 1d index and data slices

Examples
--------

For this sample array

>>> a = np.array([[10, 30, 20], [60, 40, 50]])

We can sort either by using sort directly, or argsort and this function

>>> np.sort(a, axis=1)
array([[10, 20, 30],
       [40, 50, 60]])
>>> ai = np.argsort(a, axis=1); ai
array([[0, 2, 1],
       [1, 2, 0]])
>>> np.take_along_axis(a, ai, axis=1)
array([[10, 20, 30],
       [40, 50, 60]])

The same works for max and min, if you expand the dimensions:

>>> np.expand_dims(np.max(a, axis=1), axis=1)
array([[30],
       [60]])
>>> ai = np.expand_dims(np.argmax(a, axis=1), axis=1)
>>> ai
array([[1],
       [0]])
>>> np.take_along_axis(a, ai, axis=1)
array([[30],
       [60]])

If we want to get the max and min at the same time, we can stack the
indices first

>>> ai_min = np.expand_dims(np.argmin(a, axis=1), axis=1)
>>> ai_max = np.expand_dims(np.argmax(a, axis=1), axis=1)
>>> ai = np.concatenate([ai_min, ai_max], axis=1)
>>> ai
array([[0, 1],
       [1, 0]])
>>> np.take_along_axis(a, ai, axis=1)
array([[10, 30],
       [40, 60]])
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a04f3685035c7fa6527780bab898b8a7f}\label{namespacenumpy_1_1lib_1_1shape__base_a04f3685035c7fa6527780bab898b8a7f}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!tile@{tile}}
\index{tile@{tile}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{tile()}{tile()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+tile (\begin{DoxyParamCaption}\item[{}]{A,  }\item[{}]{reps }\end{DoxyParamCaption})}

\begin{DoxyVerb}Construct an array by repeating A the number of times given by reps.

If `reps` has length ``d``, the result will have dimension of
``max(d, A.ndim)``.

If ``A.ndim < d``, `A` is promoted to be d-dimensional by prepending new
axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,
or shape (1, 1, 3) for 3-D replication. If this is not the desired
behavior, promote `A` to d-dimensions manually before calling this
function.

If ``A.ndim > d``, `reps` is promoted to `A`.ndim by pre-pending 1's to it.
Thus for an `A` of shape (2, 3, 4, 5), a `reps` of (2, 2) is treated as
(1, 1, 2, 2).

Note : Although tile may be used for broadcasting, it is strongly
recommended to use numpy's broadcasting operations and functions.

Parameters
----------
A : array_like
    The input array.
reps : array_like
    The number of repetitions of `A` along each axis.

Returns
-------
c : ndarray
    The tiled output array.

See Also
--------
repeat : Repeat elements of an array.
broadcast_to : Broadcast an array to a new shape

Examples
--------
>>> a = np.array([0, 1, 2])
>>> np.tile(a, 2)
array([0, 1, 2, 0, 1, 2])
>>> np.tile(a, (2, 2))
array([[0, 1, 2, 0, 1, 2],
       [0, 1, 2, 0, 1, 2]])
>>> np.tile(a, (2, 1, 2))
array([[[0, 1, 2, 0, 1, 2]],
       [[0, 1, 2, 0, 1, 2]]])

>>> b = np.array([[1, 2], [3, 4]])
>>> np.tile(b, 2)
array([[1, 2, 1, 2],
       [3, 4, 3, 4]])
>>> np.tile(b, (2, 1))
array([[1, 2],
       [3, 4],
       [1, 2],
       [3, 4]])

>>> c = np.array([1,2,3,4])
>>> np.tile(c,(4,1))
array([[1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4]])
\end{DoxyVerb}
 \mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a24b4c2509402097020e58f4e855c303f}\label{namespacenumpy_1_1lib_1_1shape__base_a24b4c2509402097020e58f4e855c303f}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!vsplit@{vsplit}}
\index{vsplit@{vsplit}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{vsplit()}{vsplit()}}
{\footnotesize\ttfamily def numpy.\+lib.\+shape\+\_\+base.\+vsplit (\begin{DoxyParamCaption}\item[{}]{ary,  }\item[{}]{indices\+\_\+or\+\_\+sections }\end{DoxyParamCaption})}

\begin{DoxyVerb}Split an array into multiple sub-arrays vertically (row-wise).

Please refer to the ``split`` documentation.  ``vsplit`` is equivalent
to ``split`` with `axis=0` (default), the array is always split along the
first axis regardless of the array dimension.

See Also
--------
split : Split an array into multiple sub-arrays of equal size.

Examples
--------
>>> x = np.arange(16.0).reshape(4, 4)
>>> x
array([[ 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.]])
>>> np.vsplit(x, 2)
[array([[0., 1., 2., 3.],
       [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],
       [12., 13., 14., 15.]])]
>>> np.vsplit(x, np.array([3, 6]))
[array([[ 0.,  1.,  2.,  3.],
       [ 4.,  5.,  6.,  7.],
       [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]

With a higher dimensional array the split is still along the first axis.

>>> x = np.arange(8.0).reshape(2, 2, 2)
>>> x
array([[[0.,  1.],
        [2.,  3.]],
       [[4.,  5.],
        [6.,  7.]]])
>>> np.vsplit(x, 2)
[array([[[0., 1.],
        [2., 3.]]]), array([[[4., 5.],
        [6., 7.]]])]\end{DoxyVerb}
 

\subsection{Variable Documentation}
\mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_ad9a2d886baff0bea9193f85485a753a1}\label{namespacenumpy_1_1lib_1_1shape__base_ad9a2d886baff0bea9193f85485a753a1}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!array\+\_\+function\+\_\+dispatch@{array\+\_\+function\+\_\+dispatch}}
\index{array\+\_\+function\+\_\+dispatch@{array\+\_\+function\+\_\+dispatch}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{array\+\_\+function\+\_\+dispatch}{array\_function\_dispatch}}
{\footnotesize\ttfamily numpy.\+lib.\+shape\+\_\+base.\+array\+\_\+function\+\_\+dispatch}

\mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_ab703b799ede8879a02e521346f5a25c5}\label{namespacenumpy_1_1lib_1_1shape__base_ab703b799ede8879a02e521346f5a25c5}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!module@{module}}
\index{module@{module}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{module}{module}}
{\footnotesize\ttfamily numpy.\+lib.\+shape\+\_\+base.\+module}

\mbox{\Hypertarget{namespacenumpy_1_1lib_1_1shape__base_a87dc9cba9a65818cea26b0b308bdde12}\label{namespacenumpy_1_1lib_1_1shape__base_a87dc9cba9a65818cea26b0b308bdde12}} 
\index{numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}!row\+\_\+stack@{row\+\_\+stack}}
\index{row\+\_\+stack@{row\+\_\+stack}!numpy\+::lib\+::shape\+\_\+base@{numpy\+::lib\+::shape\+\_\+base}}
\subsubsection{\texorpdfstring{row\+\_\+stack}{row\_stack}}
{\footnotesize\ttfamily numpy.\+lib.\+shape\+\_\+base.\+row\+\_\+stack}

