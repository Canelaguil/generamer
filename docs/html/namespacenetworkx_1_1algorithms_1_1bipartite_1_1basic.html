<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.bipartite.basic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite.html">bipartite</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic.html">basic</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.bipartite.basic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6462e071381cc74c249460b049be721c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic.html#a6462e071381cc74c249460b049be721c">color</a> (G)</td></tr>
<tr class="separator:a6462e071381cc74c249460b049be721c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7270bffa6310b169dab29de12670980"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic.html#ae7270bffa6310b169dab29de12670980">is_bipartite</a> (G)</td></tr>
<tr class="separator:ae7270bffa6310b169dab29de12670980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6daf4a71e3df41c92b02c3004441681"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic.html#ae6daf4a71e3df41c92b02c3004441681">is_bipartite_node_set</a> (G, nodes)</td></tr>
<tr class="separator:ae6daf4a71e3df41c92b02c3004441681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbc287cbc9094e5b488d5e3791cc964"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic.html#aacbc287cbc9094e5b488d5e3791cc964">sets</a> (G, top_nodes=None)</td></tr>
<tr class="separator:aacbc287cbc9094e5b488d5e3791cc964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f01281cb4f0d12041cfef9cbfc4bbb4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic.html#a6f01281cb4f0d12041cfef9cbfc4bbb4">density</a> (B, nodes)</td></tr>
<tr class="separator:a6f01281cb4f0d12041cfef9cbfc4bbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f81ac1d3e9ad819f508fb97ce748830"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1basic.html#a3f81ac1d3e9ad819f508fb97ce748830">degrees</a> (B, nodes, weight=None)</td></tr>
<tr class="separator:a3f81ac1d3e9ad819f508fb97ce748830"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">==========================
Bipartite Graph Algorithms
==========================
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a6462e071381cc74c249460b049be721c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6462e071381cc74c249460b049be721c">&#9670;&nbsp;</a></span>color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.basic.color </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a two-coloring of the graph.

Raises an exception if the graph is not bipartite.

Parameters
----------
G : NetworkX graph

Returns
-------
color : dictionary
    A dictionary keyed by node with a 1 or 0 as data for each node color.

Raises
------
NetworkXError
    If the graph is not two-colorable.

Examples
--------
&gt;&gt;&gt; from networkx.algorithms import bipartite
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; c = bipartite.color(G)
&gt;&gt;&gt; print(c)
{0: 1, 1: 0, 2: 1, 3: 0}

You can use this to set a node attribute indicating the biparite set:

&gt;&gt;&gt; nx.set_node_attributes(G, c, "bipartite")
&gt;&gt;&gt; print(G.nodes[0]["bipartite"])
1
&gt;&gt;&gt; print(G.nodes[1]["bipartite"])
0
</pre> 
</div>
</div>
<a id="a3f81ac1d3e9ad819f508fb97ce748830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f81ac1d3e9ad819f508fb97ce748830">&#9670;&nbsp;</a></span>degrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.basic.degrees </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the degrees of the two node sets in the bipartite graph B.

Parameters
----------
B : NetworkX graph

nodes: list or container
  Nodes in one node set of the bipartite graph.

weight : string or None, optional (default=None)
   The edge attribute that holds the numerical value used as a weight.
   If None, then each edge has weight 1.
   The degree is the sum of the edge weights adjacent to the node.

Returns
-------
(degX,degY) : tuple of dictionaries
   The degrees of the two bipartite sets as dictionaries keyed by node.

Examples
--------
&gt;&gt;&gt; from networkx.algorithms import bipartite
&gt;&gt;&gt; G = nx.complete_bipartite_graph(3, 2)
&gt;&gt;&gt; Y = set([3, 4])
&gt;&gt;&gt; degX, degY = bipartite.degrees(G, Y)
&gt;&gt;&gt; dict(degX)
{0: 2, 1: 2, 2: 2}

Notes
-----
The container of nodes passed as argument must contain all nodes
in one of the two bipartite node sets to avoid ambiguity in the
case of disconnected graphs.
See :mod:`bipartite documentation &lt;networkx.algorithms.bipartite&gt;`
for further details on how bipartite graphs are handled in NetworkX.

See Also
--------
color, density
</pre> 
</div>
</div>
<a id="a6f01281cb4f0d12041cfef9cbfc4bbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f01281cb4f0d12041cfef9cbfc4bbb4">&#9670;&nbsp;</a></span>density()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.basic.density </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns density of bipartite graph B.

Parameters
----------
B : NetworkX graph

nodes: list or container
  Nodes in one node set of the bipartite graph.

Returns
-------
d : float
   The bipartite density

Examples
--------
&gt;&gt;&gt; from networkx.algorithms import bipartite
&gt;&gt;&gt; G = nx.complete_bipartite_graph(3, 2)
&gt;&gt;&gt; X = set([0, 1, 2])
&gt;&gt;&gt; bipartite.density(G, X)
1.0
&gt;&gt;&gt; Y = set([3, 4])
&gt;&gt;&gt; bipartite.density(G, Y)
1.0

Notes
-----
The container of nodes passed as argument must contain all nodes
in one of the two bipartite node sets to avoid ambiguity in the
case of disconnected graphs.
See :mod:`bipartite documentation &lt;networkx.algorithms.bipartite&gt;`
for further details on how bipartite graphs are handled in NetworkX.

See Also
--------
color
</pre> 
</div>
</div>
<a id="ae7270bffa6310b169dab29de12670980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7270bffa6310b169dab29de12670980">&#9670;&nbsp;</a></span>is_bipartite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.basic.is_bipartite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if graph G is bipartite, False if not.

Parameters
----------
G : NetworkX graph

Examples
--------
&gt;&gt;&gt; from networkx.algorithms import bipartite
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; print(bipartite.is_bipartite(G))
True

See Also
--------
color, is_bipartite_node_set
</pre> 
</div>
</div>
<a id="ae6daf4a71e3df41c92b02c3004441681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6daf4a71e3df41c92b02c3004441681">&#9670;&nbsp;</a></span>is_bipartite_node_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.basic.is_bipartite_node_set </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if nodes and G/nodes are a bipartition of G.

Parameters
----------
G : NetworkX graph

nodes: list or container
  Check if nodes are a one of a bipartite set.

Examples
--------
&gt;&gt;&gt; from networkx.algorithms import bipartite
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; X = set([1, 3])
&gt;&gt;&gt; bipartite.is_bipartite_node_set(G, X)
True

Notes
-----
For connected graphs the bipartite sets are unique.  This function handles
disconnected graphs.
</pre> 
</div>
</div>
<a id="aacbc287cbc9094e5b488d5e3791cc964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbc287cbc9094e5b488d5e3791cc964">&#9670;&nbsp;</a></span>sets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.basic.sets </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>top_nodes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns bipartite node sets of graph G.

Raises an exception if the graph is not bipartite or if the input
graph is disconnected and thus more than one valid solution exists.
See :mod:`bipartite documentation &lt;networkx.algorithms.bipartite&gt;`
for further details on how bipartite graphs are handled in NetworkX.

Parameters
----------
G : NetworkX graph

top_nodes : container, optional
  Container with all nodes in one bipartite node set. If not supplied
  it will be computed. But if more than one solution exists an exception
  will be raised.

Returns
-------
X : set
  Nodes from one side of the bipartite graph.
Y : set
  Nodes from the other side.

Raises
------
AmbiguousSolution
  Raised if the input bipartite graph is disconnected and no container
  with all nodes in one bipartite set is provided. When determining
  the nodes in each bipartite set more than one valid solution is
  possible if the input graph is disconnected.
NetworkXError
  Raised if the input graph is not bipartite.

Examples
--------
&gt;&gt;&gt; from networkx.algorithms import bipartite
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; X, Y = bipartite.sets(G)
&gt;&gt;&gt; list(X)
[0, 2]
&gt;&gt;&gt; list(Y)
[1, 3]

See Also
--------
color</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
