<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.classes.function Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1classes.html">classes</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html">function</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.classes.function Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a13ec9e314635ecbb194fe675b544d3e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a13ec9e314635ecbb194fe675b544d3e5">nodes</a> (G)</td></tr>
<tr class="separator:a13ec9e314635ecbb194fe675b544d3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab909d446533d66c2c860fd617b12baba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#ab909d446533d66c2c860fd617b12baba">edges</a> (G, nbunch=None)</td></tr>
<tr class="separator:ab909d446533d66c2c860fd617b12baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d09e12435fd33c5f6915608df6fbf3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#ab0d09e12435fd33c5f6915608df6fbf3">degree</a> (G, nbunch=None, weight=None)</td></tr>
<tr class="separator:ab0d09e12435fd33c5f6915608df6fbf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271a8668c32a4a881230a7814dcc4ec4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a271a8668c32a4a881230a7814dcc4ec4">neighbors</a> (G, n)</td></tr>
<tr class="separator:a271a8668c32a4a881230a7814dcc4ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af683224caf58051461a40ab33821115e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#af683224caf58051461a40ab33821115e">number_of_nodes</a> (G)</td></tr>
<tr class="separator:af683224caf58051461a40ab33821115e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb37106c18fd48082b43f2a2b69fb2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a5acb37106c18fd48082b43f2a2b69fb2">number_of_edges</a> (G)</td></tr>
<tr class="separator:a5acb37106c18fd48082b43f2a2b69fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d2dff9da6b86469aa19819cfbd2710"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a01d2dff9da6b86469aa19819cfbd2710">density</a> (G)</td></tr>
<tr class="separator:a01d2dff9da6b86469aa19819cfbd2710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43770941c72d38ec396414f0df0f8bae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a43770941c72d38ec396414f0df0f8bae">degree_histogram</a> (G)</td></tr>
<tr class="separator:a43770941c72d38ec396414f0df0f8bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5dbd375698725a35a7d3fd4493ba7c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a4a5dbd375698725a35a7d3fd4493ba7c">is_directed</a> (G)</td></tr>
<tr class="separator:a4a5dbd375698725a35a7d3fd4493ba7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8cbe4f6fc7d77111cc5a4dff1a9e125"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#ad8cbe4f6fc7d77111cc5a4dff1a9e125">frozen</a> (args, kwargs)</td></tr>
<tr class="separator:ad8cbe4f6fc7d77111cc5a4dff1a9e125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e337cbcfb1c1f634abeec979d6eacbe"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a0e337cbcfb1c1f634abeec979d6eacbe">freeze</a> (G)</td></tr>
<tr class="separator:a0e337cbcfb1c1f634abeec979d6eacbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8a779487dbd0a50e0e327728477d8b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a5c8a779487dbd0a50e0e327728477d8b">is_frozen</a> (G)</td></tr>
<tr class="separator:a5c8a779487dbd0a50e0e327728477d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef5d5719b3cee2143f426efb16166af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a3ef5d5719b3cee2143f426efb16166af">add_star</a> (G_to_add_to, nodes_for_star, attr)</td></tr>
<tr class="separator:a3ef5d5719b3cee2143f426efb16166af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272ff2af873850562af525145f897dda"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a272ff2af873850562af525145f897dda">add_path</a> (G_to_add_to, nodes_for_path, attr)</td></tr>
<tr class="separator:a272ff2af873850562af525145f897dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b85f51c5079f3c36d1e2fcdd28fec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#aea8b85f51c5079f3c36d1e2fcdd28fec">add_cycle</a> (G_to_add_to, nodes_for_cycle, attr)</td></tr>
<tr class="separator:aea8b85f51c5079f3c36d1e2fcdd28fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa7d5122eef21ede5dee1c2f8521ee5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#acfa7d5122eef21ede5dee1c2f8521ee5">subgraph</a> (G, nbunch)</td></tr>
<tr class="separator:acfa7d5122eef21ede5dee1c2f8521ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a2ad0f85ad7d26c35b59a641025c3c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a45a2ad0f85ad7d26c35b59a641025c3c">induced_subgraph</a> (G, nbunch)</td></tr>
<tr class="separator:a45a2ad0f85ad7d26c35b59a641025c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d2d99f08dc6f638279d48ca07679c9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a39d2d99f08dc6f638279d48ca07679c9">edge_subgraph</a> (G, <a class="el" href="namespacenetworkx_1_1classes_1_1function.html#ab909d446533d66c2c860fd617b12baba">edges</a>)</td></tr>
<tr class="separator:a39d2d99f08dc6f638279d48ca07679c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfec12fd521d462be920924dd5953f4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a9cfec12fd521d462be920924dd5953f4">restricted_view</a> (G, <a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a13ec9e314635ecbb194fe675b544d3e5">nodes</a>, <a class="el" href="namespacenetworkx_1_1classes_1_1function.html#ab909d446533d66c2c860fd617b12baba">edges</a>)</td></tr>
<tr class="separator:a9cfec12fd521d462be920924dd5953f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e5092cd7da6e6ed1c61b46c51f5e09"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#aa5e5092cd7da6e6ed1c61b46c51f5e09">to_directed</a> (graph)</td></tr>
<tr class="separator:aa5e5092cd7da6e6ed1c61b46c51f5e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278629fd7422427c446489efd50f2759"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a278629fd7422427c446489efd50f2759">to_undirected</a> (graph)</td></tr>
<tr class="separator:a278629fd7422427c446489efd50f2759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565df0c79563c4cde9f996730f69b6d8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a565df0c79563c4cde9f996730f69b6d8">create_empty_copy</a> (G, with_data=True)</td></tr>
<tr class="separator:a565df0c79563c4cde9f996730f69b6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad844158261f251a2a9706c3f2ac06d0c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#ad844158261f251a2a9706c3f2ac06d0c">info</a> (G, n=None)</td></tr>
<tr class="separator:ad844158261f251a2a9706c3f2ac06d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa227e0002def739138e08480a98799"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#acfa227e0002def739138e08480a98799">set_node_attributes</a> (G, values, name=None)</td></tr>
<tr class="separator:acfa227e0002def739138e08480a98799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084c24285aa0773cefca0807c62d2ee6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a084c24285aa0773cefca0807c62d2ee6">get_node_attributes</a> (G, name)</td></tr>
<tr class="separator:a084c24285aa0773cefca0807c62d2ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b04c05929fa8e2cd0a0acfde1a44a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a28b04c05929fa8e2cd0a0acfde1a44a7">set_edge_attributes</a> (G, values, name=None)</td></tr>
<tr class="separator:a28b04c05929fa8e2cd0a0acfde1a44a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c6ec0a398b8dfc9e3545c54134ce37"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a05c6ec0a398b8dfc9e3545c54134ce37">get_edge_attributes</a> (G, name)</td></tr>
<tr class="separator:a05c6ec0a398b8dfc9e3545c54134ce37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5fbe4b8298af9096b2f41ab421c66f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a4e5fbe4b8298af9096b2f41ab421c66f">all_neighbors</a> (graph, node)</td></tr>
<tr class="separator:a4e5fbe4b8298af9096b2f41ab421c66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a939874452e715ec658b8450a874d3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a08a939874452e715ec658b8450a874d3">non_neighbors</a> (graph, node)</td></tr>
<tr class="separator:a08a939874452e715ec658b8450a874d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35786196acc54b50940475a34415ddfc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a35786196acc54b50940475a34415ddfc">non_edges</a> (graph)</td></tr>
<tr class="separator:a35786196acc54b50940475a34415ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b9811bc09def6b6a4e6fda86b49df9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#ae1b9811bc09def6b6a4e6fda86b49df9">common_neighbors</a> (G, u, v)</td></tr>
<tr class="separator:ae1b9811bc09def6b6a4e6fda86b49df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b85b7c8fc72a2ebc28f739c6364ad4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a69b85b7c8fc72a2ebc28f739c6364ad4">is_weighted</a> (G, edge=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a69b85b7c8fc72a2ebc28f739c6364ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac6a2e602a81557057e8ba62fb17769"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a9ac6a2e602a81557057e8ba62fb17769">is_negatively_weighted</a> (G, edge=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a9ac6a2e602a81557057e8ba62fb17769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66588440e17cb5cbad23b903d9c682e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#aa66588440e17cb5cbad23b903d9c682e">is_empty</a> (G)</td></tr>
<tr class="separator:aa66588440e17cb5cbad23b903d9c682e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78924acdc608361a17669da3ebe59b46"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a78924acdc608361a17669da3ebe59b46">nodes_with_selfloops</a> (G)</td></tr>
<tr class="separator:a78924acdc608361a17669da3ebe59b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb46104cf7b33e31d560f74b0d27029f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#abb46104cf7b33e31d560f74b0d27029f">selfloop_edges</a> (G, data=False, keys=False, default=None)</td></tr>
<tr class="separator:abb46104cf7b33e31d560f74b0d27029f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89beffb331b0ed1c2a60df70f3d4f62"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#aa89beffb331b0ed1c2a60df70f3d4f62">number_of_selfloops</a> (G)</td></tr>
<tr class="separator:aa89beffb331b0ed1c2a60df70f3d4f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf33b4db2b4b16c70e347646483f6a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#aadf33b4db2b4b16c70e347646483f6a5">is_path</a> (G, path)</td></tr>
<tr class="separator:aadf33b4db2b4b16c70e347646483f6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27237953342bdad7ef82830af11008f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1function.html#a27237953342bdad7ef82830af11008f7">path_weight</a> (G, path, weight)</td></tr>
<tr class="separator:a27237953342bdad7ef82830af11008f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functional interface to graph methods and assorted utilities.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aea8b85f51c5079f3c36d1e2fcdd28fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8b85f51c5079f3c36d1e2fcdd28fec">&#9670;&nbsp;</a></span>add_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.add_cycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G_to_add_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes_for_cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add a cycle to the Graph G_to_add_to.

Parameters
----------
G_to_add_to : graph
    A NetworkX graph
nodes_for_cycle: iterable container
    A container of nodes.  A cycle will be constructed from
    the nodes (in order) and added to the graph.
attr : keyword arguments, optional (default= no attributes)
    Attributes to add to every edge in cycle.

See Also
--------
add_path, add_star

Examples
--------
&gt;&gt;&gt; G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc
&gt;&gt;&gt; nx.add_cycle(G, [0, 1, 2, 3])
&gt;&gt;&gt; nx.add_cycle(G, [10, 11, 12], weight=7)
</pre> 
</div>
</div>
<a id="a272ff2af873850562af525145f897dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272ff2af873850562af525145f897dda">&#9670;&nbsp;</a></span>add_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.add_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G_to_add_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes_for_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add a path to the Graph G_to_add_to.

Parameters
----------
G_to_add_to : graph
    A NetworkX graph
nodes_for_path : iterable container
    A container of nodes.  A path will be constructed from
    the nodes (in order) and added to the graph.
attr : keyword arguments, optional (default= no attributes)
    Attributes to add to every edge in path.

See Also
--------
add_star, add_cycle

Examples
--------
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; nx.add_path(G, [0, 1, 2, 3])
&gt;&gt;&gt; nx.add_path(G, [10, 11, 12], weight=7)
</pre> 
</div>
</div>
<a id="a3ef5d5719b3cee2143f426efb16166af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef5d5719b3cee2143f426efb16166af">&#9670;&nbsp;</a></span>add_star()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.add_star </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G_to_add_to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes_for_star</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Add a star to Graph G_to_add_to.

The first node in `nodes_for_star` is the middle of the star.
It is connected to all other nodes.

Parameters
----------
G_to_add_to : graph
    A NetworkX graph
nodes_for_star : iterable container
    A container of nodes.
attr : keyword arguments, optional (default= no attributes)
    Attributes to add to every edge in star.

See Also
--------
add_path, add_cycle

Examples
--------
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; nx.add_star(G, [0, 1, 2, 3])
&gt;&gt;&gt; nx.add_star(G, [10, 11, 12], weight=2)
</pre> 
</div>
</div>
<a id="a4e5fbe4b8298af9096b2f41ab421c66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5fbe4b8298af9096b2f41ab421c66f">&#9670;&nbsp;</a></span>all_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.all_neighbors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns all of the neighbors of a node in the graph.

If the graph is directed returns predecessors as well as successors.

Parameters
----------
graph : NetworkX graph
    Graph to find neighbors.

node : node
    The node whose neighbors will be returned.

Returns
-------
neighbors : iterator
    Iterator of neighbors
</pre> 
</div>
</div>
<a id="ae1b9811bc09def6b6a4e6fda86b49df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b9811bc09def6b6a4e6fda86b49df9">&#9670;&nbsp;</a></span>common_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.common_neighbors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the common neighbors of two nodes in a graph.

Parameters
----------
G : graph
    A NetworkX undirected graph.

u, v : nodes
    Nodes in the graph.

Returns
-------
cnbors : iterator
    Iterator of common neighbors of u and v in the graph.

Raises
------
NetworkXError
    If u or v is not a node in the graph.

Examples
--------
&gt;&gt;&gt; G = nx.complete_graph(5)
&gt;&gt;&gt; sorted(nx.common_neighbors(G, 0, 1))
[2, 3, 4]
</pre> 
</div>
</div>
<a id="a565df0c79563c4cde9f996730f69b6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565df0c79563c4cde9f996730f69b6d8">&#9670;&nbsp;</a></span>create_empty_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.create_empty_copy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>with_data</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a copy of the graph G with all of the edges removed.

Parameters
----------
G : graph
   A NetworkX graph

with_data :  bool (default=True)
   Propagate Graph and Nodes data to the new graph.

See Also
--------
empty_graph</pre> 
</div>
</div>
<a id="ab0d09e12435fd33c5f6915608df6fbf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d09e12435fd33c5f6915608df6fbf3">&#9670;&nbsp;</a></span>degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nbunch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a degree view of single node or of nbunch of nodes.
If nbunch is omitted, then return degrees of *all* nodes.
</pre> 
</div>
</div>
<a id="a43770941c72d38ec396414f0df0f8bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43770941c72d38ec396414f0df0f8bae">&#9670;&nbsp;</a></span>degree_histogram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.degree_histogram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of the frequency of each degree value.

Parameters
----------
G : Networkx graph
   A graph

Returns
-------
hist : list
   A list of frequencies of degrees.
   The degree values are the index in the list.

Notes
-----
Note: the bins are width one, hence len(list) can be large
(Order(number_of_edges))
</pre> 
</div>
</div>
<a id="a01d2dff9da6b86469aa19819cfbd2710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d2dff9da6b86469aa19819cfbd2710">&#9670;&nbsp;</a></span>density()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.density </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the density of a graph.

The density for undirected graphs is

.. math::

   d = \frac{2m}{n(n-1)},

and for directed graphs is

.. math::

   d = \frac{m}{n(n-1)},

where `n` is the number of nodes and `m`  is the number of edges in `G`.

Notes
-----
The density is 0 for a graph without edges and 1 for a complete graph.
The density of multigraphs can be higher than 1.

Self loops are counted in the total number of edges so graphs with self
loops can have density higher than 1.
</pre> 
</div>
</div>
<a id="a39d2d99f08dc6f638279d48ca07679c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39d2d99f08dc6f638279d48ca07679c9">&#9670;&nbsp;</a></span>edge_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.edge_subgraph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a view of the subgraph induced by the specified edges.

The induced subgraph contains each edge in `edges` and each
node incident to any of those edges.

Parameters
----------
G : NetworkX Graph
edges : iterable
    An iterable of edges. Edges not present in `G` are ignored.

Returns
-------
subgraph : SubGraph View
    A read-only edge-induced subgraph of `G`.
    Changes to `G` are reflected in the view.

Notes
-----
To create a mutable subgraph with its own copies of nodes
edges and attributes use `subgraph.copy()` or `Graph(subgraph)`

If you create a subgraph of a subgraph recursively you can end up
with a chain of subgraphs that becomes very slow with about 15
nested subgraph views. Luckily the edge_subgraph filter nests
nicely so you can use the original graph as G in this function
to avoid chains. We do not rule out chains programmatically so
that odd cases like an `edge_subgraph` of a `restricted_view`
can be created.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; H = G.edge_subgraph([(0, 1), (3, 4)])
&gt;&gt;&gt; list(H.nodes)
[0, 1, 3, 4]
&gt;&gt;&gt; list(H.edges)
[(0, 1), (3, 4)]
</pre> 
</div>
</div>
<a id="ab909d446533d66c2c860fd617b12baba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab909d446533d66c2c860fd617b12baba">&#9670;&nbsp;</a></span>edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nbunch</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an edge view of edges incident to nodes in nbunch.

Return all edges if nbunch is unspecified or nbunch=None.

For digraphs, edges=out_edges
</pre> 
</div>
</div>
<a id="a0e337cbcfb1c1f634abeec979d6eacbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e337cbcfb1c1f634abeec979d6eacbe">&#9670;&nbsp;</a></span>freeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.freeze </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Modify graph to prevent further change by adding or removing
nodes or edges.

Node and edge data can still be modified.

Parameters
----------
G : graph
  A NetworkX graph

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; G = nx.freeze(G)
&gt;&gt;&gt; try:
...     G.add_edge(4, 5)
... except nx.NetworkXError as e:
...     print(str(e))
Frozen graph can't be modified

Notes
-----
To "unfreeze" a graph you must make a copy by creating a new graph object:

&gt;&gt;&gt; graph = nx.path_graph(4)
&gt;&gt;&gt; frozen_graph = nx.freeze(graph)
&gt;&gt;&gt; unfrozen_graph = nx.Graph(frozen_graph)
&gt;&gt;&gt; nx.is_frozen(unfrozen_graph)
False

See Also
--------
is_frozen
</pre> 
</div>
</div>
<a id="ad8cbe4f6fc7d77111cc5a4dff1a9e125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8cbe4f6fc7d77111cc5a4dff1a9e125">&#9670;&nbsp;</a></span>frozen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.frozen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dummy method for raising errors when trying to modify frozen graphs</pre> 
</div>
</div>
<a id="a05c6ec0a398b8dfc9e3545c54134ce37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c6ec0a398b8dfc9e3545c54134ce37">&#9670;&nbsp;</a></span>get_edge_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.get_edge_attributes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get edge attributes from graph

Parameters
----------
G : NetworkX Graph

name : string
   Attribute name

Returns
-------
Dictionary of attributes keyed by edge. For (di)graphs, the keys are
2-tuples of the form: (u, v). For multi(di)graphs, the keys are 3-tuples of
the form: (u, v, key).

Examples
--------
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; nx.add_path(G, [1, 2, 3], color="red")
&gt;&gt;&gt; color = nx.get_edge_attributes(G, "color")
&gt;&gt;&gt; color[(1, 2)]
'red'
</pre> 
</div>
</div>
<a id="a084c24285aa0773cefca0807c62d2ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084c24285aa0773cefca0807c62d2ee6">&#9670;&nbsp;</a></span>get_node_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.get_node_attributes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get node attributes from graph

Parameters
----------
G : NetworkX Graph

name : string
   Attribute name

Returns
-------
Dictionary of attributes keyed by node.

Examples
--------
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; G.add_nodes_from([1, 2, 3], color="red")
&gt;&gt;&gt; color = nx.get_node_attributes(G, "color")
&gt;&gt;&gt; color[1]
'red'
</pre> 
</div>
</div>
<a id="a45a2ad0f85ad7d26c35b59a641025c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a2ad0f85ad7d26c35b59a641025c3c">&#9670;&nbsp;</a></span>induced_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.induced_subgraph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nbunch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a SubGraph view of `G` showing only nodes in nbunch.

The induced subgraph of a graph on a set of nodes N is the
graph with nodes N and edges from G which have both ends in N.

Parameters
----------
G : NetworkX Graph
nbunch : node, container of nodes or None (for all nodes)

Returns
-------
subgraph : SubGraph View
    A read-only view of the subgraph in `G` induced by the nodes.
    Changes to the graph `G` will be reflected in the view.

Notes
-----
To create a mutable subgraph with its own copies of nodes
edges and attributes use `subgraph.copy()` or `Graph(subgraph)`

For an inplace reduction of a graph to a subgraph you can remove nodes:
`G.remove_nodes_from(n in G if n not in set(nbunch))`

If you are going to compute subgraphs of your subgraphs you could
end up with a chain of views that can be very slow once the chain
has about 15 views in it. If they are all induced subgraphs, you
can short-cut the chain by making them all subgraphs of the original
graph. The graph class method `G.subgraph` does this when `G` is
a subgraph. In contrast, this function allows you to choose to build
chains or not, as you wish. The returned subgraph is a view on `G`.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)  # or DiGraph, MultiGraph, MultiDiGraph, etc
&gt;&gt;&gt; H = G.subgraph([0, 1, 2])
&gt;&gt;&gt; list(H.edges)
[(0, 1), (1, 2)]
</pre> 
</div>
</div>
<a id="ad844158261f251a2a9706c3f2ac06d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad844158261f251a2a9706c3f2ac06d0c">&#9670;&nbsp;</a></span>info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.info </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a summary of information for the graph G or a single node n.

The summary includes the number of nodes and edges, or neighbours for a single
node.

Parameters
----------
G : Networkx graph
   A graph
n : node (any hashable)
   A node in the graph G

Returns
-------
info : str
    A string containing the short summary

Raises
------
NetworkXError
    If n is not in the graph G</pre> 
</div>
</div>
<a id="a4a5dbd375698725a35a7d3fd4493ba7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5dbd375698725a35a7d3fd4493ba7c">&#9670;&nbsp;</a></span>is_directed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.is_directed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if graph is directed.</pre> 
</div>
</div>
<a id="aa66588440e17cb5cbad23b903d9c682e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66588440e17cb5cbad23b903d9c682e">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.is_empty </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if `G` has no edges.

Parameters
----------
G : graph
    A NetworkX graph.

Returns
-------
bool
    True if `G` has no edges, and False otherwise.

Notes
-----
An empty graph can have nodes but not edges. The empty graph with zero
nodes is known as the null graph. This is an $O(n)$ operation where n
is the number of nodes in the graph.</pre> 
</div>
</div>
<a id="a5c8a779487dbd0a50e0e327728477d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8a779487dbd0a50e0e327728477d8b">&#9670;&nbsp;</a></span>is_frozen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.is_frozen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if graph is frozen.

Parameters
----------
G : graph
  A NetworkX graph

See Also
--------
freeze
</pre> 
</div>
</div>
<a id="a9ac6a2e602a81557057e8ba62fb17769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac6a2e602a81557057e8ba62fb17769">&#9670;&nbsp;</a></span>is_negatively_weighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.is_negatively_weighted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if `G` has negatively weighted edges.

Parameters
----------
G : graph
    A NetworkX graph.

edge : tuple, optional
    A 2-tuple specifying the only edge in `G` that will be tested. If
    None, then every edge in `G` is tested.

weight: string, optional
    The attribute name used to query for edge weights.

Returns
-------
bool
    A boolean signifying if `G`, or the specified edge, is negatively
    weighted.

Raises
------
NetworkXError
    If the specified edge does not exist.

Examples
--------
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; G.add_edges_from([(1, 3), (2, 4), (2, 6)])
&gt;&gt;&gt; G.add_edge(1, 2, weight=4)
&gt;&gt;&gt; nx.is_negatively_weighted(G, (1, 2))
False
&gt;&gt;&gt; G[2][4]["weight"] = -2
&gt;&gt;&gt; nx.is_negatively_weighted(G)
True
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; edges = [("0", "3", 3), ("0", "1", -5), ("1", "0", -2)]
&gt;&gt;&gt; G.add_weighted_edges_from(edges)
&gt;&gt;&gt; nx.is_negatively_weighted(G)
True</pre> 
</div>
</div>
<a id="aadf33b4db2b4b16c70e347646483f6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf33b4db2b4b16c70e347646483f6a5">&#9670;&nbsp;</a></span>is_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.is_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns whether or not the specified path exists

Parameters
----------
G : graph
    A NetworkX graph.

path: list
    A list of node labels which defines the path to traverse

Returns
-------
isPath: bool
    A boolean representing whether or not the path exists</pre> 
</div>
</div>
<a id="a69b85b7c8fc72a2ebc28f739c6364ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b85b7c8fc72a2ebc28f739c6364ad4">&#9670;&nbsp;</a></span>is_weighted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.is_weighted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if `G` has weighted edges.

Parameters
----------
G : graph
    A NetworkX graph.

edge : tuple, optional
    A 2-tuple specifying the only edge in `G` that will be tested. If
    None, then every edge in `G` is tested.

weight: string, optional
    The attribute name used to query for edge weights.

Returns
-------
bool
    A boolean signifying if `G`, or the specified edge, is weighted.

Raises
------
NetworkXError
    If the specified edge does not exist.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; nx.is_weighted(G)
False
&gt;&gt;&gt; nx.is_weighted(G, (2, 3))
False

&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_edge(1, 2, weight=1)
&gt;&gt;&gt; nx.is_weighted(G)
True</pre> 
</div>
</div>
<a id="a271a8668c32a4a881230a7814dcc4ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a271a8668c32a4a881230a7814dcc4ec4">&#9670;&nbsp;</a></span>neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.neighbors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of nodes connected to node n.</pre> 
</div>
</div>
<a id="a13ec9e314635ecbb194fe675b544d3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ec9e314635ecbb194fe675b544d3e5">&#9670;&nbsp;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.nodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator over the graph nodes.</pre> 
</div>
</div>
<a id="a78924acdc608361a17669da3ebe59b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78924acdc608361a17669da3ebe59b46">&#9670;&nbsp;</a></span>nodes_with_selfloops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.nodes_with_selfloops </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator over nodes with self loops.

A node with a self loop has an edge with both ends adjacent
to that node.

Returns
-------
nodelist : iterator
    A iterator over nodes with self loops.

See Also
--------
selfloop_edges, number_of_selfloops

Examples
--------
&gt;&gt;&gt; G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc
&gt;&gt;&gt; G.add_edge(1, 1)
&gt;&gt;&gt; G.add_edge(1, 2)
&gt;&gt;&gt; list(nx.nodes_with_selfloops(G))
[1]</pre> 
</div>
</div>
<a id="a35786196acc54b50940475a34415ddfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35786196acc54b50940475a34415ddfc">&#9670;&nbsp;</a></span>non_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.non_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the non-existent edges in the graph.

Parameters
----------
graph : NetworkX graph.
    Graph to find non-existent edges.

Returns
-------
non_edges : iterator
    Iterator of edges that are not in the graph.
</pre> 
</div>
</div>
<a id="a08a939874452e715ec658b8450a874d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a939874452e715ec658b8450a874d3">&#9670;&nbsp;</a></span>non_neighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.non_neighbors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the non-neighbors of the node in the graph.

Parameters
----------
graph : NetworkX graph
    Graph to find neighbors.

node : node
    The node whose neighbors will be returned.

Returns
-------
non_neighbors : iterator
    Iterator of nodes in the graph that are not neighbors of the node.
</pre> 
</div>
</div>
<a id="a5acb37106c18fd48082b43f2a2b69fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acb37106c18fd48082b43f2a2b69fb2">&#9670;&nbsp;</a></span>number_of_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.number_of_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of edges in the graph.</pre> 
</div>
</div>
<a id="af683224caf58051461a40ab33821115e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af683224caf58051461a40ab33821115e">&#9670;&nbsp;</a></span>number_of_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.number_of_nodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of nodes in the graph.</pre> 
</div>
</div>
<a id="aa89beffb331b0ed1c2a60df70f3d4f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89beffb331b0ed1c2a60df70f3d4f62">&#9670;&nbsp;</a></span>number_of_selfloops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.number_of_selfloops </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of selfloop edges.

A selfloop edge has the same node at both ends.

Returns
-------
nloops : int
    The number of selfloops.

See Also
--------
nodes_with_selfloops, selfloop_edges

Examples
--------
&gt;&gt;&gt; G = nx.Graph()  # or DiGraph, MultiGraph, MultiDiGraph, etc
&gt;&gt;&gt; G.add_edge(1, 1)
&gt;&gt;&gt; G.add_edge(1, 2)
&gt;&gt;&gt; nx.number_of_selfloops(G)
1
</pre> 
</div>
</div>
<a id="a27237953342bdad7ef82830af11008f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27237953342bdad7ef82830af11008f7">&#9670;&nbsp;</a></span>path_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.path_weight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns total cost associated with specified path and weight

Parameters
----------
G : graph
    A NetworkX graph.

path: list
    A list of node labels which defines the path to traverse

weight: string
    A string indicating which edge attribute to use for path cost

Returns
-------
cost: int
    A integer representing the total cost with respect to the
    specified weight of the specified path

Raises
------
NetworkXNoPath
    If the specified edge does not exist.
</pre> 
</div>
</div>
<a id="a9cfec12fd521d462be920924dd5953f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cfec12fd521d462be920924dd5953f4">&#9670;&nbsp;</a></span>restricted_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.restricted_view </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a view of `G` with hidden nodes and edges.

The resulting subgraph filters out node `nodes` and edges `edges`.
Filtered out nodes also filter out any of their edges.

Parameters
----------
G : NetworkX Graph
nodes : iterable
    An iterable of nodes. Nodes not present in `G` are ignored.
edges : iterable
    An iterable of edges. Edges not present in `G` are ignored.

Returns
-------
subgraph : SubGraph View
    A read-only restricted view of `G` filtering out nodes and edges.
    Changes to `G` are reflected in the view.

Notes
-----
To create a mutable subgraph with its own copies of nodes
edges and attributes use `subgraph.copy()` or `Graph(subgraph)`

If you create a subgraph of a subgraph recursively you may end up
with a chain of subgraph views. Such chains can get quite slow
for lengths near 15. To avoid long chains, try to make your subgraph
based on the original graph.  We do not rule out chains programmatically
so that odd cases like an `edge_subgraph` of a `restricted_view`
can be created.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; H = nx.restricted_view(G, [0], [(1, 2), (3, 4)])
&gt;&gt;&gt; list(H.nodes)
[1, 2, 3, 4]
&gt;&gt;&gt; list(H.edges)
[(2, 3)]
</pre> 
</div>
</div>
<a id="abb46104cf7b33e31d560f74b0d27029f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb46104cf7b33e31d560f74b0d27029f">&#9670;&nbsp;</a></span>selfloop_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.selfloop_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keys</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an iterator over selfloop edges.

A selfloop edge has the same node at both ends.

Parameters
----------
G : graph
    A NetworkX graph.
data : string or bool, optional (default=False)
    Return selfloop edges as two tuples (u, v) (data=False)
    or three-tuples (u, v, datadict) (data=True)
    or three-tuples (u, v, datavalue) (data='attrname')
keys : bool, optional (default=False)
    If True, return edge keys with each edge.
default : value, optional (default=None)
    Value used for edges that don't have the requested attribute.
    Only relevant if data is not True or False.

Returns
-------
edgeiter : iterator over edge tuples
    An iterator over all selfloop edges.

See Also
--------
nodes_with_selfloops, number_of_selfloops

Examples
--------
&gt;&gt;&gt; G = nx.MultiGraph()  # or Graph, DiGraph, MultiDiGraph, etc
&gt;&gt;&gt; ekey = G.add_edge(1, 1)
&gt;&gt;&gt; ekey = G.add_edge(1, 2)
&gt;&gt;&gt; list(nx.selfloop_edges(G))
[(1, 1)]
&gt;&gt;&gt; list(nx.selfloop_edges(G, data=True))
[(1, 1, {})]
&gt;&gt;&gt; list(nx.selfloop_edges(G, keys=True))
[(1, 1, 0)]
&gt;&gt;&gt; list(nx.selfloop_edges(G, keys=True, data=True))
[(1, 1, 0, {})]
</pre> 
</div>
</div>
<a id="a28b04c05929fa8e2cd0a0acfde1a44a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b04c05929fa8e2cd0a0acfde1a44a7">&#9670;&nbsp;</a></span>set_edge_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.set_edge_attributes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets edge attributes from a given value or dictionary of values.

.. Warning:: The call order of arguments `values` and `name`
    switched between v1.x &amp; v2.x.

Parameters
----------
G : NetworkX Graph

values : scalar value, dict-like
    What the edge attribute should be set to.  If `values` is
    not a dictionary, then it is treated as a single attribute value
    that is then applied to every edge in `G`.  This means that if
    you provide a mutable object, like a list, updates to that object
    will be reflected in the edge attribute for each edge.  The attribute
    name will be `name`.

    If `values` is a dict or a dict of dict, it should be keyed
    by edge tuple to either an attribute value or a dict of attribute
    key/value pairs used to update the edge's attributes.
    For multigraphs, the edge tuples must be of the form ``(u, v, key)``,
    where `u` and `v` are nodes and `key` is the edge key.
    For non-multigraphs, the keys must be tuples of the form ``(u, v)``.

name : string (optional, default=None)
    Name of the edge attribute to set if values is a scalar.

Examples
--------
After computing some property of the edges of a graph, you may want
to assign a edge attribute to store the value of that property for
each edge::

    &gt;&gt;&gt; G = nx.path_graph(3)
    &gt;&gt;&gt; bb = nx.edge_betweenness_centrality(G, normalized=False)
    &gt;&gt;&gt; nx.set_edge_attributes(G, bb, "betweenness")
    &gt;&gt;&gt; G.edges[1, 2]["betweenness"]
    2.0

If you provide a list as the second argument, updates to the list
will be reflected in the edge attribute for each edge::

    &gt;&gt;&gt; labels = []
    &gt;&gt;&gt; nx.set_edge_attributes(G, labels, "labels")
    &gt;&gt;&gt; labels.append("foo")
    &gt;&gt;&gt; G.edges[0, 1]["labels"]
    ['foo']
    &gt;&gt;&gt; G.edges[1, 2]["labels"]
    ['foo']

If you provide a dictionary of dictionaries as the second argument,
the entire dictionary will be used to update edge attributes::

    &gt;&gt;&gt; G = nx.path_graph(3)
    &gt;&gt;&gt; attrs = {(0, 1): {"attr1": 20, "attr2": "nothing"}, (1, 2): {"attr2": 3}}
    &gt;&gt;&gt; nx.set_edge_attributes(G, attrs)
    &gt;&gt;&gt; G[0][1]["attr1"]
    20
    &gt;&gt;&gt; G[0][1]["attr2"]
    'nothing'
    &gt;&gt;&gt; G[1][2]["attr2"]
    3

Note that if the dict contains edges that are not in `G`, they are
silently ignored::

    &gt;&gt;&gt; G = nx.Graph([(0, 1)])
    &gt;&gt;&gt; nx.set_edge_attributes(G, {(1, 2): {"weight": 2.0}})
    &gt;&gt;&gt; (1, 2) in G.edges()
    False</pre> 
</div>
</div>
<a id="acfa227e0002def739138e08480a98799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa227e0002def739138e08480a98799">&#9670;&nbsp;</a></span>set_node_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.set_node_attributes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sets node attributes from a given value or dictionary of values.

.. Warning:: The call order of arguments `values` and `name`
    switched between v1.x &amp; v2.x.

Parameters
----------
G : NetworkX Graph

values : scalar value, dict-like
    What the node attribute should be set to.  If `values` is
    not a dictionary, then it is treated as a single attribute value
    that is then applied to every node in `G`.  This means that if
    you provide a mutable object, like a list, updates to that object
    will be reflected in the node attribute for every node.
    The attribute name will be `name`.

    If `values` is a dict or a dict of dict, it should be keyed
    by node to either an attribute value or a dict of attribute key/value
    pairs used to update the node's attributes.

name : string (optional, default=None)
    Name of the node attribute to set if values is a scalar.

Examples
--------
After computing some property of the nodes of a graph, you may want
to assign a node attribute to store the value of that property for
each node::

    &gt;&gt;&gt; G = nx.path_graph(3)
    &gt;&gt;&gt; bb = nx.betweenness_centrality(G)
    &gt;&gt;&gt; isinstance(bb, dict)
    True
    &gt;&gt;&gt; nx.set_node_attributes(G, bb, "betweenness")
    &gt;&gt;&gt; G.nodes[1]["betweenness"]
    1.0

If you provide a list as the second argument, updates to the list
will be reflected in the node attribute for each node::

    &gt;&gt;&gt; G = nx.path_graph(3)
    &gt;&gt;&gt; labels = []
    &gt;&gt;&gt; nx.set_node_attributes(G, labels, "labels")
    &gt;&gt;&gt; labels.append("foo")
    &gt;&gt;&gt; G.nodes[0]["labels"]
    ['foo']
    &gt;&gt;&gt; G.nodes[1]["labels"]
    ['foo']
    &gt;&gt;&gt; G.nodes[2]["labels"]
    ['foo']

If you provide a dictionary of dictionaries as the second argument,
the outer dictionary is assumed to be keyed by node to an inner
dictionary of node attributes for that node::

    &gt;&gt;&gt; G = nx.path_graph(3)
    &gt;&gt;&gt; attrs = {0: {"attr1": 20, "attr2": "nothing"}, 1: {"attr2": 3}}
    &gt;&gt;&gt; nx.set_node_attributes(G, attrs)
    &gt;&gt;&gt; G.nodes[0]["attr1"]
    20
    &gt;&gt;&gt; G.nodes[0]["attr2"]
    'nothing'
    &gt;&gt;&gt; G.nodes[1]["attr2"]
    3
    &gt;&gt;&gt; G.nodes[2]
    {}

Note that if the dictionary contains nodes that are not in `G`, the
values are silently ignored::

    &gt;&gt;&gt; G = nx.Graph()
    &gt;&gt;&gt; G.add_node(0)
    &gt;&gt;&gt; nx.set_node_attributes(G, {0: "red", 1: "blue"}, name="color")
    &gt;&gt;&gt; G.nodes[0]["color"]
    'red'
    &gt;&gt;&gt; 1 in G.nodes
    False</pre> 
</div>
</div>
<a id="acfa7d5122eef21ede5dee1c2f8521ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa7d5122eef21ede5dee1c2f8521ee5">&#9670;&nbsp;</a></span>subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.subgraph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nbunch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the subgraph induced on nodes in nbunch.

Parameters
----------
G : graph
   A NetworkX graph

nbunch : list, iterable
   A container of nodes that will be iterated through once (thus
   it should be an iterator or be iterable).  Each element of the
   container should be a valid node type: any hashable type except
   None.  If nbunch is None, return all edges data in the graph.
   Nodes in nbunch that are not in the graph will be (quietly)
   ignored.

Notes
-----
subgraph(G) calls G.subgraph()
</pre> 
</div>
</div>
<a id="aa5e5092cd7da6e6ed1c61b46c51f5e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e5092cd7da6e6ed1c61b46c51f5e09">&#9670;&nbsp;</a></span>to_directed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.to_directed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a directed view of the graph `graph`.

Identical to graph.to_directed(as_view=True)
Note that graph.to_directed defaults to `as_view=False`
while this function always provides a view.
</pre> 
</div>
</div>
<a id="a278629fd7422427c446489efd50f2759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278629fd7422427c446489efd50f2759">&#9670;&nbsp;</a></span>to_undirected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.function.to_undirected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an undirected view of the graph `graph`.

Identical to graph.to_undirected(as_view=True)
Note that graph.to_undirected defaults to `as_view=False`
while this function always provides a view.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
