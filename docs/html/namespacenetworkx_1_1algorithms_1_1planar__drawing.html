<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.planar_drawing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1planar__drawing.html">planar_drawing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.planar_drawing Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac8d92cba8c047a320c16ffdf2684e58c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1planar__drawing.html#ac8d92cba8c047a320c16ffdf2684e58c">combinatorial_embedding_to_pos</a> (embedding, fully_triangulate=False)</td></tr>
<tr class="separator:ac8d92cba8c047a320c16ffdf2684e58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982f71be29109cd0fdaa238cf0551a23"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1planar__drawing.html#a982f71be29109cd0fdaa238cf0551a23">set_position</a> (parent, tree, remaining_nodes, delta_x, y_coordinate, pos)</td></tr>
<tr class="separator:a982f71be29109cd0fdaa238cf0551a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e561926d9c6866e89f8730fa371f029"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1planar__drawing.html#a5e561926d9c6866e89f8730fa371f029">get_canonical_ordering</a> (embedding, outer_face)</td></tr>
<tr class="separator:a5e561926d9c6866e89f8730fa371f029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5ec6675aba9215ee603d9eec914f79"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1planar__drawing.html#ade5ec6675aba9215ee603d9eec914f79">triangulate_face</a> (embedding, v1, v2)</td></tr>
<tr class="separator:ade5ec6675aba9215ee603d9eec914f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08ac4a90fdc11925daf5b94ed0789ac3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1planar__drawing.html#a08ac4a90fdc11925daf5b94ed0789ac3">triangulate_embedding</a> (embedding, fully_triangulate=True)</td></tr>
<tr class="separator:a08ac4a90fdc11925daf5b94ed0789ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf4bd4ab4a56044a6fa886186b84487"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1planar__drawing.html#a2bf4bd4ab4a56044a6fa886186b84487">make_bi_connected</a> (embedding, starting_node, outgoing_node, edges_counted)</td></tr>
<tr class="separator:a2bf4bd4ab4a56044a6fa886186b84487"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac8d92cba8c047a320c16ffdf2684e58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d92cba8c047a320c16ffdf2684e58c">&#9670;&nbsp;</a></span>combinatorial_embedding_to_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planar_drawing.combinatorial_embedding_to_pos </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>embedding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fully_triangulate</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Assigns every node a (x, y) position based on the given embedding

The algorithm iteratively inserts nodes of the input graph in a certain
order and rearranges previously inserted nodes so that the planar drawing
stays valid. This is done efficiently by only maintaining relative
positions during the node placements and calculating the absolute positions
at the end. For more information see [1]_.

Parameters
----------
embedding : nx.PlanarEmbedding
    This defines the order of the edges

fully_triangulate : bool
    If set to True the algorithm adds edges to a copy of the input
    embedding and makes it chordal.

Returns
-------
pos : dict
    Maps each node to a tuple that defines the (x, y) position

References
----------
.. [1] M. Chrobak and T.H. Payne:
    A Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989
    http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677</pre> 
</div>
</div>
<a id="a5e561926d9c6866e89f8730fa371f029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e561926d9c6866e89f8730fa371f029">&#9670;&nbsp;</a></span>get_canonical_ordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planar_drawing.get_canonical_ordering </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>embedding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>outer_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a canonical ordering of the nodes

The canonical ordering of nodes (v1, ..., vn) must fulfill the following
conditions:
(See Lemma 1 in [2]_)

- For the subgraph G_k of the input graph induced by v1, ..., vk it holds:
    - 2-connected
    - internally triangulated
    - the edge (v1, v2) is part of the outer face
- For a node v(k+1) the following holds:
    - The node v(k+1) is part of the outer face of G_k
    - It has at least two neighbors in G_k
    - All neighbors of v(k+1) in G_k lie consecutively on the outer face of
      G_k (excluding the edge (v1, v2)).

The algorithm used here starts with G_n (containing all nodes). It first
selects the nodes v1 and v2. And then tries to find the order of the other
nodes by checking which node can be removed in order to fulfill the
conditions mentioned above. This is done by calculating the number of
chords of nodes on the outer face. For more information see [1]_.

Parameters
----------
embedding : nx.PlanarEmbedding
    The embedding must be triangulated
outer_face : list
    The nodes on the outer face of the graph

Returns
-------
ordering : list
    A list of tuples `(vk, wp_wq)`. Here `vk` is the node at this position
    in the canonical ordering. The element `wp_wq` is a list of nodes that
    make up the outer face of G_k.

References
----------
.. [1] Steven Chaplick.
    Canonical Orders of Planar Graphs and (some of) Their Applications 2015
    https://wuecampus2.uni-wuerzburg.de/moodle/pluginfile.php/545727/mod_resource/content/0/vg-ss15-vl03-canonical-orders-druckversion.pdf
.. [2] M. Chrobak and T.H. Payne:
    A Linear-time Algorithm for Drawing a Planar Graph on a Grid 1989
    http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.51.6677</pre> 
</div>
</div>
<a id="a2bf4bd4ab4a56044a6fa886186b84487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf4bd4ab4a56044a6fa886186b84487">&#9670;&nbsp;</a></span>make_bi_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planar_drawing.make_bi_connected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>embedding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>starting_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>outgoing_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edges_counted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Triangulate a face and make it 2-connected

This method also adds all edges on the face to `edges_counted`.

Parameters
----------
embedding: nx.PlanarEmbedding
    The embedding that defines the faces
starting_node : node
    A node on the face
outgoing_node : node
    A node such that the half edge (starting_node, outgoing_node) belongs
    to the face
edges_counted: set
    Set of all half-edges that belong to a face that have been visited

Returns
-------
face_nodes: list
    A list of all nodes at the border of this face
</pre> 
</div>
</div>
<a id="a982f71be29109cd0fdaa238cf0551a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982f71be29109cd0fdaa238cf0551a23">&#9670;&nbsp;</a></span>set_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planar_drawing.set_position </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>remaining_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y_coordinate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Helper method to calculate the absolute position of nodes.</pre> 
</div>
</div>
<a id="a08ac4a90fdc11925daf5b94ed0789ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08ac4a90fdc11925daf5b94ed0789ac3">&#9670;&nbsp;</a></span>triangulate_embedding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planar_drawing.triangulate_embedding </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>embedding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fully_triangulate</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Triangulates the embedding.

Traverses faces of the embedding and adds edges to a copy of the
embedding to triangulate it.
The method also ensures that the resulting graph is 2-connected by adding
edges if the same vertex is contained twice on a path around a face.

Parameters
----------
embedding : nx.PlanarEmbedding
    The input graph must contain at least 3 nodes.

fully_triangulate : bool
    If set to False the face with the most nodes is chooses as outer face.
    This outer face does not get triangulated.

Returns
-------
(embedding, outer_face) : (nx.PlanarEmbedding, list) tuple
    The element `embedding` is a new embedding containing all edges from
    the input embedding and the additional edges to triangulate the graph.
    The element `outer_face` is a list of nodes that lie on the outer face.
    If the graph is fully triangulated these are three arbitrary connected
    nodes.</pre> 
</div>
</div>
<a id="ade5ec6675aba9215ee603d9eec914f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5ec6675aba9215ee603d9eec914f79">&#9670;&nbsp;</a></span>triangulate_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planar_drawing.triangulate_face </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>embedding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Triangulates the face given by half edge (v, w)

Parameters
----------
embedding : nx.PlanarEmbedding
v1 : node
    The half-edge (v1, v2) belongs to the face that gets triangulated
v2 : node
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
