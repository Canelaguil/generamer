<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.centrality.closeness Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1centrality.html">centrality</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1centrality_1_1closeness.html">closeness</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.centrality.closeness Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a67a23d82c67f6bccea696620781cbee4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1centrality_1_1closeness.html#a67a23d82c67f6bccea696620781cbee4">closeness_centrality</a> (G, u=None, distance=None, wf_improved=True)</td></tr>
<tr class="separator:a67a23d82c67f6bccea696620781cbee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c77443fdb449686cfc2c95b1db242ec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1centrality_1_1closeness.html#a1c77443fdb449686cfc2c95b1db242ec">incremental_closeness_centrality</a> (G, edge, prev_cc=None, insertion=True, wf_improved=True)</td></tr>
<tr class="separator:a1c77443fdb449686cfc2c95b1db242ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Closeness centrality measures.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a67a23d82c67f6bccea696620781cbee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a23d82c67f6bccea696620781cbee4">&#9670;&nbsp;</a></span>closeness_centrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.centrality.closeness.closeness_centrality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wf_improved</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute closeness centrality for nodes.

Closeness centrality [1]_ of a node `u` is the reciprocal of the
average shortest path distance to `u` over all `n-1` reachable nodes.

.. math::

    C(u) = \frac{n - 1}{\sum_{v=1}^{n-1} d(v, u)},

where `d(v, u)` is the shortest-path distance between `v` and `u`,
and `n` is the number of nodes that can reach `u`. Notice that the
closeness distance function computes the incoming distance to `u`
for directed graphs. To use outward distance, act on `G.reverse()`.

Notice that higher values of closeness indicate higher centrality.

Wasserman and Faust propose an improved formula for graphs with
more than one connected component. The result is "a ratio of the
fraction of actors in the group who are reachable, to the average
distance" from the reachable actors [2]_. You might think this
scale factor is inverted but it is not. As is, nodes from small
components receive a smaller closeness value. Letting `N` denote
the number of nodes in the graph,

.. math::

    C_{WF}(u) = \frac{n-1}{N-1} \frac{n - 1}{\sum_{v=1}^{n-1} d(v, u)},

Parameters
----------
G : graph
  A NetworkX graph

u : node, optional
  Return only the value for node u

distance : edge attribute key, optional (default=None)
  Use the specified edge attribute as the edge distance in shortest
  path calculations

wf_improved : bool, optional (default=True)
  If True, scale by the fraction of nodes reachable. This gives the
  Wasserman and Faust improved formula. For single component graphs
  it is the same as the original formula.

Returns
-------
nodes : dictionary
  Dictionary of nodes with closeness centrality as the value.

See Also
--------
betweenness_centrality, load_centrality, eigenvector_centrality,
degree_centrality, incremental_closeness_centrality

Notes
-----
The closeness centrality is normalized to `(n-1)/(|G|-1)` where
`n` is the number of nodes in the connected part of graph
containing the node.  If the graph is not completely connected,
this algorithm computes the closeness centrality for each
connected part separately scaled by that parts size.

If the 'distance' keyword is set to an edge attribute key then the
shortest-path length will be computed using Dijkstra's algorithm with
that edge attribute as the edge weight.

The closeness centrality uses *inward* distance to a node, not outward.
If you want to use outword distances apply the function to `G.reverse()`

In NetworkX 2.2 and earlier a bug caused Dijkstra's algorithm to use the
outward distance rather than the inward distance. If you use a 'distance'
keyword and a DiGraph, your results will change between v2.2 and v2.3.

References
----------
.. [1] Linton C. Freeman: Centrality in networks: I.
   Conceptual clarification. Social Networks 1:215-239, 1979.
   https://doi.org/10.1016/0378-8733(78)90021-7
.. [2] pg. 201 of Wasserman, S. and Faust, K.,
   Social Network Analysis: Methods and Applications, 1994,
   Cambridge University Press.
</pre> 
</div>
</div>
<a id="a1c77443fdb449686cfc2c95b1db242ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c77443fdb449686cfc2c95b1db242ec">&#9670;&nbsp;</a></span>incremental_closeness_centrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.centrality.closeness.incremental_closeness_centrality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prev_cc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>insertion</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wf_improved</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Incremental closeness centrality for nodes.

Compute closeness centrality for nodes using level-based work filtering
as described in Incremental Algorithms for Closeness Centrality by Sariyuce et al.

Level-based work filtering detects unnecessary updates to the closeness
centrality and filters them out.

---
From "Incremental Algorithms for Closeness Centrality":

Theorem 1: Let :math:`G = (V, E)` be a graph and u and v be two vertices in V
such that there is no edge (u, v) in E. Let :math:`G' = (V, E \cup uv)`
Then :math:`cc[s] = cc'[s]` if and only if :math:`\left|dG(s, u) - dG(s, v)\right| \leq 1`.

Where :math:`dG(u, v)` denotes the length of the shortest path between
two vertices u, v in a graph G, cc[s] is the closeness centrality for a
vertex s in V, and cc'[s] is the closeness centrality for a
vertex s in V, with the (u, v) edge added.
---

We use Theorem 1 to filter out updates when adding or removing an edge.
When adding an edge (u, v), we compute the shortest path lengths from all
other nodes to u and to v before the node is added. When removing an edge,
we compute the shortest path lengths after the edge is removed. Then we
apply Theorem 1 to use previously computed closeness centrality for nodes
where :math:`\left|dG(s, u) - dG(s, v)\right| \leq 1`. This works only for
undirected, unweighted graphs; the distance argument is not supported.

Closeness centrality [1]_ of a node `u` is the reciprocal of the
sum of the shortest path distances from `u` to all `n-1` other nodes.
Since the sum of distances depends on the number of nodes in the
graph, closeness is normalized by the sum of minimum possible
distances `n-1`.

.. math::

    C(u) = \frac{n - 1}{\sum_{v=1}^{n-1} d(v, u)},

where `d(v, u)` is the shortest-path distance between `v` and `u`,
and `n` is the number of nodes in the graph.

Notice that higher values of closeness indicate higher centrality.

Parameters
----------
G : graph
  A NetworkX graph

edge : tuple
  The modified edge (u, v) in the graph.

prev_cc : dictionary
  The previous closeness centrality for all nodes in the graph.

insertion : bool, optional
  If True (default) the edge was inserted, otherwise it was deleted from the graph.

wf_improved : bool, optional (default=True)
  If True, scale by the fraction of nodes reachable. This gives the
  Wasserman and Faust improved formula. For single component graphs
  it is the same as the original formula.

Returns
-------
nodes : dictionary
  Dictionary of nodes with closeness centrality as the value.

See Also
--------
betweenness_centrality, load_centrality, eigenvector_centrality,
degree_centrality, closeness_centrality

Notes
-----
The closeness centrality is normalized to `(n-1)/(|G|-1)` where
`n` is the number of nodes in the connected part of graph
containing the node.  If the graph is not completely connected,
this algorithm computes the closeness centrality for each
connected part separately.

References
----------
.. [1] Freeman, L.C., 1979. Centrality in networks: I.
   Conceptual clarification.  Social Networks 1, 215--239.
   https://doi.org/10.1016/0378-8733(78)90021-7
.. [2] Sariyuce, A.E. ; Kaya, K. ; Saule, E. ; Catalyiirek, U.V. Incremental
   Algorithms for Closeness Centrality. 2013 IEEE International Conference on Big Data
   http://sariyuce.com/papers/bigdata13.pdf
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
