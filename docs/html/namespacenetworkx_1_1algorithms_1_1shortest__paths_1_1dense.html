<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.shortest_paths.dense Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths.html">shortest_paths</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1dense.html">dense</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.shortest_paths.dense Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0f0fbabf2673e685c7e349ed13c2917b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1dense.html#a0f0fbabf2673e685c7e349ed13c2917b">floyd_warshall_numpy</a> (G, nodelist=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a0f0fbabf2673e685c7e349ed13c2917b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a720bd1dfc4a1a191a840459462076a09"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1dense.html#a720bd1dfc4a1a191a840459462076a09">floyd_warshall_predecessor_and_distance</a> (G, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a720bd1dfc4a1a191a840459462076a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bba22b986bd6f786d0e44dc150339e9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1dense.html#a1bba22b986bd6f786d0e44dc150339e9">reconstruct_path</a> (source, target, predecessors)</td></tr>
<tr class="separator:a1bba22b986bd6f786d0e44dc150339e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb334ccd160008dc9b6e788357978db"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1dense.html#aabb334ccd160008dc9b6e788357978db">floyd_warshall</a> (G, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:aabb334ccd160008dc9b6e788357978db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Floyd-Warshall algorithm for shortest paths.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aabb334ccd160008dc9b6e788357978db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb334ccd160008dc9b6e788357978db">&#9670;&nbsp;</a></span>floyd_warshall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.dense.floyd_warshall </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all-pairs shortest path lengths using Floyd's algorithm.

Parameters
----------
G : NetworkX graph

weight: string, optional (default= 'weight')
   Edge data key corresponding to the edge weight.


Returns
-------
distance : dict
   A dictionary,  keyed by source and target, of shortest paths distances
   between nodes.

Notes
-----
Floyd's algorithm is appropriate for finding shortest paths
in dense graphs or graphs with negative weights when Dijkstra's algorithm
fails.  This algorithm can still fail if there are negative cycles.
It has running time $O(n^3)$ with running space of $O(n^2)$.

See Also
--------
floyd_warshall_predecessor_and_distance
floyd_warshall_numpy
all_pairs_shortest_path
all_pairs_shortest_path_length
</pre> 
</div>
</div>
<a id="a0f0fbabf2673e685c7e349ed13c2917b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0fbabf2673e685c7e349ed13c2917b">&#9670;&nbsp;</a></span>floyd_warshall_numpy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.dense.floyd_warshall_numpy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodelist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all-pairs shortest path lengths using Floyd's algorithm.

This algorithm for finding shortest paths takes advantage of
matrix representations of a graph and works well for dense
graphs where all-pairs shortest path lengths are desired.
The results are returned as a NumPy array, distance[i, j],
where i and j are the indexes of two nodes in nodelist.
The entry distance[i, j] is the distance along a shortest
path from i to j. If no path exists the distance is Inf.

Parameters
----------
G : NetworkX graph

nodelist : list, optional (default=G.nodes)
   The rows and columns are ordered by the nodes in nodelist.
   If nodelist is None then the ordering is produced by G.nodes.
   Nodelist should include all nodes in G.

weight: string, optional (default='weight')
   Edge data key corresponding to the edge weight.

Returns
-------
distance : NumPy matrix
    A matrix of shortest path distances between nodes.
    If there is no path between two nodes the value is Inf.

Notes
-----
Floyd's algorithm is appropriate for finding shortest paths in
dense graphs or graphs with negative weights when Dijkstra's
algorithm fails. This algorithm can still fail if there are negative
cycles. It has running time $O(n^3)$ with running space of $O(n^2)$.

Raises
------
NetworkXError
    If nodelist is not a list of the nodes in G.
</pre> 
</div>
</div>
<a id="a720bd1dfc4a1a191a840459462076a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a720bd1dfc4a1a191a840459462076a09">&#9670;&nbsp;</a></span>floyd_warshall_predecessor_and_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.dense.floyd_warshall_predecessor_and_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find all-pairs shortest path lengths using Floyd's algorithm.

Parameters
----------
G : NetworkX graph

weight: string, optional (default= 'weight')
   Edge data key corresponding to the edge weight.

Returns
-------
predecessor,distance : dictionaries
   Dictionaries, keyed by source and target, of predecessors and distances
   in the shortest path.

Examples
--------
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_weighted_edges_from(
...     [
...         ("s", "u", 10),
...         ("s", "x", 5),
...         ("u", "v", 1),
...         ("u", "x", 2),
...         ("v", "y", 1),
...         ("x", "u", 3),
...         ("x", "v", 5),
...         ("x", "y", 2),
...         ("y", "s", 7),
...         ("y", "v", 6),
...     ]
... )
&gt;&gt;&gt; predecessors, _ = nx.floyd_warshall_predecessor_and_distance(G)
&gt;&gt;&gt; print(nx.reconstruct_path("s", "v", predecessors))
['s', 'x', 'u', 'v']

Notes
-----
Floyd's algorithm is appropriate for finding shortest paths
in dense graphs or graphs with negative weights when Dijkstra's algorithm
fails.  This algorithm can still fail if there are negative cycles.
It has running time $O(n^3)$ with running space of $O(n^2)$.

See Also
--------
floyd_warshall
floyd_warshall_numpy
all_pairs_shortest_path
all_pairs_shortest_path_length
</pre> 
</div>
</div>
<a id="a1bba22b986bd6f786d0e44dc150339e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bba22b986bd6f786d0e44dc150339e9">&#9670;&nbsp;</a></span>reconstruct_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.dense.reconstruct_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predecessors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Reconstruct a path from source to target using the predecessors
dict as returned by floyd_warshall_predecessor_and_distance

Parameters
----------
source : node
   Starting node for path

target : node
   Ending node for path

predecessors: dictionary
   Dictionary, keyed by source and target, of predecessors in the
   shortest path, as returned by floyd_warshall_predecessor_and_distance

Returns
-------
path : list
   A list of nodes containing the shortest path from source to target

   If source and target are the same, an empty list is returned

Notes
-----
This function is meant to give more applicability to the
floyd_warshall_predecessor_and_distance function

See Also
--------
floyd_warshall_predecessor_and_distance
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
