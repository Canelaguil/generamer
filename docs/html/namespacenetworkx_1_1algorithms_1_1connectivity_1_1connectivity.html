<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.connectivity.connectivity Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity.html">connectivity</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1connectivity.html">connectivity</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.connectivity.connectivity Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aca19289f3fde41022449704a6c274c3d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1connectivity.html#aca19289f3fde41022449704a6c274c3d">local_node_connectivity</a> (G, s, t, flow_func=None, auxiliary=None, residual=None, cutoff=None)</td></tr>
<tr class="separator:aca19289f3fde41022449704a6c274c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db852a84139c51dcd040682fd93d6c2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1connectivity.html#a8db852a84139c51dcd040682fd93d6c2">node_connectivity</a> (G, s=None, t=None, flow_func=None)</td></tr>
<tr class="separator:a8db852a84139c51dcd040682fd93d6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca77b87901f9285042c33892b563dd3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1connectivity.html#a9ca77b87901f9285042c33892b563dd3">average_node_connectivity</a> (G, flow_func=None)</td></tr>
<tr class="separator:a9ca77b87901f9285042c33892b563dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96366ea097779263aabdb8da1d38e624"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1connectivity.html#a96366ea097779263aabdb8da1d38e624">all_pairs_node_connectivity</a> (G, nbunch=None, flow_func=None)</td></tr>
<tr class="separator:a96366ea097779263aabdb8da1d38e624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161f08d1d45efbffa4096fe164f3942f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1connectivity.html#a161f08d1d45efbffa4096fe164f3942f">local_edge_connectivity</a> (G, s, t, flow_func=None, auxiliary=None, residual=None, cutoff=None)</td></tr>
<tr class="separator:a161f08d1d45efbffa4096fe164f3942f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb56b224f01fa955db4b6223c1074af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1connectivity.html#afdb56b224f01fa955db4b6223c1074af">edge_connectivity</a> (G, s=None, t=None, flow_func=None, cutoff=None)</td></tr>
<tr class="separator:afdb56b224f01fa955db4b6223c1074af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab2b3805544e8db35b37956f9d3d42794"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1connectivity.html#ab2b3805544e8db35b37956f9d3d42794">default_flow_func</a></td></tr>
<tr class="separator:ab2b3805544e8db35b37956f9d3d42794"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Flow based connectivity algorithms
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a96366ea097779263aabdb8da1d38e624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96366ea097779263aabdb8da1d38e624">&#9670;&nbsp;</a></span>all_pairs_node_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.connectivity.all_pairs_node_connectivity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nbunch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute node connectivity between all pairs of nodes of G.

Parameters
----------
G : NetworkX graph
    Undirected graph

nbunch: container
    Container of nodes. If provided node connectivity will be computed
    only over pairs of nodes in nbunch.

flow_func : function
    A function for computing the maximum flow among a pair of nodes.
    The function has to accept at least three parameters: a Digraph,
    a source node, and a target node. And return a residual network
    that follows NetworkX conventions (see :meth:`maximum_flow` for
    details). If flow_func is None, the default maximum flow function
    (:meth:`edmonds_karp`) is used. See below for details. The
    choice of the default function may change from version
    to version and should not be relied on. Default value: None.

Returns
-------
all_pairs : dict
    A dictionary with node connectivity between all pairs of nodes
    in G, or in nbunch if provided.

See also
--------
:meth:`local_node_connectivity`
:meth:`edge_connectivity`
:meth:`local_edge_connectivity`
:meth:`maximum_flow`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`</pre> 
</div>
</div>
<a id="a9ca77b87901f9285042c33892b563dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca77b87901f9285042c33892b563dd3">&#9670;&nbsp;</a></span>average_node_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.connectivity.average_node_connectivity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the average connectivity of a graph G.

The average connectivity `\bar{\kappa}` of a graph G is the average
of local node connectivity over all pairs of nodes of G [1]_ .

.. math::

    \bar{\kappa}(G) = \frac{\sum_{u,v} \kappa_{G}(u,v)}{{n \choose 2}}

Parameters
----------

G : NetworkX graph
    Undirected graph

flow_func : function
    A function for computing the maximum flow among a pair of nodes.
    The function has to accept at least three parameters: a Digraph,
    a source node, and a target node. And return a residual network
    that follows NetworkX conventions (see :meth:`maximum_flow` for
    details). If flow_func is None, the default maximum flow function
    (:meth:`edmonds_karp`) is used. See :meth:`local_node_connectivity`
    for details. The choice of the default function may change from
    version to version and should not be relied on. Default value: None.

Returns
-------
K : float
    Average node connectivity

See also
--------
:meth:`local_node_connectivity`
:meth:`node_connectivity`
:meth:`edge_connectivity`
:meth:`maximum_flow`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`

References
----------
.. [1]  Beineke, L., O. Oellermann, and R. Pippert (2002). The average
        connectivity of a graph. Discrete mathematics 252(1-3), 31-45.
        http://www.sciencedirect.com/science/article/pii/S0012365X01001807</pre> 
</div>
</div>
<a id="afdb56b224f01fa955db4b6223c1074af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb56b224f01fa955db4b6223c1074af">&#9670;&nbsp;</a></span>edge_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.connectivity.edge_connectivity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the edge connectivity of the graph or digraph G.

The edge connectivity is equal to the minimum number of edges that
must be removed to disconnect G or render it trivial. If source
and target nodes are provided, this function returns the local edge
connectivity: the minimum number of edges that must be removed to
break all paths from source to target in G.

Parameters
----------
G : NetworkX graph
    Undirected or directed graph

s : node
    Source node. Optional. Default value: None.

t : node
    Target node. Optional. Default value: None.

flow_func : function
    A function for computing the maximum flow among a pair of nodes.
    The function has to accept at least three parameters: a Digraph,
    a source node, and a target node. And return a residual network
    that follows NetworkX conventions (see :meth:`maximum_flow` for
    details). If flow_func is None, the default maximum flow function
    (:meth:`edmonds_karp`) is used. See below for details. The
    choice of the default function may change from version
    to version and should not be relied on. Default value: None.

cutoff : integer, float
    If specified, the maximum flow algorithm will terminate when the
    flow value reaches or exceeds the cutoff. This is only for the
    algorithms that support the cutoff parameter: e.g., :meth:`edmonds_karp`
    and :meth:`shortest_augmenting_path`. Other algorithms will ignore
    this parameter. Default value: None.

Returns
-------
K : integer
    Edge connectivity for G, or local edge connectivity if source
    and target were provided

Examples
--------
&gt;&gt;&gt; # Platonic icosahedral graph is 5-edge-connected
&gt;&gt;&gt; G = nx.icosahedral_graph()
&gt;&gt;&gt; nx.edge_connectivity(G)
5

You can use alternative flow algorithms for the underlying
maximum flow computation. In dense networks the algorithm
:meth:`shortest_augmenting_path` will usually perform better
than the default :meth:`edmonds_karp`, which is faster for
sparse networks with highly skewed degree distributions.
Alternative flow functions have to be explicitly imported
from the flow package.

&gt;&gt;&gt; from networkx.algorithms.flow import shortest_augmenting_path
&gt;&gt;&gt; nx.edge_connectivity(G, flow_func=shortest_augmenting_path)
5

If you specify a pair of nodes (source and target) as parameters,
this function returns the value of local edge connectivity.

&gt;&gt;&gt; nx.edge_connectivity(G, 3, 7)
5

If you need to perform several local computations among different
pairs of nodes on the same graph, it is recommended that you reuse
the data structures used in the maximum flow computations. See
:meth:`local_edge_connectivity` for details.

Notes
-----
This is a flow based implementation of global edge connectivity.
For undirected graphs the algorithm works by finding a 'small'
dominating set of nodes of G (see algorithm 7 in [1]_ ) and
computing local maximum flow (see :meth:`local_edge_connectivity`)
between an arbitrary node in the dominating set and the rest of
nodes in it. This is an implementation of algorithm 6 in [1]_ .
For directed graphs, the algorithm does n calls to the maximum
flow function. This is an implementation of algorithm 8 in [1]_ .

See also
--------
:meth:`local_edge_connectivity`
:meth:`local_node_connectivity`
:meth:`node_connectivity`
:meth:`maximum_flow`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`
:meth:`k_edge_components`
:meth:`k_edge_subgraphs`

References
----------
.. [1] Abdol-Hossein Esfahanian. Connectivity Algorithms.
    http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf</pre> 
</div>
</div>
<a id="a161f08d1d45efbffa4096fe164f3942f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161f08d1d45efbffa4096fe164f3942f">&#9670;&nbsp;</a></span>local_edge_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.connectivity.local_edge_connectivity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>auxiliary</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>residual</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns local edge connectivity for nodes s and t in G.

Local edge connectivity for two nodes s and t is the minimum number
of edges that must be removed to disconnect them.

This is a flow based implementation of edge connectivity. We compute the
maximum flow on an auxiliary digraph build from the original
network (see below for details). This is equal to the local edge
connectivity because the value of a maximum s-t-flow is equal to the
capacity of a minimum s-t-cut (Ford and Fulkerson theorem) [1]_ .

Parameters
----------
G : NetworkX graph
    Undirected or directed graph

s : node
    Source node

t : node
    Target node

flow_func : function
    A function for computing the maximum flow among a pair of nodes.
    The function has to accept at least three parameters: a Digraph,
    a source node, and a target node. And return a residual network
    that follows NetworkX conventions (see :meth:`maximum_flow` for
    details). If flow_func is None, the default maximum flow function
    (:meth:`edmonds_karp`) is used. See below for details. The
    choice of the default function may change from version
    to version and should not be relied on. Default value: None.

auxiliary : NetworkX DiGraph
    Auxiliary digraph for computing flow based edge connectivity. If
    provided it will be reused instead of recreated. Default value: None.

residual : NetworkX DiGraph
    Residual network to compute maximum flow. If provided it will be
    reused instead of recreated. Default value: None.

cutoff : integer, float
    If specified, the maximum flow algorithm will terminate when the
    flow value reaches or exceeds the cutoff. This is only for the
    algorithms that support the cutoff parameter: :meth:`edmonds_karp`
    and :meth:`shortest_augmenting_path`. Other algorithms will ignore
    this parameter. Default value: None.

Returns
-------
K : integer
    local edge connectivity for nodes s and t.

Examples
--------
This function is not imported in the base NetworkX namespace, so you
have to explicitly import it from the connectivity package:

&gt;&gt;&gt; from networkx.algorithms.connectivity import local_edge_connectivity

We use in this example the platonic icosahedral graph, which has edge
connectivity 5.

&gt;&gt;&gt; G = nx.icosahedral_graph()
&gt;&gt;&gt; local_edge_connectivity(G, 0, 6)
5

If you need to compute local connectivity on several pairs of
nodes in the same graph, it is recommended that you reuse the
data structures that NetworkX uses in the computation: the
auxiliary digraph for edge connectivity, and the residual
network for the underlying maximum flow computation.

Example of how to compute local edge connectivity among
all pairs of nodes of the platonic icosahedral graph reusing
the data structures.

&gt;&gt;&gt; import itertools
&gt;&gt;&gt; # You also have to explicitly import the function for
&gt;&gt;&gt; # building the auxiliary digraph from the connectivity package
&gt;&gt;&gt; from networkx.algorithms.connectivity import build_auxiliary_edge_connectivity
&gt;&gt;&gt; H = build_auxiliary_edge_connectivity(G)
&gt;&gt;&gt; # And the function for building the residual network from the
&gt;&gt;&gt; # flow package
&gt;&gt;&gt; from networkx.algorithms.flow import build_residual_network
&gt;&gt;&gt; # Note that the auxiliary digraph has an edge attribute named capacity
&gt;&gt;&gt; R = build_residual_network(H, "capacity")
&gt;&gt;&gt; result = dict.fromkeys(G, dict())
&gt;&gt;&gt; # Reuse the auxiliary digraph and the residual network by passing them
&gt;&gt;&gt; # as parameters
&gt;&gt;&gt; for u, v in itertools.combinations(G, 2):
...     k = local_edge_connectivity(G, u, v, auxiliary=H, residual=R)
...     result[u][v] = k
&gt;&gt;&gt; all(result[u][v] == 5 for u, v in itertools.combinations(G, 2))
True

You can also use alternative flow algorithms for computing edge
connectivity. For instance, in dense networks the algorithm
:meth:`shortest_augmenting_path` will usually perform better than
the default :meth:`edmonds_karp` which is faster for sparse
networks with highly skewed degree distributions. Alternative flow
functions have to be explicitly imported from the flow package.

&gt;&gt;&gt; from networkx.algorithms.flow import shortest_augmenting_path
&gt;&gt;&gt; local_edge_connectivity(G, 0, 6, flow_func=shortest_augmenting_path)
5

Notes
-----
This is a flow based implementation of edge connectivity. We compute the
maximum flow using, by default, the :meth:`edmonds_karp` algorithm on an
auxiliary digraph build from the original input graph:

If the input graph is undirected, we replace each edge (`u`,`v`) with
two reciprocal arcs (`u`, `v`) and (`v`, `u`) and then we set the attribute
'capacity' for each arc to 1. If the input graph is directed we simply
add the 'capacity' attribute. This is an implementation of algorithm 1
in [1]_.

The maximum flow in the auxiliary network is equal to the local edge
connectivity because the value of a maximum s-t-flow is equal to the
capacity of a minimum s-t-cut (Ford and Fulkerson theorem).

See also
--------
:meth:`edge_connectivity`
:meth:`local_node_connectivity`
:meth:`node_connectivity`
:meth:`maximum_flow`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`

References
----------
.. [1] Abdol-Hossein Esfahanian. Connectivity Algorithms.
    http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf</pre> 
</div>
</div>
<a id="aca19289f3fde41022449704a6c274c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca19289f3fde41022449704a6c274c3d">&#9670;&nbsp;</a></span>local_node_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.connectivity.local_node_connectivity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>auxiliary</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>residual</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes local node connectivity for nodes s and t.

Local node connectivity for two non adjacent nodes s and t is the
minimum number of nodes that must be removed (along with their incident
edges) to disconnect them.

This is a flow based implementation of node connectivity. We compute the
maximum flow on an auxiliary digraph build from the original input
graph (see below for details).

Parameters
----------
G : NetworkX graph
    Undirected graph

s : node
    Source node

t : node
    Target node

flow_func : function
    A function for computing the maximum flow among a pair of nodes.
    The function has to accept at least three parameters: a Digraph,
    a source node, and a target node. And return a residual network
    that follows NetworkX conventions (see :meth:`maximum_flow` for
    details). If flow_func is None, the default maximum flow function
    (:meth:`edmonds_karp`) is used. See below for details. The choice
    of the default function may change from version to version and
    should not be relied on. Default value: None.

auxiliary : NetworkX DiGraph
    Auxiliary digraph to compute flow based node connectivity. It has
    to have a graph attribute called mapping with a dictionary mapping
    node names in G and in the auxiliary digraph. If provided
    it will be reused instead of recreated. Default value: None.

residual : NetworkX DiGraph
    Residual network to compute maximum flow. If provided it will be
    reused instead of recreated. Default value: None.

cutoff : integer, float
    If specified, the maximum flow algorithm will terminate when the
    flow value reaches or exceeds the cutoff. This is only for the
    algorithms that support the cutoff parameter: :meth:`edmonds_karp`
    and :meth:`shortest_augmenting_path`. Other algorithms will ignore
    this parameter. Default value: None.

Returns
-------
K : integer
    local node connectivity for nodes s and t

Examples
--------
This function is not imported in the base NetworkX namespace, so you
have to explicitly import it from the connectivity package:

&gt;&gt;&gt; from networkx.algorithms.connectivity import local_node_connectivity

We use in this example the platonic icosahedral graph, which has node
connectivity 5.

&gt;&gt;&gt; G = nx.icosahedral_graph()
&gt;&gt;&gt; local_node_connectivity(G, 0, 6)
5

If you need to compute local connectivity on several pairs of
nodes in the same graph, it is recommended that you reuse the
data structures that NetworkX uses in the computation: the
auxiliary digraph for node connectivity, and the residual
network for the underlying maximum flow computation.

Example of how to compute local node connectivity among
all pairs of nodes of the platonic icosahedral graph reusing
the data structures.

&gt;&gt;&gt; import itertools
&gt;&gt;&gt; # You also have to explicitly import the function for
&gt;&gt;&gt; # building the auxiliary digraph from the connectivity package
&gt;&gt;&gt; from networkx.algorithms.connectivity import build_auxiliary_node_connectivity
...
&gt;&gt;&gt; H = build_auxiliary_node_connectivity(G)
&gt;&gt;&gt; # And the function for building the residual network from the
&gt;&gt;&gt; # flow package
&gt;&gt;&gt; from networkx.algorithms.flow import build_residual_network
&gt;&gt;&gt; # Note that the auxiliary digraph has an edge attribute named capacity
&gt;&gt;&gt; R = build_residual_network(H, "capacity")
&gt;&gt;&gt; result = dict.fromkeys(G, dict())
&gt;&gt;&gt; # Reuse the auxiliary digraph and the residual network by passing them
&gt;&gt;&gt; # as parameters
&gt;&gt;&gt; for u, v in itertools.combinations(G, 2):
...     k = local_node_connectivity(G, u, v, auxiliary=H, residual=R)
...     result[u][v] = k
...
&gt;&gt;&gt; all(result[u][v] == 5 for u, v in itertools.combinations(G, 2))
True

You can also use alternative flow algorithms for computing node
connectivity. For instance, in dense networks the algorithm
:meth:`shortest_augmenting_path` will usually perform better than
the default :meth:`edmonds_karp` which is faster for sparse
networks with highly skewed degree distributions. Alternative flow
functions have to be explicitly imported from the flow package.

&gt;&gt;&gt; from networkx.algorithms.flow import shortest_augmenting_path
&gt;&gt;&gt; local_node_connectivity(G, 0, 6, flow_func=shortest_augmenting_path)
5

Notes
-----
This is a flow based implementation of node connectivity. We compute the
maximum flow using, by default, the :meth:`edmonds_karp` algorithm (see:
:meth:`maximum_flow`) on an auxiliary digraph build from the original
input graph:

For an undirected graph G having `n` nodes and `m` edges we derive a
directed graph H with `2n` nodes and `2m+n` arcs by replacing each
original node `v` with two nodes `v_A`, `v_B` linked by an (internal)
arc in H. Then for each edge (`u`, `v`) in G we add two arcs
(`u_B`, `v_A`) and (`v_B`, `u_A`) in H. Finally we set the attribute
capacity = 1 for each arc in H [1]_ .

For a directed graph G having `n` nodes and `m` arcs we derive a
directed graph H with `2n` nodes and `m+n` arcs by replacing each
original node `v` with two nodes `v_A`, `v_B` linked by an (internal)
arc (`v_A`, `v_B`) in H. Then for each arc (`u`, `v`) in G we add one arc
(`u_B`, `v_A`) in H. Finally we set the attribute capacity = 1 for
each arc in H.

This is equal to the local node connectivity because the value of
a maximum s-t-flow is equal to the capacity of a minimum s-t-cut.

See also
--------
:meth:`local_edge_connectivity`
:meth:`node_connectivity`
:meth:`minimum_node_cut`
:meth:`maximum_flow`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`

References
----------
.. [1] Kammer, Frank and Hanjo Taubig. Graph Connectivity. in Brandes and
    Erlebach, 'Network Analysis: Methodological Foundations', Lecture
    Notes in Computer Science, Volume 3418, Springer-Verlag, 2005.
    http://www.informatik.uni-augsburg.de/thi/personen/kammer/Graph_Connectivity.pdf</pre> 
</div>
</div>
<a id="a8db852a84139c51dcd040682fd93d6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db852a84139c51dcd040682fd93d6c2">&#9670;&nbsp;</a></span>node_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.connectivity.node_connectivity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns node connectivity for a graph or digraph G.

Node connectivity is equal to the minimum number of nodes that
must be removed to disconnect G or render it trivial. If source
and target nodes are provided, this function returns the local node
connectivity: the minimum number of nodes that must be removed to break
all paths from source to target in G.

Parameters
----------
G : NetworkX graph
    Undirected graph

s : node
    Source node. Optional. Default value: None.

t : node
    Target node. Optional. Default value: None.

flow_func : function
    A function for computing the maximum flow among a pair of nodes.
    The function has to accept at least three parameters: a Digraph,
    a source node, and a target node. And return a residual network
    that follows NetworkX conventions (see :meth:`maximum_flow` for
    details). If flow_func is None, the default maximum flow function
    (:meth:`edmonds_karp`) is used. See below for details. The
    choice of the default function may change from version
    to version and should not be relied on. Default value: None.

Returns
-------
K : integer
    Node connectivity of G, or local node connectivity if source
    and target are provided.

Examples
--------
&gt;&gt;&gt; # Platonic icosahedral graph is 5-node-connected
&gt;&gt;&gt; G = nx.icosahedral_graph()
&gt;&gt;&gt; nx.node_connectivity(G)
5

You can use alternative flow algorithms for the underlying maximum
flow computation. In dense networks the algorithm
:meth:`shortest_augmenting_path` will usually perform better
than the default :meth:`edmonds_karp`, which is faster for
sparse networks with highly skewed degree distributions. Alternative
flow functions have to be explicitly imported from the flow package.

&gt;&gt;&gt; from networkx.algorithms.flow import shortest_augmenting_path
&gt;&gt;&gt; nx.node_connectivity(G, flow_func=shortest_augmenting_path)
5

If you specify a pair of nodes (source and target) as parameters,
this function returns the value of local node connectivity.

&gt;&gt;&gt; nx.node_connectivity(G, 3, 7)
5

If you need to perform several local computations among different
pairs of nodes on the same graph, it is recommended that you reuse
the data structures used in the maximum flow computations. See
:meth:`local_node_connectivity` for details.

Notes
-----
This is a flow based implementation of node connectivity. The
algorithm works by solving $O((n-\delta-1+\delta(\delta-1)/2))$
maximum flow problems on an auxiliary digraph. Where $\delta$
is the minimum degree of G. For details about the auxiliary
digraph and the computation of local node connectivity see
:meth:`local_node_connectivity`. This implementation is based
on algorithm 11 in [1]_.

See also
--------
:meth:`local_node_connectivity`
:meth:`edge_connectivity`
:meth:`maximum_flow`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`

References
----------
.. [1] Abdol-Hossein Esfahanian. Connectivity Algorithms.
    http://www.cse.msu.edu/~cse835/Papers/Graph_connectivity_revised.pdf</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab2b3805544e8db35b37956f9d3d42794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b3805544e8db35b37956f9d3d42794">&#9670;&nbsp;</a></span>default_flow_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">networkx.algorithms.connectivity.connectivity.default_flow_func</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
