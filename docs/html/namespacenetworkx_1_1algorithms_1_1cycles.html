<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.cycles Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cycles.html">cycles</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.cycles Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5bfa96f32eeb2c330eabaccac3fcbf47"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cycles.html#a5bfa96f32eeb2c330eabaccac3fcbf47">cycle_basis</a> (G, root=None)</td></tr>
<tr class="separator:a5bfa96f32eeb2c330eabaccac3fcbf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24027fc741f4f11cef8f92482a159943"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cycles.html#a24027fc741f4f11cef8f92482a159943">simple_cycles</a> (G)</td></tr>
<tr class="separator:a24027fc741f4f11cef8f92482a159943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bedb7146b5c717fd6489a63bdfefe3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cycles.html#ae7bedb7146b5c717fd6489a63bdfefe3">recursive_simple_cycles</a> (G)</td></tr>
<tr class="separator:ae7bedb7146b5c717fd6489a63bdfefe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86186b756148879600221a62b7f006b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cycles.html#ab86186b756148879600221a62b7f006b">find_cycle</a> (G, source=None, orientation=None)</td></tr>
<tr class="separator:ab86186b756148879600221a62b7f006b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481131a004cc5e80148f5a9650871650"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cycles.html#a481131a004cc5e80148f5a9650871650">minimum_cycle_basis</a> (G, weight=None)</td></tr>
<tr class="separator:a481131a004cc5e80148f5a9650871650"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">========================
Cycle finding algorithms
========================
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a5bfa96f32eeb2c330eabaccac3fcbf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfa96f32eeb2c330eabaccac3fcbf47">&#9670;&nbsp;</a></span>cycle_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cycles.cycle_basis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>root</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of cycles which form a basis for cycles of G.

A basis for cycles of a network is a minimal collection of
cycles such that any cycle in the network can be written
as a sum of cycles in the basis.  Here summation of cycles
is defined as "exclusive or" of the edges. Cycle bases are
useful, e.g. when deriving equations for electric circuits
using Kirchhoff's Laws.

Parameters
----------
G : NetworkX Graph
root : node, optional
   Specify starting node for basis.

Returns
-------
A list of cycle lists.  Each cycle list is a list of nodes
which forms a cycle (loop) in G.

Examples
--------
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; nx.add_cycle(G, [0, 1, 2, 3])
&gt;&gt;&gt; nx.add_cycle(G, [0, 3, 4, 5])
&gt;&gt;&gt; print(nx.cycle_basis(G, 0))
[[3, 4, 5, 0], [1, 2, 3, 0]]

Notes
-----
This is adapted from algorithm CACM 491 [1]_.

References
----------
.. [1] Paton, K. An algorithm for finding a fundamental set of
   cycles of a graph. Comm. ACM 12, 9 (Sept 1969), 514-518.

See Also
--------
simple_cycles
</pre> 
</div>
</div>
<a id="ab86186b756148879600221a62b7f006b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86186b756148879600221a62b7f006b">&#9670;&nbsp;</a></span>find_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cycles.find_cycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>orientation</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a cycle found via depth-first traversal.

The cycle is a list of edges indicating the cyclic path.
Orientation of directed edges is controlled by `orientation`.

Parameters
----------
G : graph
    A directed/undirected graph/multigraph.

source : node, list of nodes
    The node from which the traversal begins. If None, then a source
    is chosen arbitrarily and repeatedly until all edges from each node in
    the graph are searched.

orientation : None | 'original' | 'reverse' | 'ignore' (default: None)
    For directed graphs and directed multigraphs, edge traversals need not
    respect the original orientation of the edges.
    When set to 'reverse' every edge is traversed in the reverse direction.
    When set to 'ignore', every edge is treated as undirected.
    When set to 'original', every edge is treated as directed.
    In all three cases, the yielded edge tuples add a last entry to
    indicate the direction in which that edge was traversed.
    If orientation is None, the yielded edge has no direction indicated.
    The direction is respected, but not reported.

Returns
-------
edges : directed edges
    A list of directed edges indicating the path taken for the loop.
    If no cycle is found, then an exception is raised.
    For graphs, an edge is of the form `(u, v)` where `u` and `v`
    are the tail and head of the edge as determined by the traversal.
    For multigraphs, an edge is of the form `(u, v, key)`, where `key` is
    the key of the edge. When the graph is directed, then `u` and `v`
    are always in the order of the actual directed edge.
    If orientation is not None then the edge tuple is extended to include
    the direction of traversal ('forward' or 'reverse') on that edge.

Raises
------
NetworkXNoCycle
    If no cycle was found.

Examples
--------
In this example, we construct a DAG and find, in the first call, that there
are no directed cycles, and so an exception is raised. In the second call,
we ignore edge orientations and find that there is an undirected cycle.
Note that the second call finds a directed cycle while effectively
traversing an undirected graph, and so, we found an "undirected cycle".
This means that this DAG structure does not form a directed tree (which
is also known as a polytree).

&gt;&gt;&gt; G = nx.DiGraph([(0, 1), (0, 2), (1, 2)])
&gt;&gt;&gt; nx.find_cycle(G, orientation="original")
Traceback (most recent call last):
    ...
networkx.exception.NetworkXNoCycle: No cycle found.
&gt;&gt;&gt; list(nx.find_cycle(G, orientation="ignore"))
[(0, 1, 'forward'), (1, 2, 'forward'), (0, 2, 'reverse')]

See Also
--------
simple_cycles
</pre> 
</div>
</div>
<a id="a481131a004cc5e80148f5a9650871650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481131a004cc5e80148f5a9650871650">&#9670;&nbsp;</a></span>minimum_cycle_basis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cycles.minimum_cycle_basis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a minimum weight cycle basis for G

Minimum weight means a cycle basis for which the total weight
(length for unweighted graphs) of all the cycles is minimum.

Parameters
----------
G : NetworkX Graph
weight: string
    name of the edge attribute to use for edge weights

Returns
-------
A list of cycle lists.  Each cycle list is a list of nodes
which forms a cycle (loop) in G. Note that the nodes are not
necessarily returned in a order by which they appear in the cycle

Examples
--------
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; nx.add_cycle(G, [0, 1, 2, 3])
&gt;&gt;&gt; nx.add_cycle(G, [0, 3, 4, 5])
&gt;&gt;&gt; print([sorted(c) for c in nx.minimum_cycle_basis(G)])
[[0, 1, 2, 3], [0, 3, 4, 5]]

References:
    [1] Kavitha, Telikepalli, et al. "An O(m^2n) Algorithm for
    Minimum Cycle Basis of Graphs."
    http://link.springer.com/article/10.1007/s00453-007-9064-z
    [2] de Pina, J. 1995. Applications of shortest path methods.
    Ph.D. thesis, University of Amsterdam, Netherlands

See Also
--------
simple_cycles, cycle_basis
</pre> 
</div>
</div>
<a id="ae7bedb7146b5c717fd6489a63bdfefe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bedb7146b5c717fd6489a63bdfefe3">&#9670;&nbsp;</a></span>recursive_simple_cycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cycles.recursive_simple_cycles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find simple cycles (elementary circuits) of a directed graph.

A `simple cycle`, or `elementary circuit`, is a closed path where
no node appears twice. Two elementary circuits are distinct if they
are not cyclic permutations of each other.

This version uses a recursive algorithm to build a list of cycles.
You should probably use the iterator version called simple_cycles().
Warning: This recursive version uses lots of RAM!

Parameters
----------
G : NetworkX DiGraph
   A directed graph

Returns
-------
A list of cycles, where each cycle is represented by a list of nodes
along the cycle.

Example:

&gt;&gt;&gt; edges = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 0), (2, 1), (2, 2)]
&gt;&gt;&gt; G = nx.DiGraph(edges)
&gt;&gt;&gt; nx.recursive_simple_cycles(G)
[[0], [2], [0, 1, 2], [0, 2], [1, 2]]

See Also
--------
cycle_basis (for undirected graphs)

Notes
-----
The implementation follows pp. 79-80 in [1]_.

The time complexity is $O((n+e)(c+1))$ for $n$ nodes, $e$ edges and $c$
elementary circuits.

References
----------
.. [1] Finding all the elementary circuits of a directed graph.
   D. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.
   https://doi.org/10.1137/0204007

See Also
--------
simple_cycles, cycle_basis
</pre> 
</div>
</div>
<a id="a24027fc741f4f11cef8f92482a159943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24027fc741f4f11cef8f92482a159943">&#9670;&nbsp;</a></span>simple_cycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cycles.simple_cycles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find simple cycles (elementary circuits) of a directed graph.

A `simple cycle`, or `elementary circuit`, is a closed path where
no node appears twice. Two elementary circuits are distinct if they
are not cyclic permutations of each other.

This is a nonrecursive, iterator/generator version of Johnson's
algorithm [1]_.  There may be better algorithms for some cases [2]_ [3]_.

Parameters
----------
G : NetworkX DiGraph
   A directed graph

Returns
-------
cycle_generator: generator
   A generator that produces elementary cycles of the graph.
   Each cycle is represented by a list of nodes along the cycle.

Examples
--------
&gt;&gt;&gt; edges = [(0, 0), (0, 1), (0, 2), (1, 2), (2, 0), (2, 1), (2, 2)]
&gt;&gt;&gt; G = nx.DiGraph(edges)
&gt;&gt;&gt; len(list(nx.simple_cycles(G)))
5

To filter the cycles so that they don't include certain nodes or edges,
copy your graph and eliminate those nodes or edges before calling

&gt;&gt;&gt; copyG = G.copy()
&gt;&gt;&gt; copyG.remove_nodes_from([1])
&gt;&gt;&gt; copyG.remove_edges_from([(0, 1)])
&gt;&gt;&gt; len(list(nx.simple_cycles(copyG)))
3


Notes
-----
The implementation follows pp. 79-80 in [1]_.

The time complexity is $O((n+e)(c+1))$ for $n$ nodes, $e$ edges and $c$
elementary circuits.

References
----------
.. [1] Finding all the elementary circuits of a directed graph.
   D. B. Johnson, SIAM Journal on Computing 4, no. 1, 77-84, 1975.
   https://doi.org/10.1137/0204007
.. [2] Enumerating the cycles of a digraph: a new preprocessing strategy.
   G. Loizou and P. Thanish, Information Sciences, v. 27, 163-182, 1982.
.. [3] A search strategy for the elementary cycles of a directed graph.
   J.L. Szwarcfiter and P.E. Lauer, BIT NUMERICAL MATHEMATICS,
   v. 16, no. 2, 192-204, 1976.

See Also
--------
cycle_basis
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
