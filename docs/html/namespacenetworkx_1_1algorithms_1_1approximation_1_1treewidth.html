<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.approximation.treewidth Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation.html">approximation</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1treewidth.html">treewidth</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.approximation.treewidth Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1approximation_1_1treewidth_1_1MinDegreeHeuristic.html">MinDegreeHeuristic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a61fc0c9223a43796cfaca14a69fe0a8c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1treewidth.html#a61fc0c9223a43796cfaca14a69fe0a8c">treewidth_min_degree</a> (G)</td></tr>
<tr class="separator:a61fc0c9223a43796cfaca14a69fe0a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f9b50c25683439899cf76c8b7baeca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1treewidth.html#a80f9b50c25683439899cf76c8b7baeca">treewidth_min_fill_in</a> (G)</td></tr>
<tr class="separator:a80f9b50c25683439899cf76c8b7baeca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb0e946b540b4d1287654403c7e38ba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1treewidth.html#a0bb0e946b540b4d1287654403c7e38ba">min_fill_in_heuristic</a> (graph)</td></tr>
<tr class="separator:a0bb0e946b540b4d1287654403c7e38ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237be07bcad07dfb38016e0938bbfcfc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1treewidth.html#a237be07bcad07dfb38016e0938bbfcfc">treewidth_decomp</a> (G, heuristic=<a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1treewidth.html#a0bb0e946b540b4d1287654403c7e38ba">min_fill_in_heuristic</a>)</td></tr>
<tr class="separator:a237be07bcad07dfb38016e0938bbfcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions for computing treewidth decomposition.

Treewidth of an undirected graph is a number associated with the graph.
It can be defined as the size of the largest vertex set (bag) in a tree
decomposition of the graph minus one.

`Wikipedia: Treewidth &lt;https://en.wikipedia.org/wiki/Treewidth&gt;`_

The notions of treewidth and tree decomposition have gained their
attractiveness partly because many graph and network problems that are
intractable (e.g., NP-hard) on arbitrary graphs become efficiently
solvable (e.g., with a linear time algorithm) when the treewidth of the
input graphs is bounded by a constant [1]_ [2]_.

There are two different functions for computing a tree decomposition:
:func:`treewidth_min_degree` and :func:`treewidth_min_fill_in`.

.. [1] Hans L. Bodlaender and Arie M. C. A. Koster. 2010. "Treewidth
      computations I.Upper bounds". Inf. Comput. 208, 3 (March 2010),259-275.
      http://dx.doi.org/10.1016/j.ic.2009.03.008

.. [2] Hans L. Bodlaender. "Discovering Treewidth". Institute of Information
      and Computing Sciences, Utrecht University.
      Technical Report UU-CS-2005-018.
      http://www.cs.uu.nl

.. [3] K. Wang, Z. Lu, and J. Hicks *Treewidth*.
      https://web.archive.org/web/20210507025929/http://web.eecs.utk.edu/~cphill25/cs594_spring2015_projects/treewidth.pdf</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a0bb0e946b540b4d1287654403c7e38ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb0e946b540b4d1287654403c7e38ba">&#9670;&nbsp;</a></span>min_fill_in_heuristic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.treewidth.min_fill_in_heuristic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Implements the Minimum Degree heuristic.

Returns the node from the graph, where the number of edges added when
turning the neighbourhood of the chosen node into clique is as small as
possible. This algorithm chooses the nodes using the Minimum Fill-In
heuristic. The running time of the algorithm is :math:`O(V^3)` and it uses
additional constant memory.</pre> 
</div>
</div>
<a id="a237be07bcad07dfb38016e0938bbfcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237be07bcad07dfb38016e0938bbfcfc">&#9670;&nbsp;</a></span>treewidth_decomp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.treewidth.treewidth_decomp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>heuristic</em> = <code><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1treewidth.html#a0bb0e946b540b4d1287654403c7e38ba">min_fill_in_heuristic</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a treewidth decomposition using the passed heuristic.

Parameters
----------
G : NetworkX graph
heuristic : heuristic function

Returns
-------
Treewidth decomposition : (int, Graph) tuple
    2-tuple with treewidth and the corresponding decomposed tree.
</pre> 
</div>
</div>
<a id="a61fc0c9223a43796cfaca14a69fe0a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fc0c9223a43796cfaca14a69fe0a8c">&#9670;&nbsp;</a></span>treewidth_min_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.treewidth.treewidth_min_degree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a treewidth decomposition using the Minimum Degree heuristic.

The heuristic chooses the nodes according to their degree, i.e., first
the node with the lowest degree is chosen, then the graph is updated
and the corresponding node is removed. Next, a new node with the lowest
degree is chosen, and so on.

Parameters
----------
G : NetworkX graph

Returns
-------
Treewidth decomposition : (int, Graph) tuple
      2-tuple with treewidth and the corresponding decomposed tree.
</pre> 
</div>
</div>
<a id="a80f9b50c25683439899cf76c8b7baeca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f9b50c25683439899cf76c8b7baeca">&#9670;&nbsp;</a></span>treewidth_min_fill_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.treewidth.treewidth_min_fill_in </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a treewidth decomposition using the Minimum Fill-in heuristic.

The heuristic chooses a node from the graph, where the number of edges
added turning the neighbourhood of the chosen node into clique is as
small as possible.

Parameters
----------
G : NetworkX graph

Returns
-------
Treewidth decomposition : (int, Graph) tuple
    2-tuple with treewidth and the corresponding decomposed tree.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
