<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.dag Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html">dag</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.dag Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad83d7e1164190f67e4f648e8bb0d1df8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#ad83d7e1164190f67e4f648e8bb0d1df8">descendants</a> (G, source)</td></tr>
<tr class="separator:ad83d7e1164190f67e4f648e8bb0d1df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5931c11c1d779c650c90cb1594f738e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#ab5931c11c1d779c650c90cb1594f738e">ancestors</a> (G, source)</td></tr>
<tr class="separator:ab5931c11c1d779c650c90cb1594f738e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92320d5ff79b60e340b1b386a71b5b33"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#a92320d5ff79b60e340b1b386a71b5b33">has_cycle</a> (G)</td></tr>
<tr class="separator:a92320d5ff79b60e340b1b386a71b5b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282871f30feeb5981563367cb9800007"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#a282871f30feeb5981563367cb9800007">is_directed_acyclic_graph</a> (G)</td></tr>
<tr class="separator:a282871f30feeb5981563367cb9800007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90baa3a72db8f7a1da7098d87c7e64b4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#a90baa3a72db8f7a1da7098d87c7e64b4">topological_generations</a> (G)</td></tr>
<tr class="separator:a90baa3a72db8f7a1da7098d87c7e64b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21f66ba4608c33f0e992f552694bd6d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#ab21f66ba4608c33f0e992f552694bd6d">topological_sort</a> (G)</td></tr>
<tr class="separator:ab21f66ba4608c33f0e992f552694bd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718a056e7a26627ee5bd12d1db32e0be"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#a718a056e7a26627ee5bd12d1db32e0be">lexicographical_topological_sort</a> (G, key=None)</td></tr>
<tr class="separator:a718a056e7a26627ee5bd12d1db32e0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074659844f762889735522a3da549efa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#a074659844f762889735522a3da549efa">all_topological_sorts</a> (G)</td></tr>
<tr class="separator:a074659844f762889735522a3da549efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecc4e0b39707797a07ead610a9ecdf7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#a4ecc4e0b39707797a07ead610a9ecdf7">is_aperiodic</a> (G)</td></tr>
<tr class="separator:a4ecc4e0b39707797a07ead610a9ecdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004f6e48d82f3d56b5e5c906da0986d9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#a004f6e48d82f3d56b5e5c906da0986d9">transitive_closure</a> (G, reflexive=False)</td></tr>
<tr class="separator:a004f6e48d82f3d56b5e5c906da0986d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461cd43df92c1a7dcb7e5605d750801f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#a461cd43df92c1a7dcb7e5605d750801f">transitive_closure_dag</a> (G, topo_order=None)</td></tr>
<tr class="separator:a461cd43df92c1a7dcb7e5605d750801f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c177fd8eccf2503a153ddc6f73a8c2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#ad4c177fd8eccf2503a153ddc6f73a8c2">transitive_reduction</a> (G)</td></tr>
<tr class="separator:ad4c177fd8eccf2503a153ddc6f73a8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269f94d57f2a7ef7559754d4f6d8032d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#a269f94d57f2a7ef7559754d4f6d8032d">antichains</a> (G, topo_order=None)</td></tr>
<tr class="separator:a269f94d57f2a7ef7559754d4f6d8032d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfb030d483ff43f5f7da173db47ee4a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#abbfb030d483ff43f5f7da173db47ee4a">dag_longest_path</a> (G, weight=&quot;weight&quot;, default_weight=1, topo_order=None)</td></tr>
<tr class="separator:abbfb030d483ff43f5f7da173db47ee4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cb4d4b25d9d700fe878ddf4044ed72"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#aa5cb4d4b25d9d700fe878ddf4044ed72">dag_longest_path_length</a> (G, weight=&quot;weight&quot;, default_weight=1)</td></tr>
<tr class="separator:aa5cb4d4b25d9d700fe878ddf4044ed72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6432469cf28a68ed889941626729667"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#aa6432469cf28a68ed889941626729667">root_to_leaf_paths</a> (G)</td></tr>
<tr class="separator:aa6432469cf28a68ed889941626729667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63ef5d8c287a81f02cc897e51cc662f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#ac63ef5d8c287a81f02cc897e51cc662f">dag_to_branching</a> (G)</td></tr>
<tr class="separator:ac63ef5d8c287a81f02cc897e51cc662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae9077dab1fc86c2cf208bff64fd4d594"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1dag.html#ae9077dab1fc86c2cf208bff64fd4d594">chaini</a></td></tr>
<tr class="separator:ae9077dab1fc86c2cf208bff64fd4d594"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Algorithms for directed acyclic graphs (DAGs).

Note that most of these functions are only guaranteed to work for DAGs.
In general, these functions do not check for acyclic-ness, so it is up
to the user to check for that.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a074659844f762889735522a3da549efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074659844f762889735522a3da549efa">&#9670;&nbsp;</a></span>all_topological_sorts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.all_topological_sorts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a generator of _all_ topological sorts of the directed graph G.

A topological sort is a nonunique permutation of the nodes such that an
edge from u to v implies that u appears before v in the topological sort
order.

Parameters
----------
G : NetworkX DiGraph
    A directed graph

Returns
-------
generator
    All topological sorts of the digraph G

Raises
------
NetworkXNotImplemented
    If `G` is not directed
NetworkXUnfeasible
    If `G` is not acyclic

Examples
--------
To enumerate all topological sorts of directed graph:

&gt;&gt;&gt; DG = nx.DiGraph([(1, 2), (2, 3), (2, 4)])
&gt;&gt;&gt; list(nx.all_topological_sorts(DG))
[[1, 2, 4, 3], [1, 2, 3, 4]]

Notes
-----
Implements an iterative version of the algorithm given in [1].

References
----------
.. [1] Knuth, Donald E., Szwarcfiter, Jayme L. (1974).
   "A Structured Program to Generate All Topological Sorting Arrangements"
   Information Processing Letters, Volume 2, Issue 6, 1974, Pages 153-157,
   ISSN 0020-0190,
   https://doi.org/10.1016/0020-0190(74)90001-5.
   Elsevier (North-Holland), Amsterdam
</pre> 
</div>
</div>
<a id="ab5931c11c1d779c650c90cb1594f738e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5931c11c1d779c650c90cb1594f738e">&#9670;&nbsp;</a></span>ancestors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.ancestors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns all nodes having a path to `source` in `G`.

Parameters
----------
G : NetworkX DiGraph
    A directed graph
source : node in `G`

Returns
-------
set()
    The ancestors of source in G
</pre> 
</div>
</div>
<a id="a269f94d57f2a7ef7559754d4f6d8032d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269f94d57f2a7ef7559754d4f6d8032d">&#9670;&nbsp;</a></span>antichains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.antichains </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>topo_order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates antichains from a directed acyclic graph (DAG).

An antichain is a subset of a partially ordered set such that any
two elements in the subset are incomparable.

Parameters
----------
G : NetworkX DiGraph
    A directed acyclic graph (DAG)

topo_order: list or tuple, optional
    A topological order for G (if None, the function will compute one)

Returns
-------
generator object

Raises
------
NetworkXNotImplemented
    If `G` is not directed

NetworkXUnfeasible
    If `G` contains a cycle

Notes
-----
This function was originally developed by Peter Jipsen and Franco Saliola
for the SAGE project. It's included in NetworkX with permission from the
authors. Original SAGE code at:

https://github.com/sagemath/sage/blob/master/src/sage/combinat/posets/hasse_diagram.py

References
----------
.. [1] Free Lattices, by R. Freese, J. Jezek and J. B. Nation,
   AMS, Vol 42, 1995, p. 226.
</pre> 
</div>
</div>
<a id="abbfb030d483ff43f5f7da173db47ee4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfb030d483ff43f5f7da173db47ee4a">&#9670;&nbsp;</a></span>dag_longest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.dag_longest_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default_weight</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>topo_order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the longest path in a directed acyclic graph (DAG).

If `G` has edges with `weight` attribute the edge data are used as
weight values.

Parameters
----------
G : NetworkX DiGraph
    A directed acyclic graph (DAG)

weight : str, optional
    Edge data key to use for weight

default_weight : int, optional
    The weight of edges that do not have a weight attribute

topo_order: list or tuple, optional
    A topological order for G (if None, the function will compute one)

Returns
-------
list
    Longest path

Raises
------
NetworkXNotImplemented
    If `G` is not directed

See also
--------
dag_longest_path_length</pre> 
</div>
</div>
<a id="aa5cb4d4b25d9d700fe878ddf4044ed72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cb4d4b25d9d700fe878ddf4044ed72">&#9670;&nbsp;</a></span>dag_longest_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.dag_longest_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default_weight</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the longest path length in a DAG

Parameters
----------
G : NetworkX DiGraph
    A directed acyclic graph (DAG)

weight : string, optional
    Edge data key to use for weight

default_weight : int, optional
    The weight of edges that do not have a weight attribute

Returns
-------
int
    Longest path length

Raises
------
NetworkXNotImplemented
    If `G` is not directed

See also
--------
dag_longest_path
</pre> 
</div>
</div>
<a id="ac63ef5d8c287a81f02cc897e51cc662f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63ef5d8c287a81f02cc897e51cc662f">&#9670;&nbsp;</a></span>dag_to_branching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.dag_to_branching </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a branching representing all (overlapping) paths from
root nodes to leaf nodes in the given directed acyclic graph.

As described in :mod:`networkx.algorithms.tree.recognition`, a
*branching* is a directed forest in which each node has at most one
parent. In other words, a branching is a disjoint union of
*arborescences*. For this function, each node of in-degree zero in
`G` becomes a root of one of the arborescences, and there will be
one leaf node for each distinct path from that root to a leaf node
in `G`.

Each node `v` in `G` with *k* parents becomes *k* distinct nodes in
the returned branching, one for each parent, and the sub-DAG rooted
at `v` is duplicated for each copy. The algorithm then recurses on
the children of each copy of `v`.

Parameters
----------
G : NetworkX graph
    A directed acyclic graph.

Returns
-------
DiGraph
    The branching in which there is a bijection between root-to-leaf
    paths in `G` (in which multiple paths may share the same leaf)
    and root-to-leaf paths in the branching (in which there is a
    unique path from a root to a leaf).

    Each node has an attribute 'source' whose value is the original
    node to which this node corresponds. No other graph, node, or
    edge attributes are copied into this new graph.

Raises
------
NetworkXNotImplemented
    If `G` is not directed, or if `G` is a multigraph.

HasACycle
    If `G` is not acyclic.

Examples
--------
To examine which nodes in the returned branching were produced by
which original node in the directed acyclic graph, we can collect
the mapping from source node to new nodes into a dictionary. For
example, consider the directed diamond graph::

    &gt;&gt;&gt; from collections import defaultdict
    &gt;&gt;&gt; from operator import itemgetter
    &gt;&gt;&gt;
    &gt;&gt;&gt; G = nx.DiGraph(nx.utils.pairwise("abd"))
    &gt;&gt;&gt; G.add_edges_from(nx.utils.pairwise("acd"))
    &gt;&gt;&gt; B = nx.dag_to_branching(G)
    &gt;&gt;&gt;
    &gt;&gt;&gt; sources = defaultdict(set)
    &gt;&gt;&gt; for v, source in B.nodes(data="source"):
    ...     sources[source].add(v)
    &gt;&gt;&gt; len(sources["a"])
    1
    &gt;&gt;&gt; len(sources["d"])
    2

To copy node attributes from the original graph to the new graph,
you can use a dictionary like the one constructed in the above
example::

    &gt;&gt;&gt; for source, nodes in sources.items():
    ...     for v in nodes:
    ...         B.nodes[v].update(G.nodes[source])

Notes
-----
This function is not idempotent in the sense that the node labels in
the returned branching may be uniquely generated each time the
function is invoked. In fact, the node labels may not be integers;
in order to relabel the nodes to be more readable, you can use the
:func:`networkx.convert_node_labels_to_integers` function.

The current implementation of this function uses
:func:`networkx.prefix_tree`, so it is subject to the limitations of
that function.</pre> 
</div>
</div>
<a id="ad83d7e1164190f67e4f648e8bb0d1df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83d7e1164190f67e4f648e8bb0d1df8">&#9670;&nbsp;</a></span>descendants()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.descendants </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns all nodes reachable from `source` in `G`.

Parameters
----------
G : NetworkX DiGraph
    A directed graph
source : node in `G`

Returns
-------
set()
    The descendants of `source` in `G`
</pre> 
</div>
</div>
<a id="a92320d5ff79b60e340b1b386a71b5b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92320d5ff79b60e340b1b386a71b5b33">&#9670;&nbsp;</a></span>has_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.has_cycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decides whether the directed graph has a cycle.</pre> 
</div>
</div>
<a id="a4ecc4e0b39707797a07ead610a9ecdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecc4e0b39707797a07ead610a9ecdf7">&#9670;&nbsp;</a></span>is_aperiodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.is_aperiodic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if `G` is aperiodic.

A directed graph is aperiodic if there is no integer k &gt; 1 that
divides the length of every cycle in the graph.

Parameters
----------
G : NetworkX DiGraph
    A directed graph

Returns
-------
bool
    True if the graph is aperiodic False otherwise

Raises
------
NetworkXError
    If `G` is not directed

Notes
-----
This uses the method outlined in [1]_, which runs in $O(m)$ time
given $m$ edges in `G`. Note that a graph is not aperiodic if it is
acyclic as every integer trivial divides length 0 cycles.

References
----------
.. [1] Jarvis, J. P.; Shier, D. R. (1996),
   "Graph-theoretic analysis of finite Markov chains,"
   in Shier, D. R.; Wallenius, K. T., Applied Mathematical Modeling:
   A Multidisciplinary Approach, CRC Press.
</pre> 
</div>
</div>
<a id="a282871f30feeb5981563367cb9800007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282871f30feeb5981563367cb9800007">&#9670;&nbsp;</a></span>is_directed_acyclic_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.is_directed_acyclic_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the graph `G` is a directed acyclic graph (DAG) or
False if not.

Parameters
----------
G : NetworkX graph

Returns
-------
bool
    True if `G` is a DAG, False otherwise
</pre> 
</div>
</div>
<a id="a718a056e7a26627ee5bd12d1db32e0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718a056e7a26627ee5bd12d1db32e0be">&#9670;&nbsp;</a></span>lexicographical_topological_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.lexicographical_topological_sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a generator of nodes in lexicographically topologically sorted
order.

A topological sort is a nonunique permutation of the nodes such that an
edge from u to v implies that u appears before v in the topological sort
order.

Parameters
----------
G : NetworkX digraph
    A directed acyclic graph (DAG)

key : function, optional
    This function maps nodes to keys with which to resolve ambiguities in
    the sort order.  Defaults to the identity function.

Returns
-------
iterable
    An iterable of node names in lexicographical topological sort order.

Raises
------
NetworkXError
    Topological sort is defined for directed graphs only. If the graph `G`
    is undirected, a :exc:`NetworkXError` is raised.

NetworkXUnfeasible
    If `G` is not a directed acyclic graph (DAG) no topological sort exists
    and a :exc:`NetworkXUnfeasible` exception is raised.  This can also be
    raised if `G` is changed while the returned iterator is being processed

RuntimeError
    If `G` is changed while the returned iterator is being processed.

Notes
-----
This algorithm is based on a description and proof in
"Introduction to Algorithms: A Creative Approach" [1]_ .

See also
--------
topological_sort

References
----------
.. [1] Manber, U. (1989).
   *Introduction to Algorithms - A Creative Approach.* Addison-Wesley.
</pre> 
</div>
</div>
<a id="aa6432469cf28a68ed889941626729667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6432469cf28a68ed889941626729667">&#9670;&nbsp;</a></span>root_to_leaf_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.root_to_leaf_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yields root-to-leaf paths in a directed acyclic graph.

`G` must be a directed acyclic graph. If not, the behavior of this
function is undefined. A "root" in this graph is a node of in-degree
zero and a "leaf" a node of out-degree zero.

When invoked, this function iterates over each path from any root to
any leaf. A path is a list of nodes.</pre> 
</div>
</div>
<a id="a90baa3a72db8f7a1da7098d87c7e64b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90baa3a72db8f7a1da7098d87c7e64b4">&#9670;&nbsp;</a></span>topological_generations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.topological_generations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Stratifies a DAG into generations.

A topological generation is node collection in which ancestors of a node in each
generation are guaranteed to be in a previous generation, and any descendants of
a node are guaranteed to be in a following generation. Nodes are guaranteed to
be in the earliest possible generation that they can belong to.

Parameters
----------
G : NetworkX digraph
    A directed acyclic graph (DAG)

Yields
------
sets of nodes
    Yields sets of nodes representing each generation.

Raises
------
NetworkXError
    Generations are defined for directed graphs only. If the graph
    `G` is undirected, a :exc:`NetworkXError` is raised.

NetworkXUnfeasible
    If `G` is not a directed acyclic graph (DAG) no topological generations
    exist and a :exc:`NetworkXUnfeasible` exception is raised.  This can also
    be raised if `G` is changed while the returned iterator is being processed

RuntimeError
    If `G` is changed while the returned iterator is being processed.

Examples
--------
&gt;&gt;&gt; DG = nx.DiGraph([(2, 1), (3, 1)])
&gt;&gt;&gt; [sorted(generation) for generation in nx.topological_generations(DG)]
[[2, 3], [1]]

Notes
-----
The generation in which a node resides can also be determined by taking the
max-path-distance from the node to the farthest leaf node. That value can
be obtained with this function using `enumerate(topological_generations(G))`.

See also
--------
topological_sort
</pre> 
</div>
</div>
<a id="ab21f66ba4608c33f0e992f552694bd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21f66ba4608c33f0e992f552694bd6d">&#9670;&nbsp;</a></span>topological_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.topological_sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a generator of nodes in topologically sorted order.

A topological sort is a nonunique permutation of the nodes of a
directed graph such that an edge from u to v implies that u
appears before v in the topological sort order. This ordering is
valid only if the graph has no directed cycles.

Parameters
----------
G : NetworkX digraph
    A directed acyclic graph (DAG)

Yields
------
nodes
    Yields the nodes in topological sorted order.

Raises
------
NetworkXError
    Topological sort is defined for directed graphs only. If the graph `G`
    is undirected, a :exc:`NetworkXError` is raised.

NetworkXUnfeasible
    If `G` is not a directed acyclic graph (DAG) no topological sort exists
    and a :exc:`NetworkXUnfeasible` exception is raised.  This can also be
    raised if `G` is changed while the returned iterator is being processed

RuntimeError
    If `G` is changed while the returned iterator is being processed.

Examples
--------
To get the reverse order of the topological sort:

&gt;&gt;&gt; DG = nx.DiGraph([(1, 2), (2, 3)])
&gt;&gt;&gt; list(reversed(list(nx.topological_sort(DG))))
[3, 2, 1]

If your DiGraph naturally has the edges representing tasks/inputs
and nodes representing people/processes that initiate tasks, then
topological_sort is not quite what you need. You will have to change
the tasks to nodes with dependence reflected by edges. The result is
a kind of topological sort of the edges. This can be done
with :func:`networkx.line_graph` as follows:

&gt;&gt;&gt; list(nx.topological_sort(nx.line_graph(DG)))
[(1, 2), (2, 3)]

Notes
-----
This algorithm is based on a description and proof in
"Introduction to Algorithms: A Creative Approach" [1]_ .

See also
--------
is_directed_acyclic_graph, lexicographical_topological_sort

References
----------
.. [1] Manber, U. (1989).
   *Introduction to Algorithms - A Creative Approach.* Addison-Wesley.
</pre> 
</div>
</div>
<a id="a004f6e48d82f3d56b5e5c906da0986d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004f6e48d82f3d56b5e5c906da0986d9">&#9670;&nbsp;</a></span>transitive_closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.transitive_closure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reflexive</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns transitive closure of a directed graph

The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that
for all v, w in V there is an edge (v, w) in E+ if and only if there
is a path from v to w in G.

Handling of paths from v to v has some flexibility within this definition.
A reflexive transitive closure creates a self-loop for the path
from v to v of length 0. The usual transitive closure creates a
self-loop only if a cycle exists (a path from v to v with length &gt; 0).
We also allow an option for no self-loops.

Parameters
----------
G : NetworkX DiGraph
    A directed graph
reflexive : Bool or None, optional (default: False)
    Determines when cycles create self-loops in the Transitive Closure.
    If True, trivial cycles (length 0) create self-loops. The result
    is a reflexive tranistive closure of G.
    If False (the default) non-trivial cycles create self-loops.
    If None, self-loops are not created.

Returns
-------
NetworkX DiGraph
    The transitive closure of `G`

Raises
------
NetworkXNotImplemented
    If `G` is not directed

References
----------
.. [1] http://www.ics.uci.edu/~eppstein/PADS/PartialOrder.py

TODO this function applies to all directed graphs and is probably misplaced
     here in dag.py
</pre> 
</div>
</div>
<a id="a461cd43df92c1a7dcb7e5605d750801f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461cd43df92c1a7dcb7e5605d750801f">&#9670;&nbsp;</a></span>transitive_closure_dag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.transitive_closure_dag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>topo_order</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the transitive closure of a directed acyclic graph.

This function is faster than the function `transitive_closure`, but fails
if the graph has a cycle.

The transitive closure of G = (V,E) is a graph G+ = (V,E+) such that
for all v, w in V there is an edge (v, w) in E+ if and only if there
is a non-null path from v to w in G.

Parameters
----------
G : NetworkX DiGraph
    A directed acyclic graph (DAG)

topo_order: list or tuple, optional
    A topological order for G (if None, the function will compute one)

Returns
-------
NetworkX DiGraph
    The transitive closure of `G`

Raises
------
NetworkXNotImplemented
    If `G` is not directed
NetworkXUnfeasible
    If `G` has a cycle

Notes
-----
This algorithm is probably simple enough to be well-known but I didn't find
a mention in the literature.
</pre> 
</div>
</div>
<a id="ad4c177fd8eccf2503a153ddc6f73a8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c177fd8eccf2503a153ddc6f73a8c2">&#9670;&nbsp;</a></span>transitive_reduction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.dag.transitive_reduction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns transitive reduction of a directed graph

The transitive reduction of G = (V,E) is a graph G- = (V,E-) such that
for all v,w in V there is an edge (v,w) in E- if and only if (v,w) is
in E and there is no path from v to w in G with length greater than 1.

Parameters
----------
G : NetworkX DiGraph
    A directed acyclic graph (DAG)

Returns
-------
NetworkX DiGraph
    The transitive reduction of `G`

Raises
------
NetworkXError
    If `G` is not a directed acyclic graph (DAG) transitive reduction is
    not uniquely defined and a :exc:`NetworkXError` exception is raised.

Examples
--------
To perform transitive reduction on a DiGraph:

&gt;&gt;&gt; DG = nx.DiGraph([(1, 2), (2, 3), (1, 3)])
&gt;&gt;&gt; TR = nx.transitive_reduction(DG)
&gt;&gt;&gt; list(TR.edges)
[(1, 2), (2, 3)]

To avoid unnecessary data copies, this implementation does not return a
DiGraph with node/edge data.
To perform transitive reduction on a DiGraph and transfer node/edge data:

&gt;&gt;&gt; DG = nx.DiGraph()
&gt;&gt;&gt; DG.add_edges_from([(1, 2), (2, 3), (1, 3)], color='red')
&gt;&gt;&gt; TR = nx.transitive_reduction(DG)
&gt;&gt;&gt; TR.add_nodes_from(DG.nodes(data=True))
&gt;&gt;&gt; TR.add_edges_from((u, v, DG.edges[u, v]) for u, v in TR.edges)
&gt;&gt;&gt; list(TR.edges(data=True))
[(1, 2, {'color': 'red'}), (2, 3, {'color': 'red'})]

References
----------
https://en.wikipedia.org/wiki/Transitive_reduction</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae9077dab1fc86c2cf208bff64fd4d594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9077dab1fc86c2cf208bff64fd4d594">&#9670;&nbsp;</a></span>chaini</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">networkx.algorithms.dag.chaini</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
