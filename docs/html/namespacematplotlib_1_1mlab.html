<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: matplotlib.mlab Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematplotlib.html">matplotlib</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1mlab.html">mlab</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">matplotlib.mlab Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1mlab_1_1GaussianKDE.html">GaussianKDE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0be4c7ab27102a4d8ceb0a08a32ac0fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a0be4c7ab27102a4d8ceb0a08a32ac0fc">window_hanning</a> (x)</td></tr>
<tr class="separator:a0be4c7ab27102a4d8ceb0a08a32ac0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef28ebe480ae1d60bd6b695441873a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#acef28ebe480ae1d60bd6b695441873a0">window_none</a> (x)</td></tr>
<tr class="separator:acef28ebe480ae1d60bd6b695441873a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6139bfa85c059f2a11858aaab4471a5d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a6139bfa85c059f2a11858aaab4471a5d">detrend</a> (x, key=None, axis=None)</td></tr>
<tr class="separator:a6139bfa85c059f2a11858aaab4471a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33582c8e986a5abbf517793a90af9ec9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a33582c8e986a5abbf517793a90af9ec9">detrend_mean</a> (x, axis=None)</td></tr>
<tr class="separator:a33582c8e986a5abbf517793a90af9ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359979aa8e0e635738648ca88ebd5e1d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a359979aa8e0e635738648ca88ebd5e1d">detrend_none</a> (x, axis=None)</td></tr>
<tr class="separator:a359979aa8e0e635738648ca88ebd5e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8259a7aec39bab4216763acc518aba2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#ad8259a7aec39bab4216763acc518aba2">detrend_linear</a> (y)</td></tr>
<tr class="separator:ad8259a7aec39bab4216763acc518aba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80bb47f94fc42f477178fb4e77272c80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a80bb47f94fc42f477178fb4e77272c80">stride_windows</a> (x, n, noverlap=None, axis=0)</td></tr>
<tr class="separator:a80bb47f94fc42f477178fb4e77272c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e214a07b5569a236ed4a255e7d703d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#ac7e214a07b5569a236ed4a255e7d703d">psd</a> (x, NFFT=None, Fs=None, <a class="el" href="namespacematplotlib_1_1mlab.html#a6139bfa85c059f2a11858aaab4471a5d">detrend</a>=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)</td></tr>
<tr class="separator:ac7e214a07b5569a236ed4a255e7d703d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c09befd987c2d0090be90434de805a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#af5c09befd987c2d0090be90434de805a">csd</a> (x, y, NFFT=None, Fs=None, <a class="el" href="namespacematplotlib_1_1mlab.html#a6139bfa85c059f2a11858aaab4471a5d">detrend</a>=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None)</td></tr>
<tr class="separator:af5c09befd987c2d0090be90434de805a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1512ebd8694c242d0aa5d75518d74723"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a1512ebd8694c242d0aa5d75518d74723">specgram</a> (x, NFFT=None, Fs=None, <a class="el" href="namespacematplotlib_1_1mlab.html#a6139bfa85c059f2a11858aaab4471a5d">detrend</a>=None, window=None, noverlap=None, pad_to=None, sides=None, scale_by_freq=None, mode=None)</td></tr>
<tr class="separator:a1512ebd8694c242d0aa5d75518d74723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95254cce5b7e87a908f947cf3ee3a3c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a95254cce5b7e87a908f947cf3ee3a3c3">cohere</a> (x, y, NFFT=256, Fs=2, <a class="el" href="namespacematplotlib_1_1mlab.html#a6139bfa85c059f2a11858aaab4471a5d">detrend</a>=<a class="el" href="namespacematplotlib_1_1mlab.html#a359979aa8e0e635738648ca88ebd5e1d">detrend_none</a>, window=<a class="el" href="namespacematplotlib_1_1mlab.html#a0be4c7ab27102a4d8ceb0a08a32ac0fc">window_hanning</a>, noverlap=0, pad_to=None, sides='default', scale_by_freq=None)</td></tr>
<tr class="separator:a95254cce5b7e87a908f947cf3ee3a3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af9fe23cd7c677efdfda27673cf1acd7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#af9fe23cd7c677efdfda27673cf1acd7b">complex_spectrum</a> = functools.partial(_single_spectrum_helper, &quot;complex&quot;)</td></tr>
<tr class="separator:af9fe23cd7c677efdfda27673cf1acd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b561b24d549354119a44640169596ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a6b561b24d549354119a44640169596ff">quantity</a></td></tr>
<tr class="separator:a6b561b24d549354119a44640169596ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0900364120ca4896abeb582fafa87750"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a0900364120ca4896abeb582fafa87750">magnitude_spectrum</a> = functools.partial(_single_spectrum_helper, &quot;magnitude&quot;)</td></tr>
<tr class="separator:a0900364120ca4896abeb582fafa87750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c68c82f633551591f79ca822c4cba6f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a4c68c82f633551591f79ca822c4cba6f">angle_spectrum</a> = functools.partial(_single_spectrum_helper, &quot;angle&quot;)</td></tr>
<tr class="separator:a4c68c82f633551591f79ca822c4cba6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff39313e62c876e7310b03cbf275a45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacematplotlib_1_1mlab.html#a3ff39313e62c876e7310b03cbf275a45">phase_spectrum</a> = functools.partial(_single_spectrum_helper, &quot;phase&quot;)</td></tr>
<tr class="separator:a3ff39313e62c876e7310b03cbf275a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Numerical python functions written for compatibility with MATLAB
commands with the same names. Most numerical python functions can be found in
the `numpy` and `scipy` libraries. What remains here is code for performing
spectral computations.

Spectral functions
------------------

`cohere`
    Coherence (normalized cross spectral density)

`csd`
    Cross spectral density using Welch's average periodogram

`detrend`
    Remove the mean or best fit line from an array

`psd`
    Power spectral density using Welch's average periodogram

`specgram`
    Spectrogram (spectrum over segments of time)

`complex_spectrum`
    Return the complex-valued frequency spectrum of a signal

`magnitude_spectrum`
    Return the magnitude of the frequency spectrum of a signal

`angle_spectrum`
    Return the angle (wrapped phase) of the frequency spectrum of a signal

`phase_spectrum`
    Return the phase (unwrapped angle) of the frequency spectrum of a signal

`detrend_mean`
    Remove the mean from a line.

`detrend_linear`
    Remove the best fit line from a line.

`detrend_none`
    Return the original line.

`stride_windows`
    Get all windows in an array in a memory-efficient manner
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a95254cce5b7e87a908f947cf3ee3a3c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95254cce5b7e87a908f947cf3ee3a3c3">&#9670;&nbsp;</a></span>cohere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.cohere </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>NFFT</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Fs</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code><a class="el" href="namespacematplotlib_1_1mlab.html#a359979aa8e0e635738648ca88ebd5e1d">detrend_none</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code><a class="el" href="namespacematplotlib_1_1mlab.html#a0be4c7ab27102a4d8ceb0a08a32ac0fc">window_hanning</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_to</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sides</em> = <code>'default'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale_by_freq</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The coherence between *x* and *y*.  Coherence is the normalized
cross spectral density:

.. math::

    C_{xy} = \frac{|P_{xy}|^2}{P_{xx}P_{yy}}

Parameters
----------
x, y
    Array or sequence containing the data

%(Spectral)s

%(PSD)s

noverlap : int, default: 0 (no overlap)
    The number of points of overlap between segments.

Returns
-------
Cxy : 1-D array
    The coherence vector.
freqs : 1-D array
        The frequencies for the elements in *Cxy*.

See Also
--------
:func:`psd`, :func:`csd` :
    For information about the methods used to compute :math:`P_{xy}`,
    :math:`P_{xx}` and :math:`P_{yy}`.
</pre> 
</div>
</div>
<a id="af5c09befd987c2d0090be90434de805a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c09befd987c2d0090be90434de805a">&#9670;&nbsp;</a></span>csd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.csd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>NFFT</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Fs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_to</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sides</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale_by_freq</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the cross-spectral density.

The cross spectral density :math:`P_{xy}` by Welch's average
periodogram method.  The vectors *x* and *y* are divided into
*NFFT* length segments.  Each segment is detrended by function
*detrend* and windowed by function *window*.  *noverlap* gives
the length of the overlap between segments.  The product of
the direct FFTs of *x* and *y* are averaged over each segment
to compute :math:`P_{xy}`, with a scaling to correct for power
loss due to windowing.

If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero
padded to *NFFT*.

Parameters
----------
x, y : 1-D arrays or sequences
    Arrays or sequences containing the data

%(Spectral)s

%(PSD)s

noverlap : int, default: 0 (no overlap)
    The number of points of overlap between segments.

Returns
-------
Pxy : 1-D array
    The values for the cross spectrum :math:`P_{xy}` before scaling (real
    valued)

freqs : 1-D array
    The frequencies corresponding to the elements in *Pxy*

References
----------
Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John
Wiley &amp; Sons (1986)

See Also
--------
psd : equivalent to setting ``y = x``.
</pre> 
</div>
</div>
<a id="a6139bfa85c059f2a11858aaab4471a5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6139bfa85c059f2a11858aaab4471a5d">&#9670;&nbsp;</a></span>detrend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.detrend </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return x with its trend removed.

Parameters
----------
x : array or sequence
    Array or sequence containing the data.

key : {'default', 'constant', 'mean', 'linear', 'none'} or function
    The detrending algorithm to use. 'default', 'mean', and 'constant' are
    the same as `detrend_mean`. 'linear' is the same as `detrend_linear`.
    'none' is the same as `detrend_none`. The default is 'mean'. See the
    corresponding functions for more details regarding the algorithms. Can
    also be a function that carries out the detrend operation.

axis : int
    The axis along which to do the detrending.

See Also
--------
detrend_mean : Implementation of the 'mean' algorithm.
detrend_linear : Implementation of the 'linear' algorithm.
detrend_none : Implementation of the 'none' algorithm.
</pre> 
</div>
</div>
<a id="ad8259a7aec39bab4216763acc518aba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8259a7aec39bab4216763acc518aba2">&#9670;&nbsp;</a></span>detrend_linear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.detrend_linear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return x minus best fit line; 'linear' detrending.

Parameters
----------
y : 0-D or 1-D array or sequence
    Array or sequence containing the data

axis : int
    The axis along which to take the mean.  See numpy.mean for a
    description of this argument.

See Also
--------
detrend_mean : Another detrend algorithm.
detrend_none : Another detrend algorithm.
detrend : A wrapper around all the detrend algorithms.
</pre> 
</div>
</div>
<a id="a33582c8e986a5abbf517793a90af9ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33582c8e986a5abbf517793a90af9ec9">&#9670;&nbsp;</a></span>detrend_mean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.detrend_mean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return x minus the mean(x).

Parameters
----------
x : array or sequence
    Array or sequence containing the data
    Can have any dimensionality

axis : int
    The axis along which to take the mean.  See numpy.mean for a
    description of this argument.

See Also
--------
detrend_linear : Another detrend algorithm.
detrend_none : Another detrend algorithm.
detrend : A wrapper around all the detrend algorithms.
</pre> 
</div>
</div>
<a id="a359979aa8e0e635738648ca88ebd5e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359979aa8e0e635738648ca88ebd5e1d">&#9670;&nbsp;</a></span>detrend_none()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.detrend_none </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return x: no detrending.

Parameters
----------
x : any object
    An object containing the data

axis : int
    This parameter is ignored.
    It is included for compatibility with detrend_mean

See Also
--------
detrend_mean : Another detrend algorithm.
detrend_linear : Another detrend algorithm.
detrend : A wrapper around all the detrend algorithms.
</pre> 
</div>
</div>
<a id="ac7e214a07b5569a236ed4a255e7d703d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e214a07b5569a236ed4a255e7d703d">&#9670;&nbsp;</a></span>psd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.psd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>NFFT</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Fs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_to</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sides</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale_by_freq</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the power spectral density.

The power spectral density :math:`P_{xx}` by Welch's average
periodogram method.  The vector *x* is divided into *NFFT* length
segments.  Each segment is detrended by function *detrend* and
windowed by function *window*.  *noverlap* gives the length of
the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`
of each segment :math:`i` are averaged to compute :math:`P_{xx}`.

If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*.

Parameters
----------
x : 1-D array or sequence
    Array or sequence containing the data

%(Spectral)s

%(PSD)s

noverlap : int, default: 0 (no overlap)
    The number of points of overlap between segments.

Returns
-------
Pxx : 1-D array
    The values for the power spectrum :math:`P_{xx}` (real valued)

freqs : 1-D array
    The frequencies corresponding to the elements in *Pxx*

References
----------
Bendat &amp; Piersol -- Random Data: Analysis and Measurement Procedures, John
Wiley &amp; Sons (1986)

See Also
--------
specgram
    `specgram` differs in the default overlap; in not returning the mean of
    the segment periodograms; and in returning the times of the segments.

magnitude_spectrum : returns the magnitude spectrum.

csd : returns the spectral density between two signals.
</pre> 
</div>
</div>
<a id="a1512ebd8694c242d0aa5d75518d74723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1512ebd8694c242d0aa5d75518d74723">&#9670;&nbsp;</a></span>specgram()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.specgram </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>NFFT</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Fs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>detrend</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pad_to</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sides</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale_by_freq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute a spectrogram.

Compute and plot a spectrogram of data in x.  Data are split into
NFFT length segments and the spectrum of each section is
computed.  The windowing function window is applied to each
segment, and the amount of overlap of each segment is
specified with noverlap.

Parameters
----------
x : array-like
    1-D array or sequence.

%(Spectral)s

%(PSD)s

noverlap : int, default: 128
    The number of points of overlap between blocks.
mode : str, default: 'psd'
    What sort of spectrum to use:
        'psd'
            Returns the power spectral density.
        'complex'
            Returns the complex-valued frequency spectrum.
        'magnitude'
            Returns the magnitude spectrum.
        'angle'
            Returns the phase spectrum without unwrapping.
        'phase'
            Returns the phase spectrum with unwrapping.

Returns
-------
spectrum : array-like
    2D array, columns are the periodograms of successive segments.

freqs : array-like
    1-D array, frequencies corresponding to the rows in *spectrum*.

t : array-like
    1-D array, the times corresponding to midpoints of segments
    (i.e the columns in *spectrum*).

See Also
--------
psd : differs in the overlap and in the return values.
complex_spectrum : similar, but with complex valued frequencies.
magnitude_spectrum : similar single segment when mode is 'magnitude'.
angle_spectrum : similar to single segment when mode is 'angle'.
phase_spectrum : similar to single segment when mode is 'phase'.

Notes
-----
detrend and scale_by_freq only apply when *mode* is set to 'psd'.</pre> 
</div>
</div>
<a id="a80bb47f94fc42f477178fb4e77272c80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80bb47f94fc42f477178fb4e77272c80">&#9670;&nbsp;</a></span>stride_windows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.stride_windows </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noverlap</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get all windows of x with length n as a single array,
using strides to avoid data duplication.

.. warning::

    It is not safe to write to the output array.  Multiple
    elements may point to the same piece of memory,
    so modifying one value may change others.

Parameters
----------
x : 1D array or sequence
    Array or sequence containing the data.
n : int
    The number of data points in each window.
noverlap : int, default: 0 (no overlap)
    The overlap between adjacent windows.
axis : int
    The axis along which the windows will run.

References
----------
`stackoverflow: Rolling window for 1D arrays in Numpy?
&lt;http://stackoverflow.com/a/6811241&gt;`_
`stackoverflow: Using strides for an efficient moving average filter
&lt;http://stackoverflow.com/a/4947453&gt;`_
</pre> 
</div>
</div>
<a id="a0be4c7ab27102a4d8ceb0a08a32ac0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be4c7ab27102a4d8ceb0a08a32ac0fc">&#9670;&nbsp;</a></span>window_hanning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.window_hanning </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return x times the hanning window of len(x).

See Also
--------
window_none : Another window algorithm.
</pre> 
</div>
</div>
<a id="acef28ebe480ae1d60bd6b695441873a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef28ebe480ae1d60bd6b695441873a0">&#9670;&nbsp;</a></span>window_none()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def matplotlib.mlab.window_none </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">No window function; simply return x.

See Also
--------
window_hanning : Another window algorithm.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4c68c82f633551591f79ca822c4cba6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c68c82f633551591f79ca822c4cba6f">&#9670;&nbsp;</a></span>angle_spectrum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.mlab.angle_spectrum = functools.partial(_single_spectrum_helper, &quot;angle&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af9fe23cd7c677efdfda27673cf1acd7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fe23cd7c677efdfda27673cf1acd7b">&#9670;&nbsp;</a></span>complex_spectrum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.mlab.complex_spectrum = functools.partial(_single_spectrum_helper, &quot;complex&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0900364120ca4896abeb582fafa87750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0900364120ca4896abeb582fafa87750">&#9670;&nbsp;</a></span>magnitude_spectrum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.mlab.magnitude_spectrum = functools.partial(_single_spectrum_helper, &quot;magnitude&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ff39313e62c876e7310b03cbf275a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff39313e62c876e7310b03cbf275a45">&#9670;&nbsp;</a></span>phase_spectrum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.mlab.phase_spectrum = functools.partial(_single_spectrum_helper, &quot;phase&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b561b24d549354119a44640169596ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b561b24d549354119a44640169596ff">&#9670;&nbsp;</a></span>quantity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.mlab.quantity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
