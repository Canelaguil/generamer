<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.link_prediction Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1link__prediction.html">link_prediction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.link_prediction Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2d04b0b73763f8f964ae0d251e536b31"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1link__prediction.html#a2d04b0b73763f8f964ae0d251e536b31">resource_allocation_index</a> (G, ebunch=None)</td></tr>
<tr class="separator:a2d04b0b73763f8f964ae0d251e536b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb6cb724a33fc47e2722a29aa23f65d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1link__prediction.html#aafb6cb724a33fc47e2722a29aa23f65d">jaccard_coefficient</a> (G, ebunch=None)</td></tr>
<tr class="separator:aafb6cb724a33fc47e2722a29aa23f65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e3c05fec4b4c2d20be81fb3e10ae5a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1link__prediction.html#a97e3c05fec4b4c2d20be81fb3e10ae5a">adamic_adar_index</a> (G, ebunch=None)</td></tr>
<tr class="separator:a97e3c05fec4b4c2d20be81fb3e10ae5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45713a94d1120e276cad7a7e636b7212"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1link__prediction.html#a45713a94d1120e276cad7a7e636b7212">common_neighbor_centrality</a> (G, ebunch=None, alpha=0.8)</td></tr>
<tr class="separator:a45713a94d1120e276cad7a7e636b7212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424e20c04c0309c9486da83a51138d05"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1link__prediction.html#a424e20c04c0309c9486da83a51138d05">preferential_attachment</a> (G, ebunch=None)</td></tr>
<tr class="separator:a424e20c04c0309c9486da83a51138d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5018917b79b89c1f4ad087731d7f10"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1link__prediction.html#a9c5018917b79b89c1f4ad087731d7f10">cn_soundarajan_hopcroft</a> (G, ebunch=None, community=&quot;community&quot;)</td></tr>
<tr class="separator:a9c5018917b79b89c1f4ad087731d7f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec305e0e0ad608c561c6e51b358b1fb3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1link__prediction.html#aec305e0e0ad608c561c6e51b358b1fb3">ra_index_soundarajan_hopcroft</a> (G, ebunch=None, community=&quot;community&quot;)</td></tr>
<tr class="separator:aec305e0e0ad608c561c6e51b358b1fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7af17cf19357c55684099957105c67"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1link__prediction.html#a9b7af17cf19357c55684099957105c67">within_inter_cluster</a> (G, ebunch=None, delta=0.001, community=&quot;community&quot;)</td></tr>
<tr class="separator:a9b7af17cf19357c55684099957105c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Link prediction algorithms.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a97e3c05fec4b4c2d20be81fb3e10ae5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e3c05fec4b4c2d20be81fb3e10ae5a">&#9670;&nbsp;</a></span>adamic_adar_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.link_prediction.adamic_adar_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ebunch</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Adamic-Adar index of all node pairs in ebunch.

Adamic-Adar index of `u` and `v` is defined as

.. math::

    \sum_{w \in \Gamma(u) \cap \Gamma(v)} \frac{1}{\log |\Gamma(w)|}

where $\Gamma(u)$ denotes the set of neighbors of $u$.
This index leads to zero-division for nodes only connected via self-loops.
It is intended to be used when no self-loops are present.

Parameters
----------
G : graph
    NetworkX undirected graph.

ebunch : iterable of node pairs, optional (default = None)
    Adamic-Adar index will be computed for each pair of nodes given
    in the iterable. The pairs must be given as 2-tuples (u, v)
    where u and v are nodes in the graph. If ebunch is None then all
    non-existent edges in the graph will be used.
    Default value: None.

Returns
-------
piter : iterator
    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a
    pair of nodes and p is their Adamic-Adar index.

Examples
--------
&gt;&gt;&gt; G = nx.complete_graph(5)
&gt;&gt;&gt; preds = nx.adamic_adar_index(G, [(0, 1), (2, 3)])
&gt;&gt;&gt; for u, v, p in preds:
...     print(f"({u}, {v}) -&gt; {p:.8f}")
(0, 1) -&gt; 2.16404256
(2, 3) -&gt; 2.16404256

References
----------
.. [1] D. Liben-Nowell, J. Kleinberg.
       The Link Prediction Problem for Social Networks (2004).
       http://www.cs.cornell.edu/home/kleinber/link-pred.pdf
</pre> 
</div>
</div>
<a id="a9c5018917b79b89c1f4ad087731d7f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5018917b79b89c1f4ad087731d7f10">&#9670;&nbsp;</a></span>cn_soundarajan_hopcroft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.link_prediction.cn_soundarajan_hopcroft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ebunch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>community</em> = <code>&quot;community&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Count the number of common neighbors of all node pairs in ebunch
    using community information.

For two nodes $u$ and $v$, this function computes the number of
common neighbors and bonus one for each common neighbor belonging to
the same community as $u$ and $v$. Mathematically,

.. math::

    |\Gamma(u) \cap \Gamma(v)| + \sum_{w \in \Gamma(u) \cap \Gamma(v)} f(w)

where $f(w)$ equals 1 if $w$ belongs to the same community as $u$
and $v$ or 0 otherwise and $\Gamma(u)$ denotes the set of
neighbors of $u$.

Parameters
----------
G : graph
    A NetworkX undirected graph.

ebunch : iterable of node pairs, optional (default = None)
    The score will be computed for each pair of nodes given in the
    iterable. The pairs must be given as 2-tuples (u, v) where u
    and v are nodes in the graph. If ebunch is None then all
    non-existent edges in the graph will be used.
    Default value: None.

community : string, optional (default = 'community')
    Nodes attribute name containing the community information.
    G[u][community] identifies which community u belongs to. Each
    node belongs to at most one community. Default value: 'community'.

Returns
-------
piter : iterator
    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a
    pair of nodes and p is their score.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(3)
&gt;&gt;&gt; G.nodes[0]["community"] = 0
&gt;&gt;&gt; G.nodes[1]["community"] = 0
&gt;&gt;&gt; G.nodes[2]["community"] = 0
&gt;&gt;&gt; preds = nx.cn_soundarajan_hopcroft(G, [(0, 2)])
&gt;&gt;&gt; for u, v, p in preds:
...     print(f"({u}, {v}) -&gt; {p}")
(0, 2) -&gt; 2

References
----------
.. [1] Sucheta Soundarajan and John Hopcroft.
   Using community information to improve the precision of link
   prediction methods.
   In Proceedings of the 21st international conference companion on
   World Wide Web (WWW '12 Companion). ACM, New York, NY, USA, 607-608.
   http://doi.acm.org/10.1145/2187980.2188150
</pre> 
</div>
</div>
<a id="a45713a94d1120e276cad7a7e636b7212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45713a94d1120e276cad7a7e636b7212">&#9670;&nbsp;</a></span>common_neighbor_centrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.link_prediction.common_neighbor_centrality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ebunch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the CCPA score for each pair of nodes.

Compute the Common Neighbor and Centrality based Parameterized Algorithm(CCPA)
score of all node pairs in ebunch.

CCPA score of `u` and `v` is defined as

.. math::

    \alpha \cdot (|\Gamma (u){\cap }^{}\Gamma (v)|)+(1-\alpha )\cdot \frac{N}{{d}_{uv}}

where $\Gamma(u)$ denotes the set of neighbors of $u$, $\Gamma(v)$ denotes the
set of neighbors of $v$, $\alpha$ is  parameter varies between [0,1], $N$ denotes
total number of nodes in the Graph and ${d}_{uv}$ denotes shortest distance
between $u$ and $v$.

This algorithm is based on two vital properties of nodes, namely the number
of common neighbors and their centrality. Common neighbor refers to the common
nodes between two nodes. Centrality refers to the prestige that a node enjoys
in a network.

.. seealso::

    :func:`common_neighbors`

Parameters
----------
G : graph
    NetworkX undirected graph.

ebunch : iterable of node pairs, optional (default = None)
    Preferential attachment score will be computed for each pair of
    nodes given in the iterable. The pairs must be given as
    2-tuples (u, v) where u and v are nodes in the graph. If ebunch
    is None then all non-existent edges in the graph will be used.
    Default value: None.

alpha : Parameter defined for participation of Common Neighbor
        and Centrality Algorithm share. Default value set to 0.8
        because author found better performance at 0.8 for all the
        dataset.
        Default value: 0.8


Returns
-------
piter : iterator
    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a
    pair of nodes and p is their Common Neighbor and Centrality based
    Parameterized Algorithm(CCPA) score.

Examples
--------
&gt;&gt;&gt; G = nx.complete_graph(5)
&gt;&gt;&gt; preds = nx.common_neighbor_centrality(G, [(0, 1), (2, 3)])
&gt;&gt;&gt; for u, v, p in preds:
...     print(f"({u}, {v}) -&gt; {p}")
(0, 1) -&gt; 3.4000000000000004
(2, 3) -&gt; 3.4000000000000004

References
----------
.. [1] Ahmad, I., Akhtar, M.U., Noor, S. et al.
       Missing Link Prediction using Common Neighbor and Centrality based Parameterized Algorithm.
       Sci Rep 10, 364 (2020).
       https://doi.org/10.1038/s41598-019-57304-y
</pre> 
</div>
</div>
<a id="aafb6cb724a33fc47e2722a29aa23f65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb6cb724a33fc47e2722a29aa23f65d">&#9670;&nbsp;</a></span>jaccard_coefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.link_prediction.jaccard_coefficient </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ebunch</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Jaccard coefficient of all node pairs in ebunch.

Jaccard coefficient of nodes `u` and `v` is defined as

.. math::

    \frac{|\Gamma(u) \cap \Gamma(v)|}{|\Gamma(u) \cup \Gamma(v)|}

where $\Gamma(u)$ denotes the set of neighbors of $u$.

Parameters
----------
G : graph
    A NetworkX undirected graph.

ebunch : iterable of node pairs, optional (default = None)
    Jaccard coefficient will be computed for each pair of nodes
    given in the iterable. The pairs must be given as 2-tuples
    (u, v) where u and v are nodes in the graph. If ebunch is None
    then all non-existent edges in the graph will be used.
    Default value: None.

Returns
-------
piter : iterator
    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a
    pair of nodes and p is their Jaccard coefficient.

Examples
--------
&gt;&gt;&gt; G = nx.complete_graph(5)
&gt;&gt;&gt; preds = nx.jaccard_coefficient(G, [(0, 1), (2, 3)])
&gt;&gt;&gt; for u, v, p in preds:
...     print(f"({u}, {v}) -&gt; {p:.8f}")
(0, 1) -&gt; 0.60000000
(2, 3) -&gt; 0.60000000

References
----------
.. [1] D. Liben-Nowell, J. Kleinberg.
       The Link Prediction Problem for Social Networks (2004).
       http://www.cs.cornell.edu/home/kleinber/link-pred.pdf
</pre> 
</div>
</div>
<a id="a424e20c04c0309c9486da83a51138d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424e20c04c0309c9486da83a51138d05">&#9670;&nbsp;</a></span>preferential_attachment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.link_prediction.preferential_attachment </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ebunch</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the preferential attachment score of all node pairs in ebunch.

Preferential attachment score of `u` and `v` is defined as

.. math::

    |\Gamma(u)| |\Gamma(v)|

where $\Gamma(u)$ denotes the set of neighbors of $u$.

Parameters
----------
G : graph
    NetworkX undirected graph.

ebunch : iterable of node pairs, optional (default = None)
    Preferential attachment score will be computed for each pair of
    nodes given in the iterable. The pairs must be given as
    2-tuples (u, v) where u and v are nodes in the graph. If ebunch
    is None then all non-existent edges in the graph will be used.
    Default value: None.

Returns
-------
piter : iterator
    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a
    pair of nodes and p is their preferential attachment score.

Examples
--------
&gt;&gt;&gt; G = nx.complete_graph(5)
&gt;&gt;&gt; preds = nx.preferential_attachment(G, [(0, 1), (2, 3)])
&gt;&gt;&gt; for u, v, p in preds:
...     print(f"({u}, {v}) -&gt; {p}")
(0, 1) -&gt; 16
(2, 3) -&gt; 16

References
----------
.. [1] D. Liben-Nowell, J. Kleinberg.
       The Link Prediction Problem for Social Networks (2004).
       http://www.cs.cornell.edu/home/kleinber/link-pred.pdf
</pre> 
</div>
</div>
<a id="aec305e0e0ad608c561c6e51b358b1fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec305e0e0ad608c561c6e51b358b1fb3">&#9670;&nbsp;</a></span>ra_index_soundarajan_hopcroft()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.link_prediction.ra_index_soundarajan_hopcroft </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ebunch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>community</em> = <code>&quot;community&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the resource allocation index of all node pairs in
ebunch using community information.

For two nodes $u$ and $v$, this function computes the resource
allocation index considering only common neighbors belonging to the
same community as $u$ and $v$. Mathematically,

.. math::

    \sum_{w \in \Gamma(u) \cap \Gamma(v)} \frac{f(w)}{|\Gamma(w)|}

where $f(w)$ equals 1 if $w$ belongs to the same community as $u$
and $v$ or 0 otherwise and $\Gamma(u)$ denotes the set of
neighbors of $u$.

Parameters
----------
G : graph
    A NetworkX undirected graph.

ebunch : iterable of node pairs, optional (default = None)
    The score will be computed for each pair of nodes given in the
    iterable. The pairs must be given as 2-tuples (u, v) where u
    and v are nodes in the graph. If ebunch is None then all
    non-existent edges in the graph will be used.
    Default value: None.

community : string, optional (default = 'community')
    Nodes attribute name containing the community information.
    G[u][community] identifies which community u belongs to. Each
    node belongs to at most one community. Default value: 'community'.

Returns
-------
piter : iterator
    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a
    pair of nodes and p is their score.

Examples
--------
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; G.add_edges_from([(0, 1), (0, 2), (1, 3), (2, 3)])
&gt;&gt;&gt; G.nodes[0]["community"] = 0
&gt;&gt;&gt; G.nodes[1]["community"] = 0
&gt;&gt;&gt; G.nodes[2]["community"] = 1
&gt;&gt;&gt; G.nodes[3]["community"] = 0
&gt;&gt;&gt; preds = nx.ra_index_soundarajan_hopcroft(G, [(0, 3)])
&gt;&gt;&gt; for u, v, p in preds:
...     print(f"({u}, {v}) -&gt; {p:.8f}")
(0, 3) -&gt; 0.50000000

References
----------
.. [1] Sucheta Soundarajan and John Hopcroft.
   Using community information to improve the precision of link
   prediction methods.
   In Proceedings of the 21st international conference companion on
   World Wide Web (WWW '12 Companion). ACM, New York, NY, USA, 607-608.
   http://doi.acm.org/10.1145/2187980.2188150
</pre> 
</div>
</div>
<a id="a2d04b0b73763f8f964ae0d251e536b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d04b0b73763f8f964ae0d251e536b31">&#9670;&nbsp;</a></span>resource_allocation_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.link_prediction.resource_allocation_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ebunch</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the resource allocation index of all node pairs in ebunch.

Resource allocation index of `u` and `v` is defined as

.. math::

    \sum_{w \in \Gamma(u) \cap \Gamma(v)} \frac{1}{|\Gamma(w)|}

where $\Gamma(u)$ denotes the set of neighbors of $u$.

Parameters
----------
G : graph
    A NetworkX undirected graph.

ebunch : iterable of node pairs, optional (default = None)
    Resource allocation index will be computed for each pair of
    nodes given in the iterable. The pairs must be given as
    2-tuples (u, v) where u and v are nodes in the graph. If ebunch
    is None then all non-existent edges in the graph will be used.
    Default value: None.

Returns
-------
piter : iterator
    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a
    pair of nodes and p is their resource allocation index.

Examples
--------
&gt;&gt;&gt; G = nx.complete_graph(5)
&gt;&gt;&gt; preds = nx.resource_allocation_index(G, [(0, 1), (2, 3)])
&gt;&gt;&gt; for u, v, p in preds:
...     print(f"({u}, {v}) -&gt; {p:.8f}")
(0, 1) -&gt; 0.75000000
(2, 3) -&gt; 0.75000000

References
----------
.. [1] T. Zhou, L. Lu, Y.-C. Zhang.
   Predicting missing links via local information.
   Eur. Phys. J. B 71 (2009) 623.
   https://arxiv.org/pdf/0901.0553.pdf
</pre> 
</div>
</div>
<a id="a9b7af17cf19357c55684099957105c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7af17cf19357c55684099957105c67">&#9670;&nbsp;</a></span>within_inter_cluster()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.link_prediction.within_inter_cluster </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ebunch</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>delta</em> = <code>0.001</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>community</em> = <code>&quot;community&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the ratio of within- and inter-cluster common neighbors
of all node pairs in ebunch.

For two nodes `u` and `v`, if a common neighbor `w` belongs to the
same community as them, `w` is considered as within-cluster common
neighbor of `u` and `v`. Otherwise, it is considered as
inter-cluster common neighbor of `u` and `v`. The ratio between the
size of the set of within- and inter-cluster common neighbors is
defined as the WIC measure. [1]_

Parameters
----------
G : graph
    A NetworkX undirected graph.

ebunch : iterable of node pairs, optional (default = None)
    The WIC measure will be computed for each pair of nodes given in
    the iterable. The pairs must be given as 2-tuples (u, v) where
    u and v are nodes in the graph. If ebunch is None then all
    non-existent edges in the graph will be used.
    Default value: None.

delta : float, optional (default = 0.001)
    Value to prevent division by zero in case there is no
    inter-cluster common neighbor between two nodes. See [1]_ for
    details. Default value: 0.001.

community : string, optional (default = 'community')
    Nodes attribute name containing the community information.
    G[u][community] identifies which community u belongs to. Each
    node belongs to at most one community. Default value: 'community'.

Returns
-------
piter : iterator
    An iterator of 3-tuples in the form (u, v, p) where (u, v) is a
    pair of nodes and p is their WIC measure.

Examples
--------
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; G.add_edges_from([(0, 1), (0, 2), (0, 3), (1, 4), (2, 4), (3, 4)])
&gt;&gt;&gt; G.nodes[0]["community"] = 0
&gt;&gt;&gt; G.nodes[1]["community"] = 1
&gt;&gt;&gt; G.nodes[2]["community"] = 0
&gt;&gt;&gt; G.nodes[3]["community"] = 0
&gt;&gt;&gt; G.nodes[4]["community"] = 0
&gt;&gt;&gt; preds = nx.within_inter_cluster(G, [(0, 4)])
&gt;&gt;&gt; for u, v, p in preds:
...     print(f"({u}, {v}) -&gt; {p:.8f}")
(0, 4) -&gt; 1.99800200
&gt;&gt;&gt; preds = nx.within_inter_cluster(G, [(0, 4)], delta=0.5)
&gt;&gt;&gt; for u, v, p in preds:
...     print(f"({u}, {v}) -&gt; {p:.8f}")
(0, 4) -&gt; 1.33333333

References
----------
.. [1] Jorge Carlos Valverde-Rebaza and Alneu de Andrade Lopes.
   Link prediction in complex networks based on cluster information.
   In Proceedings of the 21st Brazilian conference on Advances in
   Artificial Intelligence (SBIA'12)
   https://doi.org/10.1007/978-3-642-34459-6_10
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
