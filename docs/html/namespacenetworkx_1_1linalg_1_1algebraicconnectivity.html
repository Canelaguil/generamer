<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.linalg.algebraicconnectivity Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1linalg_1_1algebraicconnectivity.html">algebraicconnectivity</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.linalg.algebraicconnectivity Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1linalg_1_1algebraicconnectivity_1_1__CholeskySolver.html">_CholeskySolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1linalg_1_1algebraicconnectivity_1_1__LUSolver.html">_LUSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1linalg_1_1algebraicconnectivity_1_1__PCGSolver.html">_PCGSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abf07069cd8baafec751f7be25880c595"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1linalg_1_1algebraicconnectivity.html#abf07069cd8baafec751f7be25880c595">algebraic_connectivity</a> (G, weight=&quot;weight&quot;, normalized=False, tol=1e-8, method=&quot;tracemin_pcg&quot;, seed=None)</td></tr>
<tr class="separator:abf07069cd8baafec751f7be25880c595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862b00cdd972ff366199b0e3b8a42a4c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1linalg_1_1algebraicconnectivity.html#a862b00cdd972ff366199b0e3b8a42a4c">fiedler_vector</a> (G, weight=&quot;weight&quot;, normalized=False, tol=1e-8, method=&quot;tracemin_pcg&quot;, seed=None)</td></tr>
<tr class="separator:a862b00cdd972ff366199b0e3b8a42a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ebf49ae3fabf3461120a0a4b8007a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1linalg_1_1algebraicconnectivity.html#a51ebf49ae3fabf3461120a0a4b8007a7">spectral_ordering</a> (G, weight=&quot;weight&quot;, normalized=False, tol=1e-8, method=&quot;tracemin_pcg&quot;, seed=None)</td></tr>
<tr class="separator:a51ebf49ae3fabf3461120a0a4b8007a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Algebraic connectivity and Fiedler vectors of undirected graphs.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="abf07069cd8baafec751f7be25880c595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf07069cd8baafec751f7be25880c595">&#9670;&nbsp;</a></span>algebraic_connectivity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.linalg.algebraicconnectivity.algebraic_connectivity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;tracemin_pcg&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the algebraic connectivity of an undirected graph.

The algebraic connectivity of a connected undirected graph is the second
smallest eigenvalue of its Laplacian matrix.

Parameters
----------
G : NetworkX graph
    An undirected graph.

weight : object, optional (default: None)
    The data key used to determine the weight of each edge. If None, then
    each edge has unit weight.

normalized : bool, optional (default: False)
    Whether the normalized Laplacian matrix is used.

tol : float, optional (default: 1e-8)
    Tolerance of relative residual in eigenvalue computation.

method : string, optional (default: 'tracemin_pcg')
    Method of eigenvalue computation. It must be one of the tracemin
    options shown below (TraceMIN), 'lanczos' (Lanczos iteration)
    or 'lobpcg' (LOBPCG).

    The TraceMIN algorithm uses a linear system solver. The following
    values allow specifying the solver to be used.

    =============== ========================================
    Value           Solver
    =============== ========================================
    'tracemin_pcg'  Preconditioned conjugate gradient method
    'tracemin_lu'   LU factorization
    =============== ========================================

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
algebraic_connectivity : float
    Algebraic connectivity.

Raises
------
NetworkXNotImplemented
    If G is directed.

NetworkXError
    If G has less than two nodes.

Notes
-----
Edge weights are interpreted by their absolute values. For MultiGraph's,
weights of parallel edges are summed. Zero-weighted edges are ignored.

See Also
--------
laplacian_matrix
</pre> 
</div>
</div>
<a id="a862b00cdd972ff366199b0e3b8a42a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862b00cdd972ff366199b0e3b8a42a4c">&#9670;&nbsp;</a></span>fiedler_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.linalg.algebraicconnectivity.fiedler_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;tracemin_pcg&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Fiedler vector of a connected undirected graph.

The Fiedler vector of a connected undirected graph is the eigenvector
corresponding to the second smallest eigenvalue of the Laplacian matrix
of the graph.

Parameters
----------
G : NetworkX graph
    An undirected graph.

weight : object, optional (default: None)
    The data key used to determine the weight of each edge. If None, then
    each edge has unit weight.

normalized : bool, optional (default: False)
    Whether the normalized Laplacian matrix is used.

tol : float, optional (default: 1e-8)
    Tolerance of relative residual in eigenvalue computation.

method : string, optional (default: 'tracemin_pcg')
    Method of eigenvalue computation. It must be one of the tracemin
    options shown below (TraceMIN), 'lanczos' (Lanczos iteration)
    or 'lobpcg' (LOBPCG).

    The TraceMIN algorithm uses a linear system solver. The following
    values allow specifying the solver to be used.

    =============== ========================================
    Value           Solver
    =============== ========================================
    'tracemin_pcg'  Preconditioned conjugate gradient method
    'tracemin_lu'   LU factorization
    =============== ========================================

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
fiedler_vector : NumPy array of floats.
    Fiedler vector.

Raises
------
NetworkXNotImplemented
    If G is directed.

NetworkXError
    If G has less than two nodes or is not connected.

Notes
-----
Edge weights are interpreted by their absolute values. For MultiGraph's,
weights of parallel edges are summed. Zero-weighted edges are ignored.

See Also
--------
laplacian_matrix
</pre> 
</div>
</div>
<a id="a51ebf49ae3fabf3461120a0a4b8007a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ebf49ae3fabf3461120a0a4b8007a7">&#9670;&nbsp;</a></span>spectral_ordering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.linalg.algebraicconnectivity.spectral_ordering </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;tracemin_pcg&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the spectral_ordering of a graph.

The spectral ordering of a graph is an ordering of its nodes where nodes
in the same weakly connected components appear contiguous and ordered by
their corresponding elements in the Fiedler vector of the component.

Parameters
----------
G : NetworkX graph
    A graph.

weight : object, optional (default: None)
    The data key used to determine the weight of each edge. If None, then
    each edge has unit weight.

normalized : bool, optional (default: False)
    Whether the normalized Laplacian matrix is used.

tol : float, optional (default: 1e-8)
    Tolerance of relative residual in eigenvalue computation.

method : string, optional (default: 'tracemin_pcg')
    Method of eigenvalue computation. It must be one of the tracemin
    options shown below (TraceMIN), 'lanczos' (Lanczos iteration)
    or 'lobpcg' (LOBPCG).

    The TraceMIN algorithm uses a linear system solver. The following
    values allow specifying the solver to be used.

    =============== ========================================
    Value           Solver
    =============== ========================================
    'tracemin_pcg'  Preconditioned conjugate gradient method
    'tracemin_lu'   LU factorization
    =============== ========================================

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
spectral_ordering : NumPy array of floats.
    Spectral ordering of nodes.

Raises
------
NetworkXError
    If G is empty.

Notes
-----
Edge weights are interpreted by their absolute values. For MultiGraph's,
weights of parallel edges are summed. Zero-weighted edges are ignored.

See Also
--------
laplacian_matrix
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
