<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.generators.trees Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1generators.html">generators</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1generators_1_1trees.html">trees</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.generators.trees Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3b35b24b5057cc067d2b4d0127f586a9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1trees.html#a3b35b24b5057cc067d2b4d0127f586a9">prefix_tree</a> (paths)</td></tr>
<tr class="separator:a3b35b24b5057cc067d2b4d0127f586a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c31c09253b1e1f5052437d5a7e267"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1trees.html#a8e7c31c09253b1e1f5052437d5a7e267">prefix_tree_recursive</a> (paths)</td></tr>
<tr class="separator:a8e7c31c09253b1e1f5052437d5a7e267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8423414dc7c03c951d99e44d69566d93"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1trees.html#a8423414dc7c03c951d99e44d69566d93">random_tree</a> (n, seed=None, create_using=None)</td></tr>
<tr class="separator:a8423414dc7c03c951d99e44d69566d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions for generating trees.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a3b35b24b5057cc067d2b4d0127f586a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b35b24b5057cc067d2b4d0127f586a9">&#9670;&nbsp;</a></span>prefix_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.trees.prefix_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a directed prefix tree from a list of paths.

Usually the paths are described as strings or lists of integers.

A "prefix tree" represents the prefix structure of the strings.
Each node represents a prefix of some string. The root represents
the empty prefix with children for the single letter prefixes which
in turn have children for each double letter prefix starting with
the single letter corresponding to the parent node, and so on.

More generally the prefixes do not need to be strings. A prefix refers
to the start of a sequence. The root has children for each one element
prefix and they have children for each two element prefix that starts
with the one element sequence of the parent, and so on.

Note that this implementation uses integer nodes with an attribute.
Each node has an attribute "source" whose value is the original element
of the path to which this node corresponds. For example, suppose `paths`
consists of one path: "can". Then the nodes `[1, 2, 3]` which represent
this path have "source" values "c", "a" and "n".

All the descendants of a node have a common prefix in the sequence/path
associated with that node. From the returned tree, the prefix for each
node can be constructed by traversing the tree up to the root and
accumulating the "source" values along the way.

The root node is always `0` and has "source" attribute `None`.
The root is the only node with in-degree zero.
The nil node is always `-1` and has "source" attribute `"NIL"`.
The nil node is the only node with out-degree zero.


Parameters
----------
paths: iterable of paths
    An iterable of paths which are themselves sequences.
    Matching prefixes among these sequences are identified with
    nodes of the prefix tree. One leaf of the tree is associated
    with each path. (Identical paths are associated with the same
    leaf of the tree.)


Returns
-------
tree: DiGraph
    A directed graph representing an arborescence consisting of the
    prefix tree generated by `paths`. Nodes are directed "downward",
    from parent to child. A special "synthetic" root node is added
    to be the parent of the first node in each path. A special
    "synthetic" leaf node, the "nil" node `-1`, is added to be the child
    of all nodes representing the last element in a path. (The
    addition of this nil node technically makes this not an
    arborescence but a directed acyclic graph; removing the nil node
    makes it an arborescence.)


Notes
-----
The prefix tree is also known as a *trie*.


Examples
--------
Create a prefix tree from a list of strings with common prefixes::

    &gt;&gt;&gt; paths = ["ab", "abs", "ad"]
    &gt;&gt;&gt; T = nx.prefix_tree(paths)
    &gt;&gt;&gt; list(T.edges)
    [(0, 1), (1, 2), (1, 4), (2, -1), (2, 3), (3, -1), (4, -1)]

The leaf nodes can be obtained as predecessors of the nil node::

    &gt;&gt;&gt; root, NIL = 0, -1
    &gt;&gt;&gt; list(T.predecessors(NIL))
    [2, 3, 4]

To recover the original paths that generated the prefix tree,
traverse up the tree from the node `-1` to the node `0`::

    &gt;&gt;&gt; recovered = []
    &gt;&gt;&gt; for v in T.predecessors(NIL):
    ...     prefix = ""
    ...     while v != root:
    ...         prefix = str(T.nodes[v]["source"]) + prefix
    ...         v = next(T.predecessors(v))  # only one predecessor
    ...     recovered.append(prefix)
    &gt;&gt;&gt; sorted(recovered)
    ['ab', 'abs', 'ad']
</pre> 
</div>
</div>
<a id="a8e7c31c09253b1e1f5052437d5a7e267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7c31c09253b1e1f5052437d5a7e267">&#9670;&nbsp;</a></span>prefix_tree_recursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.trees.prefix_tree_recursive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Recursively creates a directed prefix tree from a list of paths.

The original recursive version of prefix_tree for comparison. It is
the same algorithm but the recursion is unrolled onto a stack.

Usually the paths are described as strings or lists of integers.

A "prefix tree" represents the prefix structure of the strings.
Each node represents a prefix of some string. The root represents
the empty prefix with children for the single letter prefixes which
in turn have children for each double letter prefix starting with
the single letter corresponding to the parent node, and so on.

More generally the prefixes do not need to be strings. A prefix refers
to the start of a sequence. The root has children for each one element
prefix and they have children for each two element prefix that starts
with the one element sequence of the parent, and so on.

Note that this implementation uses integer nodes with an attribute.
Each node has an attribute "source" whose value is the original element
of the path to which this node corresponds. For example, suppose `paths`
consists of one path: "can". Then the nodes `[1, 2, 3]` which represent
this path have "source" values "c", "a" and "n".

All the descendants of a node have a common prefix in the sequence/path
associated with that node. From the returned tree, ehe prefix for each
node can be constructed by traversing the tree up to the root and
accumulating the "source" values along the way.

The root node is always `0` and has "source" attribute `None`.
The root is the only node with in-degree zero.
The nil node is always `-1` and has "source" attribute `"NIL"`.
The nil node is the only node with out-degree zero.


Parameters
----------
paths: iterable of paths
    An iterable of paths which are themselves sequences.
    Matching prefixes among these sequences are identified with
    nodes of the prefix tree. One leaf of the tree is associated
    with each path. (Identical paths are associated with the same
    leaf of the tree.)


Returns
-------
tree: DiGraph
    A directed graph representing an arborescence consisting of the
    prefix tree generated by `paths`. Nodes are directed "downward",
    from parent to child. A special "synthetic" root node is added
    to be the parent of the first node in each path. A special
    "synthetic" leaf node, the "nil" node `-1`, is added to be the child
    of all nodes representing the last element in a path. (The
    addition of this nil node technically makes this not an
    arborescence but a directed acyclic graph; removing the nil node
    makes it an arborescence.)


Notes
-----
The prefix tree is also known as a *trie*.


Examples
--------
Create a prefix tree from a list of strings with common prefixes::

    &gt;&gt;&gt; paths = ["ab", "abs", "ad"]
    &gt;&gt;&gt; T = nx.prefix_tree(paths)
    &gt;&gt;&gt; list(T.edges)
    [(0, 1), (1, 2), (1, 4), (2, -1), (2, 3), (3, -1), (4, -1)]

The leaf nodes can be obtained as predecessors of the nil node.

    &gt;&gt;&gt; root, NIL = 0, -1
    &gt;&gt;&gt; list(T.predecessors(NIL))
    [2, 3, 4]

To recover the original paths that generated the prefix tree,
traverse up the tree from the node `-1` to the node `0`::

    &gt;&gt;&gt; recovered = []
    &gt;&gt;&gt; for v in T.predecessors(NIL):
    ...     prefix = ""
    ...     while v != root:
    ...         prefix = str(T.nodes[v]["source"]) + prefix
    ...         v = next(T.predecessors(v))  # only one predecessor
    ...     recovered.append(prefix)
    &gt;&gt;&gt; sorted(recovered)
    ['ab', 'abs', 'ad']
</pre> 
</div>
</div>
<a id="a8423414dc7c03c951d99e44d69566d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8423414dc7c03c951d99e44d69566d93">&#9670;&nbsp;</a></span>random_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.trees.random_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a uniformly random tree on `n` nodes.

Parameters
----------
n : int
    A positive integer representing the number of nodes in the tree.
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.
create_using : NetworkX graph constructor, optional (default=nx.Graph)
    Graph type to create. If graph instance, then cleared before populated.

Returns
-------
NetworkX graph
    A tree, given as an undirected graph, whose nodes are numbers in
    the set {0, …, *n* - 1}.

Raises
------
NetworkXPointlessConcept
    If `n` is zero (because the null graph is not a tree).

Notes
-----
The current implementation of this function generates a uniformly
random Prüfer sequence then converts that to a tree via the
:func:`~networkx.from_prufer_sequence` function. Since there is a
bijection between Prüfer sequences of length *n* - 2 and trees on
*n* nodes, the tree is chosen uniformly at random from the set of
all trees on *n* nodes.

Examples
--------
&gt;&gt;&gt; tree = nx.random_tree(n=10, seed=0)
&gt;&gt;&gt; print(nx.forest_str(tree, sources=[0]))
╙── 0
    ├── 3
    └── 4
        ├── 6
        │   ├── 1
        │   ├── 2
        │   └── 7
        │       └── 8
        │           └── 5
        └── 9

&gt;&gt;&gt; tree = nx.random_tree(n=10, seed=0, create_using=nx.DiGraph)
&gt;&gt;&gt; print(nx.forest_str(tree))
╙── 0
    ├─╼ 3
    └─╼ 4
        ├─╼ 6
        │   ├─╼ 1
        │   ├─╼ 2
        │   └─╼ 7
        │       └─╼ 8
        │           └─╼ 5
        └─╼ 9
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
