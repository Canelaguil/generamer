<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.planarity.PlanarEmbedding Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1planarity.html">planarity</a></li><li class="navelem"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html">PlanarEmbedding</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.planarity.PlanarEmbedding Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for networkx.algorithms.planarity.PlanarEmbedding:</div>
<div class="dyncontent">
<div class="center"><img src="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding__inherit__graph.png" border="0" usemap="#networkx_8algorithms_8planarity_8PlanarEmbedding_inherit__map" alt="Inheritance graph"/></div>
<map name="networkx_8algorithms_8planarity_8PlanarEmbedding_inherit__map" id="networkx_8algorithms_8planarity_8PlanarEmbedding_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for networkx.algorithms.planarity.PlanarEmbedding:</div>
<div class="dyncontent">
<div class="center"><img src="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding__coll__graph.png" border="0" usemap="#networkx_8algorithms_8planarity_8PlanarEmbedding_coll__map" alt="Collaboration graph"/></div>
<map name="networkx_8algorithms_8planarity_8PlanarEmbedding_coll__map" id="networkx_8algorithms_8planarity_8PlanarEmbedding_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a23df90920ee302d2f8a5a0b93e352fa2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a23df90920ee302d2f8a5a0b93e352fa2">get_data</a> (self)</td></tr>
<tr class="separator:a23df90920ee302d2f8a5a0b93e352fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42aa6cf4751eb81f7439c1f04b36e74"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#af42aa6cf4751eb81f7439c1f04b36e74">set_data</a> (self, data)</td></tr>
<tr class="separator:af42aa6cf4751eb81f7439c1f04b36e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bee82f35b6940d51353ef5d6a92690"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a22bee82f35b6940d51353ef5d6a92690">neighbors_cw_order</a> (self, v)</td></tr>
<tr class="separator:a22bee82f35b6940d51353ef5d6a92690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c1cfdd3a6c1ea0720a12bdae0681a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a05c1cfdd3a6c1ea0720a12bdae0681a7">check_structure</a> (self)</td></tr>
<tr class="separator:a05c1cfdd3a6c1ea0720a12bdae0681a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83162c25d4361f39d128074422677ef0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a83162c25d4361f39d128074422677ef0">add_half_edge_ccw</a> (self, start_node, end_node, reference_neighbor)</td></tr>
<tr class="separator:a83162c25d4361f39d128074422677ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7076b5d10c8076b752010b799d49acc6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a7076b5d10c8076b752010b799d49acc6">add_half_edge_cw</a> (self, start_node, end_node, reference_neighbor)</td></tr>
<tr class="separator:a7076b5d10c8076b752010b799d49acc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f661cc1da51d624ea821680adc7229"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a49f661cc1da51d624ea821680adc7229">connect_components</a> (self, v, w)</td></tr>
<tr class="separator:a49f661cc1da51d624ea821680adc7229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05923dc85b14af72865ae50d366fc95d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a05923dc85b14af72865ae50d366fc95d">add_half_edge_first</a> (self, start_node, end_node)</td></tr>
<tr class="separator:a05923dc85b14af72865ae50d366fc95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bca15383a6ad062a1b614046fcfe314"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a9bca15383a6ad062a1b614046fcfe314">next_face_half_edge</a> (self, v, w)</td></tr>
<tr class="separator:a9bca15383a6ad062a1b614046fcfe314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86753a214cd378f66e4c6c3badba79c0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a86753a214cd378f66e4c6c3badba79c0">traverse_face</a> (self, v, w, mark_half_edges=None)</td></tr>
<tr class="separator:a86753a214cd378f66e4c6c3badba79c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33736436ddce67cafd7effe227676773"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1planarity_1_1PlanarEmbedding.html#a33736436ddce67cafd7effe227676773">is_directed</a> (self)</td></tr>
<tr class="separator:a33736436ddce67cafd7effe227676773"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Represents a planar graph with its planar embedding.

The planar embedding is given by a `combinatorial embedding
&lt;https://en.wikipedia.org/wiki/Graph_embedding#Combinatorial_embedding&gt;`_.

**Neighbor ordering:**

In comparison to a usual graph structure, the embedding also stores the
order of all neighbors for every vertex.
The order of the neighbors can be given in clockwise (cw) direction or
counterclockwise (ccw) direction. This order is stored as edge attributes
in the underlying directed graph. For the edge (u, v) the edge attribute
'cw' is set to the neighbor of u that follows immediately after v in
clockwise direction.

In order for a PlanarEmbedding to be valid it must fulfill multiple
conditions. It is possible to check if these conditions are fulfilled with
the method :meth:`check_structure`.
The conditions are:

* Edges must go in both directions (because the edge attributes differ)
* Every edge must have a 'cw' and 'ccw' attribute which corresponds to a
  correct planar embedding.
* A node with non zero degree must have a node attribute 'first_nbr'.

As long as a PlanarEmbedding is invalid only the following methods should
be called:

* :meth:`add_half_edge_ccw`
* :meth:`add_half_edge_cw`
* :meth:`connect_components`
* :meth:`add_half_edge_first`

Even though the graph is a subclass of nx.DiGraph, it can still be used
for algorithms that require undirected graphs, because the method
:meth:`is_directed` is overridden. This is possible, because a valid
PlanarGraph must have edges in both directions.

**Half edges:**

In methods like `add_half_edge_ccw` the term "half-edge" is used, which is
a term that is used in `doubly connected edge lists
&lt;https://en.wikipedia.org/wiki/Doubly_connected_edge_list&gt;`_. It is used
to emphasize that the edge is only in one direction and there exists
another half-edge in the opposite direction.
While conventional edges always have two faces (including outer face) next
to them, it is possible to assign each half-edge *exactly one* face.
For a half-edge (u, v) that is orientated such that u is below v then the
face that belongs to (u, v) is to the right of this half-edge.

Examples
--------

Create an embedding of a star graph (compare `nx.star_graph(3)`):

&gt;&gt;&gt; G = nx.PlanarEmbedding()
&gt;&gt;&gt; G.add_half_edge_cw(0, 1, None)
&gt;&gt;&gt; G.add_half_edge_cw(0, 2, 1)
&gt;&gt;&gt; G.add_half_edge_cw(0, 3, 2)
&gt;&gt;&gt; G.add_half_edge_cw(1, 0, None)
&gt;&gt;&gt; G.add_half_edge_cw(2, 0, None)
&gt;&gt;&gt; G.add_half_edge_cw(3, 0, None)

Alternatively the same embedding can also be defined in counterclockwise
orientation. The following results in exactly the same PlanarEmbedding:

&gt;&gt;&gt; G = nx.PlanarEmbedding()
&gt;&gt;&gt; G.add_half_edge_ccw(0, 1, None)
&gt;&gt;&gt; G.add_half_edge_ccw(0, 3, 1)
&gt;&gt;&gt; G.add_half_edge_ccw(0, 2, 3)
&gt;&gt;&gt; G.add_half_edge_ccw(1, 0, None)
&gt;&gt;&gt; G.add_half_edge_ccw(2, 0, None)
&gt;&gt;&gt; G.add_half_edge_ccw(3, 0, None)

After creating a graph, it is possible to validate that the PlanarEmbedding
object is correct:

&gt;&gt;&gt; G.check_structure()</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a83162c25d4361f39d128074422677ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83162c25d4361f39d128074422677ef0">&#9670;&nbsp;</a></span>add_half_edge_ccw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.add_half_edge_ccw </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reference_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adds a half-edge from start_node to end_node.

The half-edge is added counter clockwise next to the existing half-edge
(start_node, reference_neighbor).

Parameters
----------
start_node : node
    Start node of inserted edge.
end_node : node
    End node of inserted edge.
reference_neighbor: node
    End node of reference edge.

Raises
------
NetworkXException
    If the reference_neighbor does not exist.

See Also
--------
add_half_edge_cw
connect_components
add_half_edge_first</pre> 
</div>
</div>
<a id="a7076b5d10c8076b752010b799d49acc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7076b5d10c8076b752010b799d49acc6">&#9670;&nbsp;</a></span>add_half_edge_cw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.add_half_edge_cw </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reference_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adds a half-edge from start_node to end_node.

The half-edge is added clockwise next to the existing half-edge
(start_node, reference_neighbor).

Parameters
----------
start_node : node
    Start node of inserted edge.
end_node : node
    End node of inserted edge.
reference_neighbor: node
    End node of reference edge.

Raises
------
NetworkXException
    If the reference_neighbor does not exist.

See Also
--------
add_half_edge_ccw
connect_components
add_half_edge_first
</pre> 
</div>
</div>
<a id="a05923dc85b14af72865ae50d366fc95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05923dc85b14af72865ae50d366fc95d">&#9670;&nbsp;</a></span>add_half_edge_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.add_half_edge_first </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The added half-edge is inserted at the first position in the order.

Parameters
----------
start_node : node
end_node : node

See Also
--------
add_half_edge_ccw
add_half_edge_cw
connect_components
</pre> 
</div>
</div>
<a id="a05c1cfdd3a6c1ea0720a12bdae0681a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c1cfdd3a6c1ea0720a12bdae0681a7">&#9670;&nbsp;</a></span>check_structure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.check_structure </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Runs without exceptions if this object is valid.

Checks that the following properties are fulfilled:

* Edges go in both directions (because the edge attributes differ).
* Every edge has a 'cw' and 'ccw' attribute which corresponds to a
  correct planar embedding.
* A node with a degree larger than 0 has a node attribute 'first_nbr'.

Running this method verifies that the underlying Graph must be planar.

Raises
------
NetworkXException
    This exception is raised with a short explanation if the
    PlanarEmbedding is invalid.
</pre> 
</div>
</div>
<a id="a49f661cc1da51d624ea821680adc7229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f661cc1da51d624ea821680adc7229">&#9670;&nbsp;</a></span>connect_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.connect_components </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Adds half-edges for (v, w) and (w, v) at some position.

This method should only be called if v and w are in different
components, or it might break the embedding.
This especially means that if `connect_components(v, w)`
is called it is not allowed to call `connect_components(w, v)`
afterwards. The neighbor orientations in both directions are
all set correctly after the first call.

Parameters
----------
v : node
w : node

See Also
--------
add_half_edge_ccw
add_half_edge_cw
add_half_edge_first
</pre> 
</div>
</div>
<a id="a23df90920ee302d2f8a5a0b93e352fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23df90920ee302d2f8a5a0b93e352fa2">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.get_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts the adjacency structure into a better readable structure.

Returns
-------
embedding : dict
    A dict mapping all nodes to a list of neighbors sorted in
    clockwise order.

See Also
--------
set_data</pre> 
</div>
</div>
<a id="a33736436ddce67cafd7effe227676773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33736436ddce67cafd7effe227676773">&#9670;&nbsp;</a></span>is_directed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.is_directed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">A valid PlanarEmbedding is undirected.

All reverse edges are contained, i.e. for every existing
half-edge (v, w) the half-edge in the opposite direction (w, v) is also
contained.
</pre> 
</div>
</div>
<a id="a22bee82f35b6940d51353ef5d6a92690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bee82f35b6940d51353ef5d6a92690">&#9670;&nbsp;</a></span>neighbors_cw_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.neighbors_cw_order </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generator for the neighbors of v in clockwise order.

Parameters
----------
v : node

Yields
------
node</pre> 
</div>
</div>
<a id="a9bca15383a6ad062a1b614046fcfe314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bca15383a6ad062a1b614046fcfe314">&#9670;&nbsp;</a></span>next_face_half_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.next_face_half_edge </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the following half-edge left of a face.

Parameters
----------
v : node
w : node

Returns
-------
half-edge : tuple
</pre> 
</div>
</div>
<a id="af42aa6cf4751eb81f7439c1f04b36e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42aa6cf4751eb81f7439c1f04b36e74">&#9670;&nbsp;</a></span>set_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.set_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Inserts edges according to given sorted neighbor list.

The input format is the same as the output format of get_data().

Parameters
----------
data : dict
    A dict mapping all nodes to a list of neighbors sorted in
    clockwise order.

See Also
--------
get_data</pre> 
</div>
</div>
<a id="a86753a214cd378f66e4c6c3badba79c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86753a214cd378f66e4c6c3badba79c0">&#9670;&nbsp;</a></span>traverse_face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.planarity.PlanarEmbedding.traverse_face </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mark_half_edges</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns nodes on the face that belong to the half-edge (v, w).

The face that is traversed lies to the right of the half-edge (in an
orientation where v is below w).

Optionally it is possible to pass a set to which all encountered half
edges are added. Before calling this method, this set must not include
any half-edges that belong to the face.

Parameters
----------
v : node
    Start node of half-edge.
w : node
    End node of half-edge.
mark_half_edges: set, optional
    Set to which all encountered half-edges are added.

Returns
-------
face : list
    A list of nodes that lie on this face.
</pre> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>venv/lib/python3.9/site-packages/networkx/algorithms/<a class="el" href="planarity_8py.html">planarity.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
