<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.structuralholes Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1structuralholes.html">structuralholes</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.structuralholes Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae88277a5a4f27775a56cf077c759d165"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1structuralholes.html#ae88277a5a4f27775a56cf077c759d165">mutual_weight</a> (G, u, v, weight=None)</td></tr>
<tr class="separator:ae88277a5a4f27775a56cf077c759d165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6692e85a58c9fb16f1be45606fa2b3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1structuralholes.html#aad6692e85a58c9fb16f1be45606fa2b3">normalized_mutual_weight</a> (G, u, v, norm=<a class="el" href="assumed__shape_2foo__free_8f90.html#a1c860bb40bf43c289bc16f8634733f9a">sum</a>, weight=None)</td></tr>
<tr class="separator:aad6692e85a58c9fb16f1be45606fa2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249a78cb37c5b943131a3e30d8226e62"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1structuralholes.html#a249a78cb37c5b943131a3e30d8226e62">effective_size</a> (G, nodes=None, weight=None)</td></tr>
<tr class="separator:a249a78cb37c5b943131a3e30d8226e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0530b51ac4c185cc1b48cc5f16739f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1structuralholes.html#abd0530b51ac4c185cc1b48cc5f16739f">constraint</a> (G, nodes=None, weight=None)</td></tr>
<tr class="separator:abd0530b51ac4c185cc1b48cc5f16739f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8b873761a6f5741a63aec67fa7b346"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1structuralholes.html#a0f8b873761a6f5741a63aec67fa7b346">local_constraint</a> (G, u, v, weight=None)</td></tr>
<tr class="separator:a0f8b873761a6f5741a63aec67fa7b346"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions for computing measures of structural holes.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="abd0530b51ac4c185cc1b48cc5f16739f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0530b51ac4c185cc1b48cc5f16739f">&#9670;&nbsp;</a></span>constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.structuralholes.constraint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the constraint on all nodes in the graph ``G``.

The *constraint* is a measure of the extent to which a node *v* is
invested in those nodes that are themselves invested in the
neighbors of *v*. Formally, the *constraint on v*, denoted `c(v)`,
is defined by

.. math::

   c(v) = \sum_{w \in N(v) \setminus \{v\}} \ell(v, w)

where `N(v)` is the subset of the neighbors of `v` that are either
predecessors or successors of `v` and `\ell(v, w)` is the local
constraint on `v` with respect to `w` [1]_. For the definition of local
constraint, see :func:`local_constraint`.

Parameters
----------
G : NetworkX graph
    The graph containing ``v``. This can be either directed or undirected.

nodes : container, optional
    Container of nodes in the graph ``G`` to compute the constraint. If
    None, the constraint of every node is computed.

weight : None or string, optional
  If None, all edge weights are considered equal.
  Otherwise holds the name of the edge attribute used as weight.

Returns
-------
dict
    Dictionary with nodes as keys and the constraint on the node as values.

See also
--------
local_constraint

References
----------
.. [1] Burt, Ronald S.
       "Structural holes and good ideas".
       American Journal of Sociology (110): 349–399.</pre> 
</div>
</div>
<a id="a249a78cb37c5b943131a3e30d8226e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249a78cb37c5b943131a3e30d8226e62">&#9670;&nbsp;</a></span>effective_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.structuralholes.effective_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the effective size of all nodes in the graph ``G``.

The *effective size* of a node's ego network is based on the concept
of redundancy. A person's ego network has redundancy to the extent
that her contacts are connected to each other as well. The
nonredundant part of a person's relationships it's the effective
size of her ego network [1]_.  Formally, the effective size of a
node $u$, denoted $e(u)$, is defined by

.. math::

   e(u) = \sum_{v \in N(u) \setminus \{u\}}
   \left(1 - \sum_{w \in N(v)} p_{uw} m_{vw}\right)

where $N(u)$ is the set of neighbors of $u$ and $p_{uw}$ is the
normalized mutual weight of the (directed or undirected) edges
joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. And $m_{vw}$
is the mutual weight of $v$ and $w$ divided by $v$ highest mutual
weight with any of its neighbors. The *mutual weight* of $u$ and $v$
is the sum of the weights of edges joining them (edge weights are
assumed to be one if the graph is unweighted).

For the case of unweighted and undirected graphs, Borgatti proposed
a simplified formula to compute effective size [2]_

.. math::

   e(u) = n - \frac{2t}{n}

where `t` is the number of ties in the ego network (not including
ties to ego) and `n` is the number of nodes (excluding ego).

Parameters
----------
G : NetworkX graph
    The graph containing ``v``. Directed graphs are treated like
    undirected graphs when computing neighbors of ``v``.

nodes : container, optional
    Container of nodes in the graph ``G`` to compute the effective size.
    If None, the effective size of every node is computed.

weight : None or string, optional
  If None, all edge weights are considered equal.
  Otherwise holds the name of the edge attribute used as weight.

Returns
-------
dict
    Dictionary with nodes as keys and the effective size of the node as values.

Notes
-----
Burt also defined the related concept of *efficiency* of a node's ego
network, which is its effective size divided by the degree of that
node [1]_. So you can easily compute efficiency:

&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_edges_from([(0, 1), (0, 2), (1, 0), (2, 1)])
&gt;&gt;&gt; esize = nx.effective_size(G)
&gt;&gt;&gt; efficiency = {n: v / G.degree(n) for n, v in esize.items()}

See also
--------
constraint

References
----------
.. [1] Burt, Ronald S.
       *Structural Holes: The Social Structure of Competition.*
       Cambridge: Harvard University Press, 1995.

.. [2] Borgatti, S.
       "Structural Holes: Unpacking Burt's Redundancy Measures"
       CONNECTIONS 20(1):35-38.
       http://www.analytictech.com/connections/v20(1)/holes.htm</pre> 
</div>
</div>
<a id="a0f8b873761a6f5741a63aec67fa7b346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8b873761a6f5741a63aec67fa7b346">&#9670;&nbsp;</a></span>local_constraint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.structuralholes.local_constraint </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the local constraint on the node ``u`` with respect to
the node ``v`` in the graph ``G``.

Formally, the *local constraint on u with respect to v*, denoted
$\ell(v)$, is defined by

.. math::

   \ell(u, v) = \left(p_{uv} + \sum_{w \in N(v)} p_{uw} p{wv}\right)^2,

where $N(v)$ is the set of neighbors of $v$ and $p_{uv}$ is the
normalized mutual weight of the (directed or undirected) edges
joining $u$ and $v$, for each vertex $u$ and $v$ [1]_. The *mutual
weight* of $u$ and $v$ is the sum of the weights of edges joining
them (edge weights are assumed to be one if the graph is
unweighted).

Parameters
----------
G : NetworkX graph
    The graph containing ``u`` and ``v``. This can be either
    directed or undirected.

u : node
    A node in the graph ``G``.

v : node
    A node in the graph ``G``.

weight : None or string, optional
  If None, all edge weights are considered equal.
  Otherwise holds the name of the edge attribute used as weight.

Returns
-------
float
    The constraint of the node ``v`` in the graph ``G``.

See also
--------
constraint

References
----------
.. [1] Burt, Ronald S.
       "Structural holes and good ideas".
       American Journal of Sociology (110): 349–399.</pre> 
</div>
</div>
<a id="ae88277a5a4f27775a56cf077c759d165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88277a5a4f27775a56cf077c759d165">&#9670;&nbsp;</a></span>mutual_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.structuralholes.mutual_weight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the sum of the weights of the edge from `u` to `v` and
the edge from `v` to `u` in `G`.

`weight` is the edge data key that represents the edge weight. If
the specified key is `None` or is not in the edge data for an edge,
that edge is assumed to have weight 1.

Pre-conditions: `u` and `v` must both be in `G`.</pre> 
</div>
</div>
<a id="aad6692e85a58c9fb16f1be45606fa2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6692e85a58c9fb16f1be45606fa2b3">&#9670;&nbsp;</a></span>normalized_mutual_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.structuralholes.normalized_mutual_weight </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm</em> = <code><a class="el" href="assumed__shape_2foo__free_8f90.html#a1c860bb40bf43c289bc16f8634733f9a">sum</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns normalized mutual weight of the edges from `u` to `v`
with respect to the mutual weights of the neighbors of `u` in `G`.

`norm` specifies how the normalization factor is computed. It must
be a function that takes a single argument and returns a number.
The argument will be an iterable of mutual weights
of pairs ``(u, w)``, where ``w`` ranges over each (in- and
out-)neighbor of ``u``. Commons values for `normalization` are
``sum`` and ``max``.

`weight` can be ``None`` or a string, if None, all edge weights
are considered equal. Otherwise holds the name of the edge
attribute used as weight.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
