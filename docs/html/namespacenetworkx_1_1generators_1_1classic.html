<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.generators.classic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1generators.html">generators</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html">classic</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.generators.classic Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a69efb9b43871ae3c50d10a7103c2cc16"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a69efb9b43871ae3c50d10a7103c2cc16">full_rary_tree</a> (r, n, create_using=None)</td></tr>
<tr class="separator:a69efb9b43871ae3c50d10a7103c2cc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad756a1d5ee001098fc188872b847ceae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#ad756a1d5ee001098fc188872b847ceae">balanced_tree</a> (r, h, create_using=None)</td></tr>
<tr class="separator:ad756a1d5ee001098fc188872b847ceae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19042a529358323ae61e72f1bae99690"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a19042a529358323ae61e72f1bae99690">barbell_graph</a> (m1, m2, create_using=None)</td></tr>
<tr class="separator:a19042a529358323ae61e72f1bae99690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b533c7cec64040c4ffdab95fcb98087"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a3b533c7cec64040c4ffdab95fcb98087">binomial_tree</a> (n, create_using=None)</td></tr>
<tr class="separator:a3b533c7cec64040c4ffdab95fcb98087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc64fea09115f5630c489d951d14f7eb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#adc64fea09115f5630c489d951d14f7eb">complete_graph</a> (n, create_using=None)</td></tr>
<tr class="separator:adc64fea09115f5630c489d951d14f7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac284fe1435875ee1af8de0ce688b85a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#ac284fe1435875ee1af8de0ce688b85a5">circular_ladder_graph</a> (n, create_using=None)</td></tr>
<tr class="separator:ac284fe1435875ee1af8de0ce688b85a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac2eb1c298413c763ae6377ff0c3181"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#abac2eb1c298413c763ae6377ff0c3181">circulant_graph</a> (n, offsets, create_using=None)</td></tr>
<tr class="separator:abac2eb1c298413c763ae6377ff0c3181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45238aab4d2cb9c9e6541b5e5a8de72c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a45238aab4d2cb9c9e6541b5e5a8de72c">cycle_graph</a> (n, create_using=None)</td></tr>
<tr class="separator:a45238aab4d2cb9c9e6541b5e5a8de72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90726aa681ac05681d9c13cbb9c1a06c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a90726aa681ac05681d9c13cbb9c1a06c">dorogovtsev_goltsev_mendes_graph</a> (n, create_using=None)</td></tr>
<tr class="separator:a90726aa681ac05681d9c13cbb9c1a06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93280f4b436feff8bfd9ea04ec5e74b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a93280f4b436feff8bfd9ea04ec5e74b0">empty_graph</a> (n=0, create_using=None, default=<a class="el" href="classnetworkx_1_1classes_1_1graph_1_1Graph.html">Graph</a>)</td></tr>
<tr class="separator:a93280f4b436feff8bfd9ea04ec5e74b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8cf6c6f6623688eb5ceda3a39eb11ec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#ab8cf6c6f6623688eb5ceda3a39eb11ec">ladder_graph</a> (n, create_using=None)</td></tr>
<tr class="separator:ab8cf6c6f6623688eb5ceda3a39eb11ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db7a0434f8dd414559287edd0a65957"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a8db7a0434f8dd414559287edd0a65957">lollipop_graph</a> (m, n, create_using=None)</td></tr>
<tr class="separator:a8db7a0434f8dd414559287edd0a65957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0556de2c6a97a6614334c0a5830644"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a6a0556de2c6a97a6614334c0a5830644">null_graph</a> (create_using=None)</td></tr>
<tr class="separator:a6a0556de2c6a97a6614334c0a5830644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52398ee63be385cd34c1a1cd523401b7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a52398ee63be385cd34c1a1cd523401b7">path_graph</a> (n, create_using=None)</td></tr>
<tr class="separator:a52398ee63be385cd34c1a1cd523401b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9922d057a8798f8b8856665f3effb75a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a9922d057a8798f8b8856665f3effb75a">star_graph</a> (n, create_using=None)</td></tr>
<tr class="separator:a9922d057a8798f8b8856665f3effb75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b7963652c898ec831f49d688d5a7b3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a96b7963652c898ec831f49d688d5a7b3">trivial_graph</a> (create_using=None)</td></tr>
<tr class="separator:a96b7963652c898ec831f49d688d5a7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb69342a777ad423fd6247bd9752e6b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#abfb69342a777ad423fd6247bd9752e6b">turan_graph</a> (n, r)</td></tr>
<tr class="separator:abfb69342a777ad423fd6247bd9752e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26d38d589cb04117e9476e3b5d5d62d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#ac26d38d589cb04117e9476e3b5d5d62d">wheel_graph</a> (n, create_using=None)</td></tr>
<tr class="separator:ac26d38d589cb04117e9476e3b5d5d62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bf451199b8b14c3918b16b93f6fe11"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1classic.html#a40bf451199b8b14c3918b16b93f6fe11">complete_multipartite_graph</a> (subset_sizes)</td></tr>
<tr class="separator:a40bf451199b8b14c3918b16b93f6fe11"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Generators for some classic graphs.

The typical graph builder function is called as follows:

&gt;&gt;&gt; G = nx.complete_graph(100)

returning the complete graph on n nodes labeled 0, .., 99
as a simple graph. Except for `empty_graph`, all the functions
in this module return a Graph class (i.e. a simple, undirected graph).</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ad756a1d5ee001098fc188872b847ceae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad756a1d5ee001098fc188872b847ceae">&#9670;&nbsp;</a></span>balanced_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.balanced_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the perfectly balanced `r`-ary tree of height `h`.

Parameters
----------
r : int
    Branching factor of the tree; each node will have `r`
    children.

h : int
    Height of the tree.

create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Returns
-------
G : NetworkX graph
    A balanced `r`-ary tree of height `h`.

Notes
-----
This is the rooted tree where all leaves are at distance `h` from
the root. The root has degree `r` and all other internal nodes
have degree `r + 1`.

Node labels are integers, starting from zero.

A balanced tree is also known as a *complete r-ary tree*.</pre> 
</div>
</div>
<a id="a19042a529358323ae61e72f1bae99690"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19042a529358323ae61e72f1bae99690">&#9670;&nbsp;</a></span>barbell_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.barbell_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Barbell Graph: two complete graphs connected by a path.

For $m1 &gt; 1$ and $m2 &gt;= 0$.

Two identical complete graphs $K_{m1}$ form the left and right bells,
and are connected by a path $P_{m2}$.

The `2*m1+m2`  nodes are numbered
    `0, ..., m1-1` for the left barbell,
    `m1, ..., m1+m2-1` for the path,
    and `m1+m2, ..., 2*m1+m2-1` for the right barbell.

The 3 subgraphs are joined via the edges `(m1-1, m1)` and
`(m1+m2-1, m1+m2)`. If `m2=0`, this is merely two complete
graphs joined together.

This graph is an extremal example in David Aldous
and Jim Fill's e-text on Random Walks on Graphs.</pre> 
</div>
</div>
<a id="a3b533c7cec64040c4ffdab95fcb98087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b533c7cec64040c4ffdab95fcb98087">&#9670;&nbsp;</a></span>binomial_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.binomial_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Binomial Tree of order n.

The binomial tree of order 0 consists of a single node. A binomial tree of order k
is defined recursively by linking two binomial trees of order k-1: the root of one is
the leftmost child of the root of the other.

Parameters
----------
n : int
    Order of the binomial tree.

create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Returns
-------
G : NetworkX graph
    A binomial tree of $2^n$ nodes and $2^n - 1$ edges.</pre> 
</div>
</div>
<a id="abac2eb1c298413c763ae6377ff0c3181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac2eb1c298413c763ae6377ff0c3181">&#9670;&nbsp;</a></span>circulant_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.circulant_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the circulant graph $Ci_n(x_1, x_2, ..., x_m)$ with $n$ nodes.

The circulant graph $Ci_n(x_1, ..., x_m)$ consists of $n$ nodes $0, ..., n-1$
such that node $i$ is connected to nodes $(i + x) \mod n$ and $(i - x) \mod n$
for all $x$ in $x_1, ..., x_m$. Thus $Ci_n(1)$ is a cycle graph.

Parameters
----------
n : integer
    The number of nodes in the graph.
offsets : list of integers
    A list of node offsets, $x_1$ up to $x_m$, as described above.
create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Returns
-------
NetworkX Graph of type create_using

Examples
--------
Many well-known graph families are subfamilies of the circulant graphs;
for example, to create the cycle graph on n points, we connect every
node to nodes on either side (with offset plus or minus one). For n = 10,

&gt;&gt;&gt; G = nx.circulant_graph(10, [1])
&gt;&gt;&gt; edges = [
...     (0, 9),
...     (0, 1),
...     (1, 2),
...     (2, 3),
...     (3, 4),
...     (4, 5),
...     (5, 6),
...     (6, 7),
...     (7, 8),
...     (8, 9),
... ]
...
&gt;&gt;&gt; sorted(edges) == sorted(G.edges())
True

Similarly, we can create the complete graph
on 5 points with the set of offsets [1, 2]:

&gt;&gt;&gt; G = nx.circulant_graph(5, [1, 2])
&gt;&gt;&gt; edges = [
...     (0, 1),
...     (0, 2),
...     (0, 3),
...     (0, 4),
...     (1, 2),
...     (1, 3),
...     (1, 4),
...     (2, 3),
...     (2, 4),
...     (3, 4),
... ]
...
&gt;&gt;&gt; sorted(edges) == sorted(G.edges())
True</pre> 
</div>
</div>
<a id="ac284fe1435875ee1af8de0ce688b85a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac284fe1435875ee1af8de0ce688b85a5">&#9670;&nbsp;</a></span>circular_ladder_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.circular_ladder_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the circular ladder graph $CL_n$ of length n.

$CL_n$ consists of two concentric n-cycles in which
each of the n pairs of concentric nodes are joined by an edge.

Node labels are the integers 0 to n-1</pre> 
</div>
</div>
<a id="adc64fea09115f5630c489d951d14f7eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc64fea09115f5630c489d951d14f7eb">&#9670;&nbsp;</a></span>complete_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.complete_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the complete graph `K_n` with n nodes.

A complete graph on `n` nodes means that all pairs
of distinct nodes have an edge connecting them.

Parameters
----------
n : int or iterable container of nodes
    If n is an integer, nodes are from range(n).
    If n is a container of nodes, those nodes appear in the graph.
create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Examples
--------
&gt;&gt;&gt; G = nx.complete_graph(9)
&gt;&gt;&gt; len(G)
9
&gt;&gt;&gt; G.size()
36
&gt;&gt;&gt; G = nx.complete_graph(range(11, 14))
&gt;&gt;&gt; list(G.nodes())
[11, 12, 13]
&gt;&gt;&gt; G = nx.complete_graph(4, nx.DiGraph())
&gt;&gt;&gt; G.is_directed()
True</pre> 
</div>
</div>
<a id="a40bf451199b8b14c3918b16b93f6fe11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bf451199b8b14c3918b16b93f6fe11">&#9670;&nbsp;</a></span>complete_multipartite_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.complete_multipartite_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subset_sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the complete multipartite graph with the specified subset sizes.

Parameters
----------
subset_sizes : tuple of integers or tuple of node iterables
   The arguments can either all be integer number of nodes or they
   can all be iterables of nodes. If integers, they represent the
   number of nodes in each subset of the multipartite graph.
   If iterables, each is used to create the nodes for that subset.
   The length of subset_sizes is the number of subsets.

Returns
-------
G : NetworkX Graph
   Returns the complete multipartite graph with the specified subsets.

   For each node, the node attribute 'subset' is an integer
   indicating which subset contains the node.

Examples
--------
Creating a complete tripartite graph, with subsets of one, two, and three
nodes, respectively.

    &gt;&gt;&gt; G = nx.complete_multipartite_graph(1, 2, 3)
    &gt;&gt;&gt; [G.nodes[u]["subset"] for u in G]
    [0, 1, 1, 2, 2, 2]
    &gt;&gt;&gt; list(G.edges(0))
    [(0, 1), (0, 2), (0, 3), (0, 4), (0, 5)]
    &gt;&gt;&gt; list(G.edges(2))
    [(2, 0), (2, 3), (2, 4), (2, 5)]
    &gt;&gt;&gt; list(G.edges(4))
    [(4, 0), (4, 1), (4, 2)]

    &gt;&gt;&gt; G = nx.complete_multipartite_graph("a", "bc", "def")
    &gt;&gt;&gt; [G.nodes[u]["subset"] for u in sorted(G)]
    [0, 1, 1, 2, 2, 2]

Notes
-----
This function generalizes several other graph builder functions.

- If no subset sizes are given, this returns the null graph.
- If a single subset size `n` is given, this returns the empty graph on
  `n` nodes.
- If two subset sizes `m` and `n` are given, this returns the complete
  bipartite graph on `m + n` nodes.
- If subset sizes `1` and `n` are given, this returns the star graph on
  `n + 1` nodes.

See also
--------
complete_bipartite_graph
</pre> 
</div>
</div>
<a id="a45238aab4d2cb9c9e6541b5e5a8de72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45238aab4d2cb9c9e6541b5e5a8de72c">&#9670;&nbsp;</a></span>cycle_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.cycle_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the cycle graph $C_n$ of cyclically connected nodes.

$C_n$ is a path with its two end-nodes connected.

Parameters
----------
n : int or iterable container of nodes
    If n is an integer, nodes are from `range(n)`.
    If n is a container of nodes, those nodes appear in the graph.
create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Notes
-----
If create_using is directed, the direction is in increasing order.</pre> 
</div>
</div>
<a id="a90726aa681ac05681d9c13cbb9c1a06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90726aa681ac05681d9c13cbb9c1a06c">&#9670;&nbsp;</a></span>dorogovtsev_goltsev_mendes_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.dorogovtsev_goltsev_mendes_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the hierarchically constructed Dorogovtsev-Goltsev-Mendes graph.

n is the generation.
See: arXiv:/cond-mat/0112143 by Dorogovtsev, Goltsev and Mendes.</pre> 
</div>
</div>
<a id="a93280f4b436feff8bfd9ea04ec5e74b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93280f4b436feff8bfd9ea04ec5e74b0">&#9670;&nbsp;</a></span>empty_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.empty_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code><a class="el" href="classnetworkx_1_1classes_1_1graph_1_1Graph.html">Graph</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the empty graph with n nodes and zero edges.

Parameters
----------
n : int or iterable container of nodes (default = 0)
    If n is an integer, nodes are from `range(n)`.
    If n is a container of nodes, those nodes appear in the graph.
create_using : Graph Instance, Constructor or None
    Indicator of type of graph to return.
    If a Graph-type instance, then clear and use it.
    If None, use the `default` constructor.
    If a constructor, call it to create an empty graph.
default : Graph constructor (optional, default = nx.Graph)
    The constructor to use if create_using is None.
    If None, then nx.Graph is used.
    This is used when passing an unknown `create_using` value
    through your home-grown function to `empty_graph` and
    you want a default constructor other than nx.Graph.

Examples
--------
&gt;&gt;&gt; G = nx.empty_graph(10)
&gt;&gt;&gt; G.number_of_nodes()
10
&gt;&gt;&gt; G.number_of_edges()
0
&gt;&gt;&gt; G = nx.empty_graph("ABC")
&gt;&gt;&gt; G.number_of_nodes()
3
&gt;&gt;&gt; sorted(G)
['A', 'B', 'C']

Notes
-----
The variable create_using should be a Graph Constructor or a
"graph"-like object. Constructors, e.g. `nx.Graph` or `nx.MultiGraph`
will be used to create the returned graph. "graph"-like objects
will be cleared (nodes and edges will be removed) and refitted as
an empty "graph" with nodes specified in n. This capability
is useful for specifying the class-nature of the resulting empty
"graph" (i.e. Graph, DiGraph, MyWeirdGraphClass, etc.).

The variable create_using has three main uses:
Firstly, the variable create_using can be used to create an
empty digraph, multigraph, etc.  For example,

&gt;&gt;&gt; n = 10
&gt;&gt;&gt; G = nx.empty_graph(n, create_using=nx.DiGraph)

will create an empty digraph on n nodes.

Secondly, one can pass an existing graph (digraph, multigraph,
etc.) via create_using. For example, if G is an existing graph
(resp. digraph, multigraph, etc.), then empty_graph(n, create_using=G)
will empty G (i.e. delete all nodes and edges using G.clear())
and then add n nodes and zero edges, and return the modified graph.

Thirdly, when constructing your home-grown graph creation function
you can use empty_graph to construct the graph by passing a user
defined create_using to empty_graph. In this case, if you want the
default constructor to be other than nx.Graph, specify `default`.

&gt;&gt;&gt; def mygraph(n, create_using=None):
...     G = nx.empty_graph(n, create_using, nx.MultiGraph)
...     G.add_edges_from([(0, 1), (0, 1)])
...     return G
&gt;&gt;&gt; G = mygraph(3)
&gt;&gt;&gt; G.is_multigraph()
True
&gt;&gt;&gt; G = mygraph(3, nx.Graph)
&gt;&gt;&gt; G.is_multigraph()
False

See also create_empty_copy(G).</pre> 
</div>
</div>
<a id="a69efb9b43871ae3c50d10a7103c2cc16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69efb9b43871ae3c50d10a7103c2cc16">&#9670;&nbsp;</a></span>full_rary_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.full_rary_tree </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a full r-ary tree of `n` nodes.

Sometimes called a k-ary, n-ary, or m-ary tree.
"... all non-leaf nodes have exactly r children and all levels
are full except for some rightmost position of the bottom level
(if a leaf at the bottom level is missing, then so are all of the
leaves to its right." [1]_

Parameters
----------
r : int
    branching factor of the tree
n : int
    Number of nodes in the tree
create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Returns
-------
G : networkx Graph
    An r-ary tree with n nodes

References
----------
.. [1] An introduction to data structures and algorithms,
       James Andrew Storer,  Birkhauser Boston 2001, (page 225).
</pre> 
</div>
</div>
<a id="ab8cf6c6f6623688eb5ceda3a39eb11ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8cf6c6f6623688eb5ceda3a39eb11ec">&#9670;&nbsp;</a></span>ladder_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.ladder_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Ladder graph of length n.

This is two paths of n nodes, with
each pair connected by a single edge.

Node labels are the integers 0 to 2*n - 1.</pre> 
</div>
</div>
<a id="a8db7a0434f8dd414559287edd0a65957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db7a0434f8dd414559287edd0a65957">&#9670;&nbsp;</a></span>lollipop_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.lollipop_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Lollipop Graph; `K_m` connected to `P_n`.

This is the Barbell Graph without the right barbell.

Parameters
----------
m, n : int or iterable container of nodes (default = 0)
    If an integer, nodes are from `range(m)` and `range(m,m+n)`.
    If a container, the entries are the coordinate of the node.

    The nodes for m appear in the complete graph $K_m$ and the nodes
    for n appear in the path $P_n$
create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Notes
-----
The 2 subgraphs are joined via an edge (m-1, m).
If n=0, this is merely a complete graph.

(This graph is an extremal example in David Aldous and Jim
Fill's etext on Random Walks on Graphs.)</pre> 
</div>
</div>
<a id="a6a0556de2c6a97a6614334c0a5830644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a0556de2c6a97a6614334c0a5830644">&#9670;&nbsp;</a></span>null_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.null_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Null graph with no nodes or edges.

See empty_graph for the use of create_using.</pre> 
</div>
</div>
<a id="a52398ee63be385cd34c1a1cd523401b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52398ee63be385cd34c1a1cd523401b7">&#9670;&nbsp;</a></span>path_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.path_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Path graph `P_n` of linearly connected nodes.

Parameters
----------
n : int or iterable
    If an integer, nodes are 0 to n - 1.
    If an iterable of nodes, in the order they appear in the path.
create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.</pre> 
</div>
</div>
<a id="a9922d057a8798f8b8856665f3effb75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9922d057a8798f8b8856665f3effb75a">&#9670;&nbsp;</a></span>star_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.star_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the star graph

The star graph consists of one center node connected to n outer nodes.

Parameters
----------
n : int or iterable
    If an integer, node labels are 0 to n with center 0.
    If an iterable of nodes, the center is the first.
create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Notes
-----
The graph has n+1 nodes for integer n.
So star_graph(3) is the same as star_graph(range(4)).
</pre> 
</div>
</div>
<a id="a96b7963652c898ec831f49d688d5a7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b7963652c898ec831f49d688d5a7b3">&#9670;&nbsp;</a></span>trivial_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.trivial_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Trivial graph with one node (with label 0) and no edges.</pre> 
</div>
</div>
<a id="abfb69342a777ad423fd6247bd9752e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb69342a777ad423fd6247bd9752e6b">&#9670;&nbsp;</a></span>turan_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.turan_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the Turan Graph

The Turan Graph is a complete multipartite graph on $n$ nodes
with $r$ disjoint subsets. That is, edges connect each node to
every node not in its subset.

Given $n$ and $r$, we create a complete multipartite graph with
$r-(n \mod r)$ partitions of size $n/r$, rounded down, and
$n \mod r$ partitions of size $n/r+1$, rounded down.

Parameters
----------
n : int
    The number of nodes.
r : int
    The number of partitions.
    Must be less than or equal to n.

Notes
-----
Must satisfy $1 &lt;= r &lt;= n$.
The graph has $(r-1)(n^2)/(2r)$ edges, rounded down.
</pre> 
</div>
</div>
<a id="ac26d38d589cb04117e9476e3b5d5d62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26d38d589cb04117e9476e3b5d5d62d">&#9670;&nbsp;</a></span>wheel_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.classic.wheel_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the wheel graph

The wheel graph consists of a hub node connected to a cycle of (n-1) nodes.

Parameters
----------
n : int or iterable
    If an integer, node labels are 0 to n with center 0.
    If an iterable of nodes, the center is the first.
create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Node labels are the integers 0 to n - 1.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
