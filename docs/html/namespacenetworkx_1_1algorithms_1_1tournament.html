<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.tournament Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1tournament.html">tournament</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.tournament Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab9bfdfdd0a78f649c7aa5df464eca01c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1tournament.html#ab9bfdfdd0a78f649c7aa5df464eca01c">index_satisfying</a> (iterable, condition)</td></tr>
<tr class="separator:ab9bfdfdd0a78f649c7aa5df464eca01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7af5e6b1f7adca3f88ebdba688bfa32"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1tournament.html#ab7af5e6b1f7adca3f88ebdba688bfa32">is_tournament</a> (G)</td></tr>
<tr class="separator:ab7af5e6b1f7adca3f88ebdba688bfa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afddc5b951e3fc5c0c168ccc59d22dc13"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1tournament.html#afddc5b951e3fc5c0c168ccc59d22dc13">hamiltonian_path</a> (G)</td></tr>
<tr class="separator:afddc5b951e3fc5c0c168ccc59d22dc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bd679c817dc73450fc323ed6229ca0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1tournament.html#ad7bd679c817dc73450fc323ed6229ca0">random_tournament</a> (n, seed=None)</td></tr>
<tr class="separator:ad7bd679c817dc73450fc323ed6229ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22537a4c3e27c60abf92e5ab0dded40"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1tournament.html#af22537a4c3e27c60abf92e5ab0dded40">score_sequence</a> (G)</td></tr>
<tr class="separator:af22537a4c3e27c60abf92e5ab0dded40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70eda0ba7f3f278d7c976752855d0c3c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1tournament.html#a70eda0ba7f3f278d7c976752855d0c3c">tournament_matrix</a> (G)</td></tr>
<tr class="separator:a70eda0ba7f3f278d7c976752855d0c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a915c326ebe1518ca9117308c2f2ce"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1tournament.html#a28a915c326ebe1518ca9117308c2f2ce">is_reachable</a> (G, s, t)</td></tr>
<tr class="separator:a28a915c326ebe1518ca9117308c2f2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e02266052eea4c0359eec64b9b9f694"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1tournament.html#a2e02266052eea4c0359eec64b9b9f694">is_strongly_connected</a> (G)</td></tr>
<tr class="separator:a2e02266052eea4c0359eec64b9b9f694"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions concerning tournament graphs.

A `tournament graph`_ is a complete oriented graph. In other words, it
is a directed graph in which there is exactly one directed edge joining
each pair of distinct nodes. For each function in this module that
accepts a graph as input, you must provide a tournament graph. The
responsibility is on the caller to ensure that the graph is a tournament
graph.

To access the functions in this module, you must access them through the
:mod:`networkx.algorithms.tournament` module::

&gt;&gt;&gt; from networkx.algorithms import tournament
&gt;&gt;&gt; G = nx.DiGraph([(0, 1), (1, 2), (2, 0)])
&gt;&gt;&gt; tournament.is_tournament(G)
True

.. _tournament graph: https://en.wikipedia.org/wiki/Tournament_%28graph_theory%29</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="afddc5b951e3fc5c0c168ccc59d22dc13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afddc5b951e3fc5c0c168ccc59d22dc13">&#9670;&nbsp;</a></span>hamiltonian_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.tournament.hamiltonian_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a Hamiltonian path in the given tournament graph.

Each tournament has a Hamiltonian path. If furthermore, the
tournament is strongly connected, then the returned Hamiltonian path
is a Hamiltonian cycle (by joining the endpoints of the path).

Parameters
----------
G : NetworkX graph
    A directed graph representing a tournament.

Returns
-------
path : list
    A list of nodes which form a Hamiltonian path in `G`.

Notes
-----
This is a recursive implementation with an asymptotic running time
of $O(n^2)$, ignoring multiplicative polylogarithmic factors, where
$n$ is the number of nodes in the graph.</pre> 
</div>
</div>
<a id="ab9bfdfdd0a78f649c7aa5df464eca01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9bfdfdd0a78f649c7aa5df464eca01c">&#9670;&nbsp;</a></span>index_satisfying()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.tournament.index_satisfying </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>condition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the index of the first element in `iterable` that
satisfies the given condition.

If no such element is found (that is, when the iterable is
exhausted), this returns the length of the iterable (that is, one
greater than the last index of the iterable).

`iterable` must not be empty. If `iterable` is empty, this
function raises :exc:`ValueError`.</pre> 
</div>
</div>
<a id="a28a915c326ebe1518ca9117308c2f2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a915c326ebe1518ca9117308c2f2ce">&#9670;&nbsp;</a></span>is_reachable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.tournament.is_reachable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decides whether there is a path from `s` to `t` in the
tournament.

This function is more theoretically efficient than the reachability
checks than the shortest path algorithms in
:mod:`networkx.algorithms.shortest_paths`.

The given graph **must** be a tournament, otherwise this function's
behavior is undefined.

Parameters
----------
G : NetworkX graph
    A directed graph representing a tournament.

s : node
    A node in the graph.

t : node
    A node in the graph.

Returns
-------
bool
    Whether there is a path from `s` to `t` in `G`.

Notes
-----
Although this function is more theoretically efficient than the
generic shortest path functions, a speedup requires the use of
parallelism. Though it may in the future, the current implementation
does not use parallelism, thus you may not see much of a speedup.

This algorithm comes from [1].

References
----------
.. [1] Tantau, Till.
       "A note on the complexity of the reachability problem for
       tournaments."
       *Electronic Colloquium on Computational Complexity*. 2001.
       &lt;http://eccc.hpi-web.de/report/2001/092/&gt;
</pre> 
</div>
</div>
<a id="a2e02266052eea4c0359eec64b9b9f694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e02266052eea4c0359eec64b9b9f694">&#9670;&nbsp;</a></span>is_strongly_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.tournament.is_strongly_connected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decides whether the given tournament is strongly connected.

This function is more theoretically efficient than the
:func:`~networkx.algorithms.components.is_strongly_connected`
function.

The given graph **must** be a tournament, otherwise this function's
behavior is undefined.

Parameters
----------
G : NetworkX graph
    A directed graph representing a tournament.

Returns
-------
bool
    Whether the tournament is strongly connected.

Notes
-----
Although this function is more theoretically efficient than the
generic strong connectivity function, a speedup requires the use of
parallelism. Though it may in the future, the current implementation
does not use parallelism, thus you may not see much of a speedup.

This algorithm comes from [1].

References
----------
.. [1] Tantau, Till.
       "A note on the complexity of the reachability problem for
       tournaments."
       *Electronic Colloquium on Computational Complexity*. 2001.
       &lt;http://eccc.hpi-web.de/report/2001/092/&gt;</pre> 
</div>
</div>
<a id="ab7af5e6b1f7adca3f88ebdba688bfa32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7af5e6b1f7adca3f88ebdba688bfa32">&#9670;&nbsp;</a></span>is_tournament()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.tournament.is_tournament </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if and only if `G` is a tournament.

A tournament is a directed graph, with neither self-loops nor
multi-edges, in which there is exactly one directed edge joining
each pair of distinct nodes.

Parameters
----------
G : NetworkX graph
    A directed graph representing a tournament.

Returns
-------
bool
    Whether the given graph is a tournament graph.

Notes
-----
Some definitions require a self-loop on each node, but that is not
the convention used here.</pre> 
</div>
</div>
<a id="ad7bd679c817dc73450fc323ed6229ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bd679c817dc73450fc323ed6229ca0">&#9670;&nbsp;</a></span>random_tournament()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.tournament.random_tournament </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a random tournament graph on `n` nodes.

Parameters
----------
n : int
    The number of nodes in the returned graph.
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
G : DiGraph
    A tournament on `n` nodes, with exactly one directed edge joining
    each pair of distinct nodes.

Notes
-----
This algorithm adds, for each pair of distinct nodes, an edge with
uniformly random orientation. In other words, `\binom{n}{2}` flips
of an unbiased coin decide the orientations of the edges in the
graph.</pre> 
</div>
</div>
<a id="af22537a4c3e27c60abf92e5ab0dded40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22537a4c3e27c60abf92e5ab0dded40">&#9670;&nbsp;</a></span>score_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.tournament.score_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the score sequence for the given tournament graph.

The score sequence is the sorted list of the out-degrees of the
nodes of the graph.

Parameters
----------
G : NetworkX graph
    A directed graph representing a tournament.

Returns
-------
list
    A sorted list of the out-degrees of the nodes of `G`.</pre> 
</div>
</div>
<a id="a70eda0ba7f3f278d7c976752855d0c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70eda0ba7f3f278d7c976752855d0c3c">&#9670;&nbsp;</a></span>tournament_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.tournament.tournament_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the tournament matrix for the given tournament graph.

This function requires SciPy.

The *tournament matrix* of a tournament graph with edge set *E* is
the matrix *T* defined by

.. math::

   T_{i j} =
   \begin{cases}
   +1 &amp; \text{if } (i, j) \in E \\
   -1 &amp; \text{if } (j, i) \in E \\
   0 &amp; \text{if } i == j.
   \end{cases}

An equivalent definition is `T = A - A^T`, where *A* is the
adjacency matrix of the graph `G`.

Parameters
----------
G : NetworkX graph
    A directed graph representing a tournament.

Returns
-------
SciPy sparse matrix
    The tournament matrix of the tournament graph `G`.

Raises
------
ImportError
    If SciPy is not available.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
