<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.components.biconnected Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1components.html">components</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1components_1_1biconnected.html">biconnected</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.components.biconnected Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a883b29aa8dfc5ce49acd93d453d961f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1components_1_1biconnected.html#a883b29aa8dfc5ce49acd93d453d961f8">is_biconnected</a> (G)</td></tr>
<tr class="separator:a883b29aa8dfc5ce49acd93d453d961f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f25e7eda267b9c5c7d63fe6593fd72"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1components_1_1biconnected.html#a04f25e7eda267b9c5c7d63fe6593fd72">biconnected_component_edges</a> (G)</td></tr>
<tr class="separator:a04f25e7eda267b9c5c7d63fe6593fd72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7650342e0d90dab9d3256430eab537"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1components_1_1biconnected.html#a6b7650342e0d90dab9d3256430eab537">biconnected_components</a> (G)</td></tr>
<tr class="separator:a6b7650342e0d90dab9d3256430eab537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07e52e2d68677dbf6b1fa4c7d9ee09b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1components_1_1biconnected.html#aa07e52e2d68677dbf6b1fa4c7d9ee09b">articulation_points</a> (G)</td></tr>
<tr class="separator:aa07e52e2d68677dbf6b1fa4c7d9ee09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Biconnected components and articulation points.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aa07e52e2d68677dbf6b1fa4c7d9ee09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07e52e2d68677dbf6b1fa4c7d9ee09b">&#9670;&nbsp;</a></span>articulation_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.components.biconnected.articulation_points </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the articulation points, or cut vertices, of a graph.

An articulation point or cut vertex is any node whose removal (along with
all its incident edges) increases the number of connected components of
a graph.  An undirected connected graph without articulation points is
biconnected. Articulation points belong to more than one biconnected
component of a graph.

Notice that by convention a dyad is considered a biconnected component.

Parameters
----------
G : NetworkX Graph
    An undirected graph.

Yields
------
node
    An articulation point in the graph.

Raises
------
NetworkXNotImplemented
    If the input graph is not undirected.

Examples
--------

&gt;&gt;&gt; G = nx.barbell_graph(4, 2)
&gt;&gt;&gt; print(nx.is_biconnected(G))
False
&gt;&gt;&gt; len(list(nx.articulation_points(G)))
4
&gt;&gt;&gt; G.add_edge(2, 8)
&gt;&gt;&gt; print(nx.is_biconnected(G))
True
&gt;&gt;&gt; len(list(nx.articulation_points(G)))
0

See Also
--------
is_biconnected
biconnected_components
biconnected_component_edges

Notes
-----
The algorithm to find articulation points and biconnected
components is implemented using a non-recursive depth-first-search
(DFS) that keeps track of the highest level that back edges reach
in the DFS tree.  A node `n` is an articulation point if, and only
if, there exists a subtree rooted at `n` such that there is no
back edge from any successor of `n` that links to a predecessor of
`n` in the DFS tree.  By keeping track of all the edges traversed
by the DFS we can obtain the biconnected components because all
edges of a bicomponent will be traversed consecutively between
articulation points.

References
----------
.. [1] Hopcroft, J.; Tarjan, R. (1973).
       "Efficient algorithms for graph manipulation".
       Communications of the ACM 16: 372–378. doi:10.1145/362248.362272</pre> 
</div>
</div>
<a id="a04f25e7eda267b9c5c7d63fe6593fd72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f25e7eda267b9c5c7d63fe6593fd72">&#9670;&nbsp;</a></span>biconnected_component_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.components.biconnected.biconnected_component_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a generator of lists of edges, one list for each biconnected
component of the input graph.

Biconnected components are maximal subgraphs such that the removal of a
node (and all edges incident on that node) will not disconnect the
subgraph.  Note that nodes may be part of more than one biconnected
component.  Those nodes are articulation points, or cut vertices.
However, each edge belongs to one, and only one, biconnected component.

Notice that by convention a dyad is considered a biconnected component.

Parameters
----------
G : NetworkX Graph
    An undirected graph.

Returns
-------
edges : generator of lists
    Generator of lists of edges, one list for each bicomponent.

Raises
------
NetworkXNotImplemented
    If the input graph is not undirected.

Examples
--------
&gt;&gt;&gt; G = nx.barbell_graph(4, 2)
&gt;&gt;&gt; print(nx.is_biconnected(G))
False
&gt;&gt;&gt; bicomponents_edges = list(nx.biconnected_component_edges(G))
&gt;&gt;&gt; len(bicomponents_edges)
5
&gt;&gt;&gt; G.add_edge(2, 8)
&gt;&gt;&gt; print(nx.is_biconnected(G))
True
&gt;&gt;&gt; bicomponents_edges = list(nx.biconnected_component_edges(G))
&gt;&gt;&gt; len(bicomponents_edges)
1

See Also
--------
is_biconnected,
biconnected_components,
articulation_points,

Notes
-----
The algorithm to find articulation points and biconnected
components is implemented using a non-recursive depth-first-search
(DFS) that keeps track of the highest level that back edges reach
in the DFS tree.  A node `n` is an articulation point if, and only
if, there exists a subtree rooted at `n` such that there is no
back edge from any successor of `n` that links to a predecessor of
`n` in the DFS tree.  By keeping track of all the edges traversed
by the DFS we can obtain the biconnected components because all
edges of a bicomponent will be traversed consecutively between
articulation points.

References
----------
.. [1] Hopcroft, J.; Tarjan, R. (1973).
       "Efficient algorithms for graph manipulation".
       Communications of the ACM 16: 372–378. doi:10.1145/362248.362272</pre> 
</div>
</div>
<a id="a6b7650342e0d90dab9d3256430eab537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7650342e0d90dab9d3256430eab537">&#9670;&nbsp;</a></span>biconnected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.components.biconnected.biconnected_components </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a generator of sets of nodes, one set for each biconnected
component of the graph

Biconnected components are maximal subgraphs such that the removal of a
node (and all edges incident on that node) will not disconnect the
subgraph. Note that nodes may be part of more than one biconnected
component.  Those nodes are articulation points, or cut vertices.  The
removal of articulation points will increase the number of connected
components of the graph.

Notice that by convention a dyad is considered a biconnected component.

Parameters
----------
G : NetworkX Graph
    An undirected graph.

Returns
-------
nodes : generator
    Generator of sets of nodes, one set for each biconnected component.

Raises
------
NetworkXNotImplemented
    If the input graph is not undirected.

Examples
--------
&gt;&gt;&gt; G = nx.lollipop_graph(5, 1)
&gt;&gt;&gt; print(nx.is_biconnected(G))
False
&gt;&gt;&gt; bicomponents = list(nx.biconnected_components(G))
&gt;&gt;&gt; len(bicomponents)
2
&gt;&gt;&gt; G.add_edge(0, 5)
&gt;&gt;&gt; print(nx.is_biconnected(G))
True
&gt;&gt;&gt; bicomponents = list(nx.biconnected_components(G))
&gt;&gt;&gt; len(bicomponents)
1

You can generate a sorted list of biconnected components, largest
first, using sort.

&gt;&gt;&gt; G.remove_edge(0, 5)
&gt;&gt;&gt; [len(c) for c in sorted(nx.biconnected_components(G), key=len, reverse=True)]
[5, 2]

If you only want the largest connected component, it's more
efficient to use max instead of sort.

&gt;&gt;&gt; Gc = max(nx.biconnected_components(G), key=len)

To create the components as subgraphs use:
``(G.subgraph(c).copy() for c in biconnected_components(G))``

See Also
--------
is_biconnected
articulation_points
biconnected_component_edges
k_components : this function is a special case where k=2
bridge_components : similar to this function, but is defined using
    2-edge-connectivity instead of 2-node-connectivity.

Notes
-----
The algorithm to find articulation points and biconnected
components is implemented using a non-recursive depth-first-search
(DFS) that keeps track of the highest level that back edges reach
in the DFS tree.  A node `n` is an articulation point if, and only
if, there exists a subtree rooted at `n` such that there is no
back edge from any successor of `n` that links to a predecessor of
`n` in the DFS tree.  By keeping track of all the edges traversed
by the DFS we can obtain the biconnected components because all
edges of a bicomponent will be traversed consecutively between
articulation points.

References
----------
.. [1] Hopcroft, J.; Tarjan, R. (1973).
       "Efficient algorithms for graph manipulation".
       Communications of the ACM 16: 372–378. doi:10.1145/362248.362272</pre> 
</div>
</div>
<a id="a883b29aa8dfc5ce49acd93d453d961f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883b29aa8dfc5ce49acd93d453d961f8">&#9670;&nbsp;</a></span>is_biconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.components.biconnected.is_biconnected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the graph is biconnected, False otherwise.

A graph is biconnected if, and only if, it cannot be disconnected by
removing only one node (and all edges incident on that node).  If
removing a node increases the number of disconnected components
in the graph, that node is called an articulation point, or cut
vertex.  A biconnected graph has no articulation points.

Parameters
----------
G : NetworkX Graph
    An undirected graph.

Returns
-------
biconnected : bool
    True if the graph is biconnected, False otherwise.

Raises
------
NetworkXNotImplemented
    If the input graph is not undirected.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; print(nx.is_biconnected(G))
False
&gt;&gt;&gt; G.add_edge(0, 3)
&gt;&gt;&gt; print(nx.is_biconnected(G))
True

See Also
--------
biconnected_components
articulation_points
biconnected_component_edges
is_strongly_connected
is_weakly_connected
is_connected
is_semiconnected

Notes
-----
The algorithm to find articulation points and biconnected
components is implemented using a non-recursive depth-first-search
(DFS) that keeps track of the highest level that back edges reach
in the DFS tree.  A node `n` is an articulation point if, and only
if, there exists a subtree rooted at `n` such that there is no
back edge from any successor of `n` that links to a predecessor of
`n` in the DFS tree.  By keeping track of all the edges traversed
by the DFS we can obtain the biconnected components because all
edges of a bicomponent will be traversed consecutively between
articulation points.

References
----------
.. [1] Hopcroft, J.; Tarjan, R. (1973).
   "Efficient algorithms for graph manipulation".
   Communications of the ACM 16: 372–378. doi:10.1145/362248.362272</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
