<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.drawing.layout Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1drawing.html">drawing</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html">layout</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">networkx.drawing.layout Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:addafb2807d9e7cb9a5f464ce70bc2e1b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#addafb2807d9e7cb9a5f464ce70bc2e1b">random_layout</a> (G, center=None, dim=2, seed=None)</td></tr>
<tr class="separator:addafb2807d9e7cb9a5f464ce70bc2e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f2fac85819ae55ebd51de00e25bf75"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#ad5f2fac85819ae55ebd51de00e25bf75">circular_layout</a> (G, scale=1, center=None, dim=2)</td></tr>
<tr class="separator:ad5f2fac85819ae55ebd51de00e25bf75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda61265a93a6d2ff4f19c624723d387"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#afda61265a93a6d2ff4f19c624723d387">shell_layout</a> (G, nlist=None, rotate=None, scale=1, center=None, dim=2)</td></tr>
<tr class="separator:afda61265a93a6d2ff4f19c624723d387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333ec4bb45a6a3490bcd462b06ff025a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#a333ec4bb45a6a3490bcd462b06ff025a">bipartite_layout</a> (G, nodes, align=&quot;vertical&quot;, scale=1, center=None, aspect_ratio=4/3)</td></tr>
<tr class="separator:a333ec4bb45a6a3490bcd462b06ff025a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49950bbfa7bf1c305bc9e049459ab7b9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#a49950bbfa7bf1c305bc9e049459ab7b9">spring_layout</a> (G, k=None, pos=None, fixed=None, iterations=50, threshold=1e-4, weight=&quot;weight&quot;, scale=1, center=None, dim=2, seed=None)</td></tr>
<tr class="separator:a49950bbfa7bf1c305bc9e049459ab7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab42bac0264130fda591b926dc36600"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#a6ab42bac0264130fda591b926dc36600">kamada_kawai_layout</a> (G, dist=None, pos=None, weight=&quot;weight&quot;, scale=1, center=None, dim=2)</td></tr>
<tr class="separator:a6ab42bac0264130fda591b926dc36600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac947260649039048ed839ba8fcba2428"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#ac947260649039048ed839ba8fcba2428">spectral_layout</a> (G, weight=&quot;weight&quot;, scale=1, center=None, dim=2)</td></tr>
<tr class="separator:ac947260649039048ed839ba8fcba2428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e8021cbef52e60e267eed205c99e1f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#aa9e8021cbef52e60e267eed205c99e1f">planar_layout</a> (G, scale=1, center=None, dim=2)</td></tr>
<tr class="separator:aa9e8021cbef52e60e267eed205c99e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3594891dab725686c99df4708e7d01a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#a3594891dab725686c99df4708e7d01a7">spiral_layout</a> (G, scale=1, center=None, dim=2, resolution=0.35, equidistant=False)</td></tr>
<tr class="separator:a3594891dab725686c99df4708e7d01a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5aad61461478c634351e735fdb815b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#a3d5aad61461478c634351e735fdb815b">multipartite_layout</a> (G, subset_key=&quot;subset&quot;, align=&quot;vertical&quot;, scale=1, center=None)</td></tr>
<tr class="separator:a3d5aad61461478c634351e735fdb815b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ddcb7319b47ee6b98301e3a15be250"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#af6ddcb7319b47ee6b98301e3a15be250">rescale_layout</a> (pos, scale=1)</td></tr>
<tr class="separator:af6ddcb7319b47ee6b98301e3a15be250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da50cbee09c4590ddb983e828ee5c91"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#a9da50cbee09c4590ddb983e828ee5c91">rescale_layout_dict</a> (pos, scale=1)</td></tr>
<tr class="separator:a9da50cbee09c4590ddb983e828ee5c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0778ce3d6875858bcd5f59b42f87ebff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1drawing_1_1layout.html#a0778ce3d6875858bcd5f59b42f87ebff">fruchterman_reingold_layout</a></td></tr>
<tr class="separator:a0778ce3d6875858bcd5f59b42f87ebff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">******
Layout
******

Node positioning algorithms for graph drawing.

For `random_layout()` the possible resulting shape
is a square of side [0, scale] (default: [0, 1])
Changing `center` shifts the layout by that amount.

For the other layout routines, the extent is
[center - scale, center + scale] (default: [-1, 1]).

Warning: Most layout routines have only been tested in 2-dimensions.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a333ec4bb45a6a3490bcd462b06ff025a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333ec4bb45a6a3490bcd462b06ff025a">&#9670;&nbsp;</a></span>bipartite_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.bipartite_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>align</em> = <code>&quot;vertical&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>aspect_ratio</em> = <code>4&#160;/&#160;3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes in two straight lines.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G.

nodes : list or container
    Nodes in one node set of the bipartite graph.
    This set will be placed on left or top.

align : string (default='vertical')
    The alignment of nodes. Vertical or horizontal.

scale : number (default: 1)
    Scale factor for positions.

center : array-like or None
    Coordinate pair around which to center the layout.

aspect_ratio : number (default=4/3):
    The ratio of the width to the height of the layout.

Returns
-------
pos : dict
    A dictionary of positions keyed by node.

Examples
--------
&gt;&gt;&gt; G = nx.bipartite.gnmk_random_graph(3, 5, 10, seed=123)
&gt;&gt;&gt; top = nx.bipartite.sets(G)[0]
&gt;&gt;&gt; pos = nx.bipartite_layout(G, top)

Notes
-----
This algorithm currently only works in two dimensions and does not
try to minimize edge crossings.</pre> 
</div>
</div>
<a id="ad5f2fac85819ae55ebd51de00e25bf75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f2fac85819ae55ebd51de00e25bf75">&#9670;&nbsp;</a></span>circular_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.circular_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes on a circle.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G.

scale : number (default: 1)
    Scale factor for positions.

center : array-like or None
    Coordinate pair around which to center the layout.

dim : int
    Dimension of layout.
    If dim&gt;2, the remaining dimensions are set to zero
    in the returned positions.
    If dim&lt;2, a ValueError is raised.

Returns
-------
pos : dict
    A dictionary of positions keyed by node

Raises
------
ValueError
    If dim &lt; 2

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; pos = nx.circular_layout(G)

Notes
-----
This algorithm currently only works in two dimensions and does not
try to minimize edge crossings.</pre> 
</div>
</div>
<a id="a6ab42bac0264130fda591b926dc36600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab42bac0264130fda591b926dc36600">&#9670;&nbsp;</a></span>kamada_kawai_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.kamada_kawai_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes using Kamada-Kawai path-length cost-function.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G.

dist : dict (default=None)
    A two-level dictionary of optimal distances between nodes,
    indexed by source and destination node.
    If None, the distance is computed using shortest_path_length().

pos : dict or None  optional (default=None)
    Initial positions for nodes as a dictionary with node as keys
    and values as a coordinate list or tuple.  If None, then use
    circular_layout() for dim &gt;= 2 and a linear layout for dim == 1.

weight : string or None   optional (default='weight')
    The edge attribute that holds the numerical value used for
    the edge weight.  If None, then all edge weights are 1.

scale : number (default: 1)
    Scale factor for positions.

center : array-like or None
    Coordinate pair around which to center the layout.

dim : int
    Dimension of layout.

Returns
-------
pos : dict
    A dictionary of positions keyed by node

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; pos = nx.kamada_kawai_layout(G)
</pre> 
</div>
</div>
<a id="a3d5aad61461478c634351e735fdb815b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5aad61461478c634351e735fdb815b">&#9670;&nbsp;</a></span>multipartite_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.multipartite_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subset_key</em> = <code>&quot;subset&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>align</em> = <code>&quot;vertical&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes in layers of straight lines.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G.

subset_key : string (default='subset')
    Key of node data to be used as layer subset.

align : string (default='vertical')
    The alignment of nodes. Vertical or horizontal.

scale : number (default: 1)
    Scale factor for positions.

center : array-like or None
    Coordinate pair around which to center the layout.

Returns
-------
pos : dict
    A dictionary of positions keyed by node.

Examples
--------
&gt;&gt;&gt; G = nx.complete_multipartite_graph(28, 16, 10)
&gt;&gt;&gt; pos = nx.multipartite_layout(G)

Notes
-----
This algorithm currently only works in two dimensions and does not
try to minimize edge crossings.

Network does not need to be a complete multipartite graph. As long as nodes
have subset_key data, they will be placed in the corresponding layers.</pre> 
</div>
</div>
<a id="aa9e8021cbef52e60e267eed205c99e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e8021cbef52e60e267eed205c99e1f">&#9670;&nbsp;</a></span>planar_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.planar_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes without edge intersections.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G. If G is of type
    nx.PlanarEmbedding, the positions are selected accordingly.

scale : number (default: 1)
    Scale factor for positions.

center : array-like or None
    Coordinate pair around which to center the layout.

dim : int
    Dimension of layout.

Returns
-------
pos : dict
    A dictionary of positions keyed by node

Raises
------
NetworkXException
    If G is not planar

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; pos = nx.planar_layout(G)
</pre> 
</div>
</div>
<a id="addafb2807d9e7cb9a5f464ce70bc2e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addafb2807d9e7cb9a5f464ce70bc2e1b">&#9670;&nbsp;</a></span>random_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.random_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes uniformly at random in the unit square.

For every node, a position is generated by choosing each of dim
coordinates uniformly at random on the interval [0.0, 1.0).

NumPy (http://scipy.org) is required for this function.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G.

center : array-like or None
    Coordinate pair around which to center the layout.

dim : int
    Dimension of layout.

seed : int, RandomState instance or None  optional (default=None)
    Set the random state for deterministic node layouts.
    If int, `seed` is the seed used by the random number generator,
    if numpy.random.RandomState instance, `seed` is the random
    number generator,
    if None, the random number generator is the RandomState instance used
    by numpy.random.

Returns
-------
pos : dict
    A dictionary of positions keyed by node

Examples
--------
&gt;&gt;&gt; G = nx.lollipop_graph(4, 3)
&gt;&gt;&gt; pos = nx.random_layout(G)</pre> 
</div>
</div>
<a id="af6ddcb7319b47ee6b98301e3a15be250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ddcb7319b47ee6b98301e3a15be250">&#9670;&nbsp;</a></span>rescale_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.rescale_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns scaled position array to (-scale, scale) in all axes.

The function acts on NumPy arrays which hold position information.
Each position is one row of the array. The dimension of the space
equals the number of columns. Each coordinate in one column.

To rescale, the mean (center) is subtracted from each axis separately.
Then all values are scaled so that the largest magnitude value
from all axes equals `scale` (thus, the aspect ratio is preserved).
The resulting NumPy Array is returned (order of rows unchanged).

Parameters
----------
pos : numpy array
    positions to be scaled. Each row is a position.

scale : number (default: 1)
    The size of the resulting extent in all directions.

Returns
-------
pos : numpy array
    scaled positions. Each row is a position.

See Also
--------
rescale_layout_dict
</pre> 
</div>
</div>
<a id="a9da50cbee09c4590ddb983e828ee5c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da50cbee09c4590ddb983e828ee5c91">&#9670;&nbsp;</a></span>rescale_layout_dict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.rescale_layout_dict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dictionary of scaled positions keyed by node

Parameters
----------
pos : A dictionary of positions keyed by node

scale : number (default: 1)
    The size of the resulting extent in all directions.

Returns
-------
pos : A dictionary of positions keyed by node

Examples
--------
&gt;&gt;&gt; pos = {0: (0, 0), 1: (1, 1), 2: (0.5, 0.5)}
&gt;&gt;&gt; nx.rescale_layout_dict(pos)
{0: (-1.0, -1.0), 1: (1.0, 1.0), 2: (0.0, 0.0)}

&gt;&gt;&gt; pos = {0: (0, 0), 1: (-1, 1), 2: (-0.5, 0.5)}
&gt;&gt;&gt; nx.rescale_layout_dict(pos, scale=2)
{0: (2.0, -2.0), 1: (-2.0, 2.0), 2: (0.0, 0.0)}

See Also
--------
rescale_layout
</pre> 
</div>
</div>
<a id="afda61265a93a6d2ff4f19c624723d387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda61265a93a6d2ff4f19c624723d387">&#9670;&nbsp;</a></span>shell_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.shell_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nlist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rotate</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes in concentric circles.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G.

nlist : list of lists
   List of node lists for each shell.

rotate : angle in radians (default=pi/len(nlist))
   Angle by which to rotate the starting position of each shell
   relative to the starting position of the previous shell.
   To recreate behavior before v2.5 use rotate=0.

scale : number (default: 1)
    Scale factor for positions.

center : array-like or None
    Coordinate pair around which to center the layout.

dim : int
    Dimension of layout, currently only dim=2 is supported.
    Other dimension values result in a ValueError.

Returns
-------
pos : dict
    A dictionary of positions keyed by node

Raises
------
ValueError
    If dim != 2

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; shells = [[0], [1, 2, 3]]
&gt;&gt;&gt; pos = nx.shell_layout(G, shells)

Notes
-----
This algorithm currently only works in two dimensions and does not
try to minimize edge crossings.</pre> 
</div>
</div>
<a id="ac947260649039048ed839ba8fcba2428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac947260649039048ed839ba8fcba2428">&#9670;&nbsp;</a></span>spectral_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.spectral_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes using the eigenvectors of the graph Laplacian.

Using the unnormalized Laplacian, the layout shows possible clusters of
nodes which are an approximation of the ratio cut. If dim is the number of
dimensions then the positions are the entries of the dim eigenvectors
corresponding to the ascending eigenvalues starting from the second one.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G.

weight : string or None   optional (default='weight')
    The edge attribute that holds the numerical value used for
    the edge weight.  If None, then all edge weights are 1.

scale : number (default: 1)
    Scale factor for positions.

center : array-like or None
    Coordinate pair around which to center the layout.

dim : int
    Dimension of layout.

Returns
-------
pos : dict
    A dictionary of positions keyed by node

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; pos = nx.spectral_layout(G)

Notes
-----
Directed graphs will be considered as undirected graphs when
positioning the nodes.

For larger graphs (&gt;500 nodes) this will use the SciPy sparse
eigenvalue solver (ARPACK).
</pre> 
</div>
</div>
<a id="a3594891dab725686c99df4708e7d01a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3594891dab725686c99df4708e7d01a7">&#9670;&nbsp;</a></span>spiral_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.spiral_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>0.35</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equidistant</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes in a spiral layout.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G.
scale : number (default: 1)
    Scale factor for positions.
center : array-like or None
    Coordinate pair around which to center the layout.
dim : int
    Dimension of layout, currently only dim=2 is supported.
    Other dimension values result in a ValueError.
resolution : float
    The compactness of the spiral layout returned.
    Lower values result in more compressed spiral layouts.
equidistant : bool
    If True, nodes will be plotted equidistant from each other.

Returns
-------
pos : dict
    A dictionary of positions keyed by node

Raises
------
ValueError
    If dim != 2

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; pos = nx.spiral_layout(G)

Notes
-----
This algorithm currently only works in two dimensions.</pre> 
</div>
</div>
<a id="a49950bbfa7bf1c305bc9e049459ab7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49950bbfa7bf1c305bc9e049459ab7b9">&#9670;&nbsp;</a></span>spring_layout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.drawing.layout.spring_layout </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fixed</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterations</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>center</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Position nodes using Fruchterman-Reingold force-directed algorithm.

The algorithm simulates a force-directed representation of the network
treating edges as springs holding nodes close, while treating nodes
as repelling objects, sometimes called an anti-gravity force.
Simulation continues until the positions are close to an equilibrium.

There are some hard-coded values: minimal distance between
nodes (0.01) and "temperature" of 0.1 to ensure nodes don't fly away.
During the simulation, `k` helps determine the distance between nodes,
though `scale` and `center` determine the size and place after
rescaling occurs at the end of the simulation.

Fixing some nodes doesn't allow them to move in the simulation.
It also turns off the rescaling feature at the simulation's end.
In addition, setting `scale` to `None` turns off rescaling.

Parameters
----------
G : NetworkX graph or list of nodes
    A position will be assigned to every node in G.

k : float (default=None)
    Optimal distance between nodes.  If None the distance is set to
    1/sqrt(n) where n is the number of nodes.  Increase this value
    to move nodes farther apart.

pos : dict or None  optional (default=None)
    Initial positions for nodes as a dictionary with node as keys
    and values as a coordinate list or tuple.  If None, then use
    random initial positions.

fixed : list or None  optional (default=None)
    Nodes to keep fixed at initial position.
    Nodes not in ``G.nodes`` are ignored.
    ValueError raised if `fixed` specified and `pos` not.

iterations : int  optional (default=50)
    Maximum number of iterations taken

threshold: float optional (default = 1e-4)
    Threshold for relative error in node position changes.
    The iteration stops if the error is below this threshold.

weight : string or None   optional (default='weight')
    The edge attribute that holds the numerical value used for
    the edge weight.  Larger means a stronger attractive force.
    If None, then all edge weights are 1.

scale : number or None (default: 1)
    Scale factor for positions. Not used unless `fixed is None`.
    If scale is None, no rescaling is performed.

center : array-like or None
    Coordinate pair around which to center the layout.
    Not used unless `fixed is None`.

dim : int
    Dimension of layout.

seed : int, RandomState instance or None  optional (default=None)
    Set the random state for deterministic node layouts.
    If int, `seed` is the seed used by the random number generator,
    if numpy.random.RandomState instance, `seed` is the random
    number generator,
    if None, the random number generator is the RandomState instance used
    by numpy.random.

Returns
-------
pos : dict
    A dictionary of positions keyed by node

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; pos = nx.spring_layout(G)

# The same using longer but equivalent function name
&gt;&gt;&gt; pos = nx.fruchterman_reingold_layout(G)
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a0778ce3d6875858bcd5f59b42f87ebff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0778ce3d6875858bcd5f59b42f87ebff">&#9670;&nbsp;</a></span>fruchterman_reingold_layout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">networkx.drawing.layout.fruchterman_reingold_layout</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
