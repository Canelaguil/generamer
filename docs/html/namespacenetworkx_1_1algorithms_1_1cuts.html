<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.cuts Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cuts.html">cuts</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.cuts Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3eab74cd6337e44432d794a0761b6440"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cuts.html#a3eab74cd6337e44432d794a0761b6440">cut_size</a> (G, S, T=None, weight=None)</td></tr>
<tr class="separator:a3eab74cd6337e44432d794a0761b6440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba099ec7dcd9a10ba04202443c4453f9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cuts.html#aba099ec7dcd9a10ba04202443c4453f9">volume</a> (G, S, weight=None)</td></tr>
<tr class="separator:aba099ec7dcd9a10ba04202443c4453f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7092b90008f99838b113597d801b9e9a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cuts.html#a7092b90008f99838b113597d801b9e9a">normalized_cut_size</a> (G, S, T=None, weight=None)</td></tr>
<tr class="separator:a7092b90008f99838b113597d801b9e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f7d141bb0ecb21b2da6f642484b84a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cuts.html#a96f7d141bb0ecb21b2da6f642484b84a">conductance</a> (G, S, T=None, weight=None)</td></tr>
<tr class="separator:a96f7d141bb0ecb21b2da6f642484b84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90454cac45ff9549676b947df4aece8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cuts.html#ac90454cac45ff9549676b947df4aece8">edge_expansion</a> (G, S, T=None, weight=None)</td></tr>
<tr class="separator:ac90454cac45ff9549676b947df4aece8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d523ba28c915b7f58652949d782d03"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cuts.html#ad6d523ba28c915b7f58652949d782d03">mixing_expansion</a> (G, S, T=None, weight=None)</td></tr>
<tr class="separator:ad6d523ba28c915b7f58652949d782d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baf73cd3e4ac469e4e401b321c33dcc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cuts.html#a0baf73cd3e4ac469e4e401b321c33dcc">node_expansion</a> (G, S)</td></tr>
<tr class="separator:a0baf73cd3e4ac469e4e401b321c33dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f634e722bca2e85bc85ffa9124688f1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1cuts.html#a6f634e722bca2e85bc85ffa9124688f1">boundary_expansion</a> (G, S)</td></tr>
<tr class="separator:a6f634e722bca2e85bc85ffa9124688f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions for finding and evaluating cuts in a graph.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a6f634e722bca2e85bc85ffa9124688f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f634e722bca2e85bc85ffa9124688f1">&#9670;&nbsp;</a></span>boundary_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cuts.boundary_expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the boundary expansion of the set `S`.

The *boundary expansion* is the quotient of the size
of the node boundary and the cardinality of *S*. [1]

Parameters
----------
G : NetworkX graph

S : collection
    A collection of nodes in `G`.

Returns
-------
number
    The boundary expansion of the set `S`.

See also
--------
edge_expansion
mixing_expansion
node_expansion

References
----------
.. [1] Vadhan, Salil P.
       "Pseudorandomness."
       *Foundations and Trends in Theoretical Computer Science*
       7.1–3 (2011): 1–336.
       &lt;https://doi.org/10.1561/0400000010&gt;</pre> 
</div>
</div>
<a id="a96f7d141bb0ecb21b2da6f642484b84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f7d141bb0ecb21b2da6f642484b84a">&#9670;&nbsp;</a></span>conductance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cuts.conductance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the conductance of two sets of nodes.

The *conductance* is the quotient of the cut size and the smaller of
the volumes of the two sets. [1]

Parameters
----------
G : NetworkX graph

S : collection
    A collection of nodes in `G`.

T : collection
    A collection of nodes in `G`.

weight : object
    Edge attribute key to use as weight. If not specified, edges
    have weight one.

Returns
-------
number
    The conductance between the two sets `S` and `T`.

See also
--------
cut_size
edge_expansion
normalized_cut_size
volume

References
----------
.. [1] David Gleich.
       *Hierarchical Directed Spectral Graph Partitioning*.
       &lt;https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf&gt;</pre> 
</div>
</div>
<a id="a3eab74cd6337e44432d794a0761b6440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eab74cd6337e44432d794a0761b6440">&#9670;&nbsp;</a></span>cut_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cuts.cut_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the size of the cut between two sets of nodes.

A *cut* is a partition of the nodes of a graph into two sets. The
*cut size* is the sum of the weights of the edges "between" the two
sets of nodes.

Parameters
----------
G : NetworkX graph

S : collection
    A collection of nodes in `G`.

T : collection
    A collection of nodes in `G`. If not specified, this is taken to
    be the set complement of `S`.

weight : object
    Edge attribute key to use as weight. If not specified, edges
    have weight one.

Returns
-------
number
    Total weight of all edges from nodes in set `S` to nodes in
    set `T` (and, in the case of directed graphs, all edges from
    nodes in `T` to nodes in `S`).

Examples
--------
In the graph with two cliques joined by a single edges, the natural
bipartition of the graph into two blocks, one for each clique,
yields a cut of weight one::

    &gt;&gt;&gt; G = nx.barbell_graph(3, 0)
    &gt;&gt;&gt; S = {0, 1, 2}
    &gt;&gt;&gt; T = {3, 4, 5}
    &gt;&gt;&gt; nx.cut_size(G, S, T)
    1

Each parallel edge in a multigraph is counted when determining the
cut size::

    &gt;&gt;&gt; G = nx.MultiGraph(["ab", "ab"])
    &gt;&gt;&gt; S = {"a"}
    &gt;&gt;&gt; T = {"b"}
    &gt;&gt;&gt; nx.cut_size(G, S, T)
    2

Notes
-----
In a multigraph, the cut size is the total weight of edges including
multiplicity.</pre> 
</div>
</div>
<a id="ac90454cac45ff9549676b947df4aece8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90454cac45ff9549676b947df4aece8">&#9670;&nbsp;</a></span>edge_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cuts.edge_expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the edge expansion between two node sets.

The *edge expansion* is the quotient of the cut size and the smaller
of the cardinalities of the two sets. [1]

Parameters
----------
G : NetworkX graph

S : collection
    A collection of nodes in `G`.

T : collection
    A collection of nodes in `G`.

weight : object
    Edge attribute key to use as weight. If not specified, edges
    have weight one.

Returns
-------
number
    The edge expansion between the two sets `S` and `T`.

See also
--------
boundary_expansion
mixing_expansion
node_expansion

References
----------
.. [1] Fan Chung.
       *Spectral Graph Theory*.
       (CBMS Regional Conference Series in Mathematics, No. 92),
       American Mathematical Society, 1997, ISBN 0-8218-0315-8
       &lt;http://www.math.ucsd.edu/~fan/research/revised.html&gt;</pre> 
</div>
</div>
<a id="ad6d523ba28c915b7f58652949d782d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d523ba28c915b7f58652949d782d03">&#9670;&nbsp;</a></span>mixing_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cuts.mixing_expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the mixing expansion between two node sets.

The *mixing expansion* is the quotient of the cut size and twice the
number of edges in the graph. [1]

Parameters
----------
G : NetworkX graph

S : collection
    A collection of nodes in `G`.

T : collection
    A collection of nodes in `G`.

weight : object
    Edge attribute key to use as weight. If not specified, edges
    have weight one.

Returns
-------
number
    The mixing expansion between the two sets `S` and `T`.

See also
--------
boundary_expansion
edge_expansion
node_expansion

References
----------
.. [1] Vadhan, Salil P.
       "Pseudorandomness."
       *Foundations and Trends
       in Theoretical Computer Science* 7.1–3 (2011): 1–336.
       &lt;https://doi.org/10.1561/0400000010&gt;</pre> 
</div>
</div>
<a id="a0baf73cd3e4ac469e4e401b321c33dcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0baf73cd3e4ac469e4e401b321c33dcc">&#9670;&nbsp;</a></span>node_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cuts.node_expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the node expansion of the set `S`.

The *node expansion* is the quotient of the size of the node
boundary of *S* and the cardinality of *S*. [1]

Parameters
----------
G : NetworkX graph

S : collection
    A collection of nodes in `G`.

Returns
-------
number
    The node expansion of the set `S`.

See also
--------
boundary_expansion
edge_expansion
mixing_expansion

References
----------
.. [1] Vadhan, Salil P.
       "Pseudorandomness."
       *Foundations and Trends
       in Theoretical Computer Science* 7.1–3 (2011): 1–336.
       &lt;https://doi.org/10.1561/0400000010&gt;</pre> 
</div>
</div>
<a id="a7092b90008f99838b113597d801b9e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7092b90008f99838b113597d801b9e9a">&#9670;&nbsp;</a></span>normalized_cut_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cuts.normalized_cut_size </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the normalized size of the cut between two sets of nodes.

The *normalized cut size* is the cut size times the sum of the
reciprocal sizes of the volumes of the two sets. [1]

Parameters
----------
G : NetworkX graph

S : collection
    A collection of nodes in `G`.

T : collection
    A collection of nodes in `G`.

weight : object
    Edge attribute key to use as weight. If not specified, edges
    have weight one.

Returns
-------
number
    The normalized cut size between the two sets `S` and `T`.

Notes
-----
In a multigraph, the cut size is the total weight of edges including
multiplicity.

See also
--------
conductance
cut_size
edge_expansion
volume

References
----------
.. [1] David Gleich.
       *Hierarchical Directed Spectral Graph Partitioning*.
       &lt;https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf&gt;</pre> 
</div>
</div>
<a id="aba099ec7dcd9a10ba04202443c4453f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba099ec7dcd9a10ba04202443c4453f9">&#9670;&nbsp;</a></span>volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.cuts.volume </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the volume of a set of nodes.

The *volume* of a set *S* is the sum of the (out-)degrees of nodes
in *S* (taking into account parallel edges in multigraphs). [1]

Parameters
----------
G : NetworkX graph

S : collection
    A collection of nodes in `G`.

weight : object
    Edge attribute key to use as weight. If not specified, edges
    have weight one.

Returns
-------
number
    The volume of the set of nodes represented by `S` in the graph
    `G`.

See also
--------
conductance
cut_size
edge_expansion
edge_boundary
normalized_cut_size

References
----------
.. [1] David Gleich.
       *Hierarchical Directed Spectral Graph Partitioning*.
       &lt;https://www.cs.purdue.edu/homes/dgleich/publications/Gleich%202005%20-%20hierarchical%20directed%20spectral.pdf&gt;</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
