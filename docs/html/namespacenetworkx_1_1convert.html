<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.convert Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1convert.html">convert</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.convert Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7849c4fa2154667a89fff76a6109e3cd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1convert.html#a7849c4fa2154667a89fff76a6109e3cd">to_networkx_graph</a> (data, create_using=None, multigraph_input=False)</td></tr>
<tr class="separator:a7849c4fa2154667a89fff76a6109e3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0bae8a707df0fe064309f8d481b695f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1convert.html#ac0bae8a707df0fe064309f8d481b695f">to_dict_of_lists</a> (G, nodelist=None)</td></tr>
<tr class="separator:ac0bae8a707df0fe064309f8d481b695f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8787aba5fcf3417c6602bb7205bce4f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1convert.html#aa8787aba5fcf3417c6602bb7205bce4f">from_dict_of_lists</a> (d, create_using=None)</td></tr>
<tr class="separator:aa8787aba5fcf3417c6602bb7205bce4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716491bc042d88d9668279ceb4a39900"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1convert.html#a716491bc042d88d9668279ceb4a39900">to_dict_of_dicts</a> (G, nodelist=None, edge_data=None)</td></tr>
<tr class="separator:a716491bc042d88d9668279ceb4a39900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb3971dd768e641b3395e6d245e2cc3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1convert.html#a4cb3971dd768e641b3395e6d245e2cc3">from_dict_of_dicts</a> (d, create_using=None, multigraph_input=False)</td></tr>
<tr class="separator:a4cb3971dd768e641b3395e6d245e2cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68ff44e5c1e4c03bd615d59c482ce17"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1convert.html#ae68ff44e5c1e4c03bd615d59c482ce17">to_edgelist</a> (G, nodelist=None)</td></tr>
<tr class="separator:ae68ff44e5c1e4c03bd615d59c482ce17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef2c9ebd23b8d1e5dabcce719bc9d18"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1convert.html#a7ef2c9ebd23b8d1e5dabcce719bc9d18">from_edgelist</a> (edgelist, create_using=None)</td></tr>
<tr class="separator:a7ef2c9ebd23b8d1e5dabcce719bc9d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions to convert NetworkX graphs to and from other formats.

The preferred way of converting data to a NetworkX graph is through the
graph constructor.  The constructor calls the to_networkx_graph() function
which attempts to guess the input type and convert it automatically.

Examples
--------
Create a graph with a single edge from a dictionary of dictionaries

&gt;&gt;&gt; d = {0: {1: 1}}  # dict-of-dicts single edge (0,1)
&gt;&gt;&gt; G = nx.Graph(d)

See Also
--------
nx_agraph, nx_pydot
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a4cb3971dd768e641b3395e6d245e2cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb3971dd768e641b3395e6d245e2cc3">&#9670;&nbsp;</a></span>from_dict_of_dicts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.convert.from_dict_of_dicts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multigraph_input</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a graph from a dictionary of dictionaries.

Parameters
----------
d : dictionary of dictionaries
  A dictionary of dictionaries adjacency representation.

create_using : NetworkX graph constructor, optional (default=nx.Graph)
    Graph type to create. If graph instance, then cleared before populated.

multigraph_input : bool (default False)
   When True, the dict `d` is assumed
   to be a dict-of-dict-of-dict-of-dict structure keyed by
   node to neighbor to edge keys to edge data for multi-edges.
   Otherwise this routine assumes dict-of-dict-of-dict keyed by
   node to neighbor to edge data.

Examples
--------
&gt;&gt;&gt; dod = {0: {1: {"weight": 1}}}  # single edge (0,1)
&gt;&gt;&gt; G = nx.from_dict_of_dicts(dod)

or

&gt;&gt;&gt; G = nx.Graph(dod)  # use Graph constructor</pre> 
</div>
</div>
<a id="aa8787aba5fcf3417c6602bb7205bce4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8787aba5fcf3417c6602bb7205bce4f">&#9670;&nbsp;</a></span>from_dict_of_lists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.convert.from_dict_of_lists </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a graph from a dictionary of lists.

Parameters
----------
d : dictionary of lists
  A dictionary of lists adjacency representation.

create_using : NetworkX graph constructor, optional (default=nx.Graph)
    Graph type to create. If graph instance, then cleared before populated.

Examples
--------
&gt;&gt;&gt; dol = {0: [1]}  # single edge (0,1)
&gt;&gt;&gt; G = nx.from_dict_of_lists(dol)

or

&gt;&gt;&gt; G = nx.Graph(dol)  # use Graph constructor</pre> 
</div>
</div>
<a id="a7ef2c9ebd23b8d1e5dabcce719bc9d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef2c9ebd23b8d1e5dabcce719bc9d18">&#9670;&nbsp;</a></span>from_edgelist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.convert.from_edgelist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edgelist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a graph from a list of edges.

Parameters
----------
edgelist : list or iterator
  Edge tuples

create_using : NetworkX graph constructor, optional (default=nx.Graph)
    Graph type to create. If graph instance, then cleared before populated.

Examples
--------
&gt;&gt;&gt; edgelist = [(0, 1)]  # single edge (0,1)
&gt;&gt;&gt; G = nx.from_edgelist(edgelist)

or

&gt;&gt;&gt; G = nx.Graph(edgelist)  # use Graph constructor</pre> 
</div>
</div>
<a id="a716491bc042d88d9668279ceb4a39900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716491bc042d88d9668279ceb4a39900">&#9670;&nbsp;</a></span>to_dict_of_dicts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.convert.to_dict_of_dicts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodelist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_data</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns adjacency representation of graph as a dictionary of dictionaries.

Parameters
----------
G : graph
   A NetworkX graph

nodelist : list
   Use only nodes specified in nodelist

edge_data : scalar, optional
   If provided, the value of the dictionary will be set to `edge_data` for
   all edges. Usual values could be `1` or `True`. If `edge_data` is
   `None` (the default), the edgedata in `G` is used, resulting in a
   dict-of-dict-of-dicts. If `G` is a MultiGraph, the result will be a
   dict-of-dict-of-dict-of-dicts. See Notes for an approach to customize
   handling edge data. `edge_data` should *not* be a container.

Returns
-------
dod : dict
   A nested dictionary representation of `G`. Note that the level of
   nesting depends on the type of `G` and the value of `edge_data`
   (see Examples).

See Also
--------
from_dict_of_dicts, to_dict_of_lists

Notes
-----
For a more custom approach to handling edge data, try::

    dod = {
        n: {
            nbr: custom(n, nbr, dd) for nbr, dd in nbrdict.items()
        }
        for n, nbrdict in G.adj.items()
    }

where `custom` returns the desired edge data for each edge between `n` and
`nbr`, given existing edge data `dd`.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(3)
&gt;&gt;&gt; nx.to_dict_of_dicts(G)
{0: {1: {}}, 1: {0: {}, 2: {}}, 2: {1: {}}}

Edge data is preserved by default (``edge_data=None``), resulting
in dict-of-dict-of-dicts where the innermost dictionary contains the
edge data:

&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; G.add_edges_from(
...     [
...         (0, 1, {'weight': 1.0}),
...         (1, 2, {'weight': 2.0}),
...         (2, 0, {'weight': 1.0}),
...     ]
... )
&gt;&gt;&gt; d = nx.to_dict_of_dicts(G)
&gt;&gt;&gt; d  # doctest: +SKIP
{0: {1: {'weight': 1.0}, 2: {'weight': 1.0}},
 1: {0: {'weight': 1.0}, 2: {'weight': 2.0}},
 2: {1: {'weight': 2.0}, 0: {'weight': 1.0}}}
&gt;&gt;&gt; d[1][2]['weight']
2.0

If `edge_data` is not `None`, edge data in the original graph (if any) is
replaced:

&gt;&gt;&gt; d = nx.to_dict_of_dicts(G, edge_data=1)
&gt;&gt;&gt; d
{0: {1: 1, 2: 1}, 1: {0: 1, 2: 1}, 2: {1: 1, 0: 1}}
&gt;&gt;&gt; d[1][2]
1

This also applies to MultiGraphs: edge data is preserved by default:

&gt;&gt;&gt; G = nx.MultiGraph()
&gt;&gt;&gt; G.add_edge(0, 1, key='a', weight=1.0)
'a'
&gt;&gt;&gt; G.add_edge(0, 1, key='b', weight=5.0)
'b'
&gt;&gt;&gt; d = nx.to_dict_of_dicts(G)
&gt;&gt;&gt; d  # doctest: +SKIP
{0: {1: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}},
 1: {0: {'a': {'weight': 1.0}, 'b': {'weight': 5.0}}}}
&gt;&gt;&gt; d[0][1]['b']['weight']
5.0

But multi edge data is lost if `edge_data` is not `None`:

&gt;&gt;&gt; d = nx.to_dict_of_dicts(G, edge_data=10)
&gt;&gt;&gt; d
{0: {1: 10}, 1: {0: 10}}
</pre> 
</div>
</div>
<a id="ac0bae8a707df0fe064309f8d481b695f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0bae8a707df0fe064309f8d481b695f">&#9670;&nbsp;</a></span>to_dict_of_lists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.convert.to_dict_of_lists </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodelist</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns adjacency representation of graph as a dictionary of lists.

Parameters
----------
G : graph
   A NetworkX graph

nodelist : list
   Use only nodes specified in nodelist

Notes
-----
Completely ignores edge data for MultiGraph and MultiDiGraph.</pre> 
</div>
</div>
<a id="ae68ff44e5c1e4c03bd615d59c482ce17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68ff44e5c1e4c03bd615d59c482ce17">&#9670;&nbsp;</a></span>to_edgelist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.convert.to_edgelist </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodelist</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of edges in the graph.

Parameters
----------
G : graph
   A NetworkX graph

nodelist : list
   Use only nodes specified in nodelist</pre> 
</div>
</div>
<a id="a7849c4fa2154667a89fff76a6109e3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7849c4fa2154667a89fff76a6109e3cd">&#9670;&nbsp;</a></span>to_networkx_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.convert.to_networkx_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>multigraph_input</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a NetworkX graph from a known data structure.

The preferred way to call this is automatically
from the class constructor

&gt;&gt;&gt; d = {0: {1: {"weight": 1}}}  # dict-of-dicts single edge (0,1)
&gt;&gt;&gt; G = nx.Graph(d)

instead of the equivalent

&gt;&gt;&gt; G = nx.from_dict_of_dicts(d)

Parameters
----------
data : object to be converted

    Current known types are:
     any NetworkX graph
     dict-of-dicts
     dict-of-lists
     container (e.g. set, list, tuple) of edges
     iterator (e.g. itertools.chain) that produces edges
     generator of edges
     Pandas DataFrame (row per edge)
     numpy matrix
     numpy ndarray
     scipy sparse matrix
     pygraphviz agraph

create_using : NetworkX graph constructor, optional (default=nx.Graph)
    Graph type to create. If graph instance, then cleared before populated.

multigraph_input : bool (default False)
    If True and  data is a dict_of_dicts,
    try to create a multigraph assuming dict_of_dict_of_lists.
    If data and create_using are both multigraphs then create
    a multigraph from a multigraph.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
