<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.clique Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html">clique</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.clique Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1clique_1_1MaxWeightClique.html">MaxWeightClique</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5afae1d234e0fde85e9fbe4722f4b786"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#a5afae1d234e0fde85e9fbe4722f4b786">enumerate_all_cliques</a> (G)</td></tr>
<tr class="separator:a5afae1d234e0fde85e9fbe4722f4b786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5f7c53376e84c56ea967a673b8c6bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#a9e5f7c53376e84c56ea967a673b8c6bc">find_cliques</a> (G)</td></tr>
<tr class="separator:a9e5f7c53376e84c56ea967a673b8c6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae8791cb3fbabc4195e5e1bf11b66c3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#a0ae8791cb3fbabc4195e5e1bf11b66c3">find_cliques_recursive</a> (G)</td></tr>
<tr class="separator:a0ae8791cb3fbabc4195e5e1bf11b66c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9c1881d34c45c7cfcae3ad3e2f14b2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#aac9c1881d34c45c7cfcae3ad3e2f14b2">make_max_clique_graph</a> (G, create_using=None)</td></tr>
<tr class="separator:aac9c1881d34c45c7cfcae3ad3e2f14b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866d9770533ac4a124b03e7c8adfc3d1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#a866d9770533ac4a124b03e7c8adfc3d1">make_clique_bipartite</a> (G, fpos=None, create_using=None, name=None)</td></tr>
<tr class="separator:a866d9770533ac4a124b03e7c8adfc3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ffd48517246617d89714f137b9c04a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#a15ffd48517246617d89714f137b9c04a">graph_clique_number</a> (G, cliques=None)</td></tr>
<tr class="separator:a15ffd48517246617d89714f137b9c04a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e77cc301d15b809def1d0f35945a380"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#a9e77cc301d15b809def1d0f35945a380">graph_number_of_cliques</a> (G, cliques=None)</td></tr>
<tr class="separator:a9e77cc301d15b809def1d0f35945a380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b5c17115637c1f7c9a319b1f08c6af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#ae7b5c17115637c1f7c9a319b1f08c6af">node_clique_number</a> (G, nodes=None, cliques=None)</td></tr>
<tr class="separator:ae7b5c17115637c1f7c9a319b1f08c6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715dddf1461fea94accb43717f4e7fb6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#a715dddf1461fea94accb43717f4e7fb6">number_of_cliques</a> (G, nodes=None, cliques=None)</td></tr>
<tr class="separator:a715dddf1461fea94accb43717f4e7fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b1d135f2e0c7acc72c11fef57055a28"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#a2b1d135f2e0c7acc72c11fef57055a28">cliques_containing_node</a> (G, nodes=None, cliques=None)</td></tr>
<tr class="separator:a2b1d135f2e0c7acc72c11fef57055a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19437be8e85651bb15f27f39d9f88755"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1clique.html#a19437be8e85651bb15f27f39d9f88755">max_weight_clique</a> (G, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a19437be8e85651bb15f27f39d9f88755"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions for finding and manipulating cliques.

Finding the largest clique in a graph is NP-complete problem, so most of
these algorithms have an exponential running time; for more information,
see the Wikipedia article on the clique problem [1]_.

.. [1] clique problem:: https://en.wikipedia.org/wiki/Clique_problem</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a2b1d135f2e0c7acc72c11fef57055a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b1d135f2e0c7acc72c11fef57055a28">&#9670;&nbsp;</a></span>cliques_containing_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.cliques_containing_node </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cliques</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of cliques containing the given node.

Returns a single list or list of lists depending on input nodes.
Optional list of cliques can be input if already computed.
</pre> 
</div>
</div>
<a id="a5afae1d234e0fde85e9fbe4722f4b786"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5afae1d234e0fde85e9fbe4722f4b786">&#9670;&nbsp;</a></span>enumerate_all_cliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.enumerate_all_cliques </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns all cliques in an undirected graph.

This function returns an iterator over cliques, each of which is a
list of nodes. The iteration is ordered by cardinality of the
cliques: first all cliques of size one, then all cliques of size
two, etc.

Parameters
----------
G : NetworkX graph
    An undirected graph.

Returns
-------
iterator
    An iterator over cliques, each of which is a list of nodes in
    `G`. The cliques are ordered according to size.

Notes
-----
To obtain a list of all cliques, use
`list(enumerate_all_cliques(G))`. However, be aware that in the
worst-case, the length of this list can be exponential in the number
of nodes in the graph (for example, when the graph is the complete
graph). This function avoids storing all cliques in memory by only
keeping current candidate node lists in memory during its search.

The implementation is adapted from the algorithm by Zhang, et
al. (2005) [1]_ to output all cliques discovered.

This algorithm ignores self-loops and parallel edges, since cliques
are not conventionally defined with such edges.

References
----------
.. [1] Yun Zhang, Abu-Khzam, F.N., Baldwin, N.E., Chesler, E.J.,
       Langston, M.A., Samatova, N.F.,
       "Genome-Scale Computational Approaches to Memory-Intensive
       Applications in Systems Biology".
       *Supercomputing*, 2005. Proceedings of the ACM/IEEE SC 2005
       Conference, pp. 12, 12--18 Nov. 2005.
       &lt;https://doi.org/10.1109/SC.2005.29&gt;.</pre> 
</div>
</div>
<a id="a9e5f7c53376e84c56ea967a673b8c6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5f7c53376e84c56ea967a673b8c6bc">&#9670;&nbsp;</a></span>find_cliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.find_cliques </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns all maximal cliques in an undirected graph.

For each node *v*, a *maximal clique for v* is a largest complete
subgraph containing *v*. The largest maximal clique is sometimes
called the *maximum clique*.

This function returns an iterator over cliques, each of which is a
list of nodes. It is an iterative implementation, so should not
suffer from recursion depth issues.

Parameters
----------
G : NetworkX graph
    An undirected graph.

Returns
-------
iterator
    An iterator over maximal cliques, each of which is a list of
    nodes in `G`. The order of cliques is arbitrary.

See Also
--------
find_cliques_recursive
    A recursive version of the same algorithm.

Notes
-----
To obtain a list of all maximal cliques, use
`list(find_cliques(G))`. However, be aware that in the worst-case,
the length of this list can be exponential in the number of nodes in
the graph. This function avoids storing all cliques in memory by
only keeping current candidate node lists in memory during its search.

This implementation is based on the algorithm published by Bron and
Kerbosch (1973) [1]_, as adapted by Tomita, Tanaka and Takahashi
(2006) [2]_ and discussed in Cazals and Karande (2008) [3]_. It
essentially unrolls the recursion used in the references to avoid
issues of recursion stack depth (for a recursive implementation, see
:func:`find_cliques_recursive`).

This algorithm ignores self-loops and parallel edges, since cliques
are not conventionally defined with such edges.

References
----------
.. [1] Bron, C. and Kerbosch, J.
   "Algorithm 457: finding all cliques of an undirected graph".
   *Communications of the ACM* 16, 9 (Sep. 1973), 575--577.
   &lt;http://portal.acm.org/citation.cfm?doid=362342.362367&gt;

.. [2] Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,
   "The worst-case time complexity for generating all maximal
   cliques and computational experiments",
   *Theoretical Computer Science*, Volume 363, Issue 1,
   Computing and Combinatorics,
   10th Annual International Conference on
   Computing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28--42
   &lt;https://doi.org/10.1016/j.tcs.2006.06.015&gt;

.. [3] F. Cazals, C. Karande,
   "A note on the problem of reporting maximal cliques",
   *Theoretical Computer Science*,
   Volume 407, Issues 1--3, 6 November 2008, Pages 564--568,
   &lt;https://doi.org/10.1016/j.tcs.2008.05.010&gt;</pre> 
</div>
</div>
<a id="a0ae8791cb3fbabc4195e5e1bf11b66c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ae8791cb3fbabc4195e5e1bf11b66c3">&#9670;&nbsp;</a></span>find_cliques_recursive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.find_cliques_recursive </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns all maximal cliques in a graph.

For each node *v*, a *maximal clique for v* is a largest complete
subgraph containing *v*. The largest maximal clique is sometimes
called the *maximum clique*.

This function returns an iterator over cliques, each of which is a
list of nodes. It is a recursive implementation, so may suffer from
recursion depth issues.

Parameters
----------
G : NetworkX graph

Returns
-------
iterator
    An iterator over maximal cliques, each of which is a list of
    nodes in `G`. The order of cliques is arbitrary.

See Also
--------
find_cliques
    An iterative version of the same algorithm.

Notes
-----
To obtain a list of all maximal cliques, use
`list(find_cliques_recursive(G))`. However, be aware that in the
worst-case, the length of this list can be exponential in the number
of nodes in the graph. This function avoids storing all cliques in memory
by only keeping current candidate node lists in memory during its search.

This implementation is based on the algorithm published by Bron and
Kerbosch (1973) [1]_, as adapted by Tomita, Tanaka and Takahashi
(2006) [2]_ and discussed in Cazals and Karande (2008) [3]_. For a
non-recursive implementation, see :func:`find_cliques`.

This algorithm ignores self-loops and parallel edges, since cliques
are not conventionally defined with such edges.

References
----------
.. [1] Bron, C. and Kerbosch, J.
   "Algorithm 457: finding all cliques of an undirected graph".
   *Communications of the ACM* 16, 9 (Sep. 1973), 575--577.
   &lt;http://portal.acm.org/citation.cfm?doid=362342.362367&gt;

.. [2] Etsuji Tomita, Akira Tanaka, Haruhisa Takahashi,
   "The worst-case time complexity for generating all maximal
   cliques and computational experiments",
   *Theoretical Computer Science*, Volume 363, Issue 1,
   Computing and Combinatorics,
   10th Annual International Conference on
   Computing and Combinatorics (COCOON 2004), 25 October 2006, Pages 28--42
   &lt;https://doi.org/10.1016/j.tcs.2006.06.015&gt;

.. [3] F. Cazals, C. Karande,
   "A note on the problem of reporting maximal cliques",
   *Theoretical Computer Science*,
   Volume 407, Issues 1--3, 6 November 2008, Pages 564--568,
   &lt;https://doi.org/10.1016/j.tcs.2008.05.010&gt;</pre> 
</div>
</div>
<a id="a15ffd48517246617d89714f137b9c04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ffd48517246617d89714f137b9c04a">&#9670;&nbsp;</a></span>graph_clique_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.graph_clique_number </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cliques</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the clique number of the graph.

The *clique number* of a graph is the size of the largest clique in
the graph.

Parameters
----------
G : NetworkX graph
    An undirected graph.

cliques : list
    A list of cliques, each of which is itself a list of nodes. If
    not specified, the list of all cliques will be computed, as by
    :func:`find_cliques`.

Returns
-------
int
    The size of the largest clique in `G`.

Notes
-----
You should provide `cliques` if you have already computed the list
of maximal cliques, in order to avoid an exponential time search for
maximal cliques.</pre> 
</div>
</div>
<a id="a9e77cc301d15b809def1d0f35945a380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e77cc301d15b809def1d0f35945a380">&#9670;&nbsp;</a></span>graph_number_of_cliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.graph_number_of_cliques </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cliques</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of maximal cliques in the graph.

Parameters
----------
G : NetworkX graph
    An undirected graph.

cliques : list
    A list of cliques, each of which is itself a list of nodes. If
    not specified, the list of all cliques will be computed, as by
    :func:`find_cliques`.

Returns
-------
int
    The number of maximal cliques in `G`.

Notes
-----
You should provide `cliques` if you have already computed the list
of maximal cliques, in order to avoid an exponential time search for
maximal cliques.</pre> 
</div>
</div>
<a id="a866d9770533ac4a124b03e7c8adfc3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866d9770533ac4a124b03e7c8adfc3d1">&#9670;&nbsp;</a></span>make_clique_bipartite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.make_clique_bipartite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fpos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the bipartite clique graph corresponding to `G`.

In the returned bipartite graph, the "bottom" nodes are the nodes of
`G` and the "top" nodes represent the maximal cliques of `G`.
There is an edge from node *v* to clique *C* in the returned graph
if and only if *v* is an element of *C*.

Parameters
----------
G : NetworkX graph
    An undirected graph.

fpos : bool
    If True or not None, the returned graph will have an
    additional attribute, `pos`, a dictionary mapping node to
    position in the Euclidean plane.

create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Returns
-------
NetworkX graph
    A bipartite graph whose "bottom" set is the nodes of the graph
    `G`, whose "top" set is the cliques of `G`, and whose edges
    join nodes of `G` to the cliques that contain them.

    The nodes of the graph `G` have the node attribute
    'bipartite' set to 1 and the nodes representing cliques
    have the node attribute 'bipartite' set to 0, as is the
    convention for bipartite graphs in NetworkX.</pre> 
</div>
</div>
<a id="aac9c1881d34c45c7cfcae3ad3e2f14b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9c1881d34c45c7cfcae3ad3e2f14b2">&#9670;&nbsp;</a></span>make_max_clique_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.make_max_clique_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the maximal clique graph of the given graph.

The nodes of the maximal clique graph of `G` are the cliques of
`G` and an edge joins two cliques if the cliques are not disjoint.

Parameters
----------
G : NetworkX graph

create_using : NetworkX graph constructor, optional (default=nx.Graph)
   Graph type to create. If graph instance, then cleared before populated.

Returns
-------
NetworkX graph
    A graph whose nodes are the cliques of `G` and whose edges
    join two cliques if they are not disjoint.

Notes
-----
This function behaves like the following code::

    import networkx as nx
    G = nx.make_clique_bipartite(G)
    cliques = [v for v in G.nodes() if G.nodes[v]['bipartite'] == 0]
    G = nx.bipartite.project(G, cliques)
    G = nx.relabel_nodes(G, {-v: v - 1 for v in G})

It should be faster, though, since it skips all the intermediate
steps.</pre> 
</div>
</div>
<a id="a19437be8e85651bb15f27f39d9f88755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19437be8e85651bb15f27f39d9f88755">&#9670;&nbsp;</a></span>max_weight_clique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.max_weight_clique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a maximum weight clique in G.

A *clique* in a graph is a set of nodes such that every two distinct nodes
are adjacent.  The *weight* of a clique is the sum of the weights of its
nodes.  A *maximum weight clique* of graph G is a clique C in G such that
no clique in G has weight greater than the weight of C.

Parameters
----------
G : NetworkX graph
    Undirected graph
weight : string or None, optional (default='weight')
    The node attribute that holds the integer value used as a weight.
    If None, then each node has weight 1.

Returns
-------
clique : list
    the nodes of a maximum weight clique
weight : int
    the weight of a maximum weight clique

Notes
-----
The implementation is recursive, and therefore it may run into recursion
depth issues if G contains a clique whose number of nodes is close to the
recursion depth limit.

At each search node, the algorithm greedily constructs a weighted
independent set cover of part of the graph in order to find a small set of
nodes on which to branch.  The algorithm is very similar to the algorithm
of Tavares et al. [1]_, other than the fact that the NetworkX version does
not use bitsets.  This style of algorithm for maximum weight clique (and
maximum weight independent set, which is the same problem but on the
complement graph) has a decades-long history.  See Algorithm B of Warren
and Hicks [2]_ and the references in that paper.

References
----------
.. [1] Tavares, W.A., Neto, M.B.C., Rodrigues, C.D., Michelon, P.: Um
       algoritmo de branch and bound para o problema da clique máxima
       ponderada.  Proceedings of XLVII SBPO 1 (2015).

.. [2] Warrent, Jeffrey S, Hicks, Illya V.: Combinatorial Branch-and-Bound
       for the Maximum Weight Independent Set Problem.  Technical Report,
       Texas A&amp;M University (2016).
</pre> 
</div>
</div>
<a id="ae7b5c17115637c1f7c9a319b1f08c6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b5c17115637c1f7c9a319b1f08c6af">&#9670;&nbsp;</a></span>node_clique_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.node_clique_number </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cliques</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the size of the largest maximal clique containing
each given node.

Returns a single or list depending on input nodes.
Optional list of cliques can be input if already computed.
</pre> 
</div>
</div>
<a id="a715dddf1461fea94accb43717f4e7fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715dddf1461fea94accb43717f4e7fb6">&#9670;&nbsp;</a></span>number_of_cliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.clique.number_of_cliques </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cliques</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the number of maximal cliques for each node.

Returns a single or list depending on input nodes.
Optional list of cliques can be input if already computed.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
