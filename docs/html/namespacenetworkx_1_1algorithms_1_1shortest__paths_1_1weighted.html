<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.shortest_paths.weighted Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths.html">shortest_paths</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html">weighted</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.shortest_paths.weighted Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a095dd1ac8fbd1166cdfec7a044b2a751"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a095dd1ac8fbd1166cdfec7a044b2a751">dijkstra_path</a> (G, source, target, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a095dd1ac8fbd1166cdfec7a044b2a751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a179e91d8496dabf25682da89b575b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a01a179e91d8496dabf25682da89b575b">dijkstra_path_length</a> (G, source, target, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a01a179e91d8496dabf25682da89b575b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fce3a81151f15473e1801803a3a1028"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a9fce3a81151f15473e1801803a3a1028">single_source_dijkstra_path</a> (G, source, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a9fce3a81151f15473e1801803a3a1028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec7f3d75b6973e3acc5019448258df7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#afec7f3d75b6973e3acc5019448258df7">single_source_dijkstra_path_length</a> (G, source, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:afec7f3d75b6973e3acc5019448258df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc651b4331fd0b95cac56fc491a0e81"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#aefc651b4331fd0b95cac56fc491a0e81">single_source_dijkstra</a> (G, source, target=None, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:aefc651b4331fd0b95cac56fc491a0e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486bcb57503a86eea5888b1ce4ba8a3d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a486bcb57503a86eea5888b1ce4ba8a3d">multi_source_dijkstra_path</a> (G, sources, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a486bcb57503a86eea5888b1ce4ba8a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0469ea487b81adb0071ccaef986efb4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#af0469ea487b81adb0071ccaef986efb4">multi_source_dijkstra_path_length</a> (G, sources, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:af0469ea487b81adb0071ccaef986efb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5f81cc7c6f46d1f11ec440ee37b930"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#aee5f81cc7c6f46d1f11ec440ee37b930">multi_source_dijkstra</a> (G, sources, target=None, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:aee5f81cc7c6f46d1f11ec440ee37b930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa626ff4e7f1c29c88f1fd9711b33b1ba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#aa626ff4e7f1c29c88f1fd9711b33b1ba">dijkstra_predecessor_and_distance</a> (G, source, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:aa626ff4e7f1c29c88f1fd9711b33b1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2307507504e391a1bc60e53564f0066a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a2307507504e391a1bc60e53564f0066a">all_pairs_dijkstra</a> (G, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a2307507504e391a1bc60e53564f0066a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca70fc51bf6bb5ad9d9e41e4451e5e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#acca70fc51bf6bb5ad9d9e41e4451e5e6">all_pairs_dijkstra_path_length</a> (G, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:acca70fc51bf6bb5ad9d9e41e4451e5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab315738b5d893fe6d12f4d7396a4c777"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#ab315738b5d893fe6d12f4d7396a4c777">all_pairs_dijkstra_path</a> (G, cutoff=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:ab315738b5d893fe6d12f4d7396a4c777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0a3e61a52f47e5fd682a4df34aad6c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a3e0a3e61a52f47e5fd682a4df34aad6c">bellman_ford_predecessor_and_distance</a> (G, source, target=None, weight=&quot;weight&quot;, heuristic=False)</td></tr>
<tr class="separator:a3e0a3e61a52f47e5fd682a4df34aad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e342fe36f78d22f22315472f5e4845a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a9e342fe36f78d22f22315472f5e4845a">bellman_ford_path</a> (G, source, target, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a9e342fe36f78d22f22315472f5e4845a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985b3fe02368560b5bfcf3506ab479f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a985b3fe02368560b5bfcf3506ab479f7">bellman_ford_path_length</a> (G, source, target, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a985b3fe02368560b5bfcf3506ab479f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7193ad94b7b96b526d6f504fbd9928d3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a7193ad94b7b96b526d6f504fbd9928d3">single_source_bellman_ford_path</a> (G, source, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a7193ad94b7b96b526d6f504fbd9928d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0621107112bb024e746959e343f53e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#ac0621107112bb024e746959e343f53e3">single_source_bellman_ford_path_length</a> (G, source, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:ac0621107112bb024e746959e343f53e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0ea1b941fbc772ac500e47c6fbbf06"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a8c0ea1b941fbc772ac500e47c6fbbf06">single_source_bellman_ford</a> (G, source, target=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a8c0ea1b941fbc772ac500e47c6fbbf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936c1f63a5a5699a63900f569a9cc9b0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a936c1f63a5a5699a63900f569a9cc9b0">all_pairs_bellman_ford_path_length</a> (G, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a936c1f63a5a5699a63900f569a9cc9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425f04d53d403563a733dc77b1c7cd24"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a425f04d53d403563a733dc77b1c7cd24">all_pairs_bellman_ford_path</a> (G, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a425f04d53d403563a733dc77b1c7cd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d375c09123fa049e92db19e16ce57fd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a5d375c09123fa049e92db19e16ce57fd">goldberg_radzik</a> (G, source, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a5d375c09123fa049e92db19e16ce57fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfecc0f26108aa59e45335af3a3c4357"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#adfecc0f26108aa59e45335af3a3c4357">negative_edge_cycle</a> (G, weight=&quot;weight&quot;, heuristic=True)</td></tr>
<tr class="separator:adfecc0f26108aa59e45335af3a3c4357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb8421faed983fc247d9ad2e789645d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a4eb8421faed983fc247d9ad2e789645d">bidirectional_dijkstra</a> (G, source, target, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a4eb8421faed983fc247d9ad2e789645d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b33735d56c0db02c1126dd8eed79650"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1weighted.html#a8b33735d56c0db02c1126dd8eed79650">johnson</a> (G, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a8b33735d56c0db02c1126dd8eed79650"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Shortest path algorithms for weighed graphs.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a425f04d53d403563a733dc77b1c7cd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a425f04d53d403563a733dc77b1c7cd24">&#9670;&nbsp;</a></span>all_pairs_bellman_ford_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.all_pairs_bellman_ford_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest paths between all nodes in a weighted graph.

Parameters
----------
G : NetworkX graph

weight: string, optional (default='weight')
    Edge data key corresponding to the edge weight

Returns
-------
distance : dictionary
    Dictionary, keyed by source and target, of shortest paths.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; path = dict(nx.all_pairs_bellman_ford_path(G))
&gt;&gt;&gt; print(path[0][4])
[0, 1, 2, 3, 4]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

See Also
--------
floyd_warshall, all_pairs_dijkstra_path</pre> 
</div>
</div>
<a id="a936c1f63a5a5699a63900f569a9cc9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936c1f63a5a5699a63900f569a9cc9b0">&#9670;&nbsp;</a></span>all_pairs_bellman_ford_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.all_pairs_bellman_ford_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest path lengths between all nodes in a weighted graph.

Parameters
----------
G : NetworkX graph

weight: string, optional (default='weight')
    Edge data key corresponding to the edge weight

Returns
-------
distance : iterator
    (source, dictionary) iterator with dictionary keyed by target and
    shortest path length as the key value.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length = dict(nx.all_pairs_bellman_ford_path_length(G))
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"1 - {node}: {length[1][node]}")
1 - 0: 1
1 - 1: 0
1 - 2: 1
1 - 3: 2
1 - 4: 3
&gt;&gt;&gt; length[3][2]
1
&gt;&gt;&gt; length[2][2]
0

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The dictionary returned only has keys for reachable node pairs.
</pre> 
</div>
</div>
<a id="a2307507504e391a1bc60e53564f0066a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2307507504e391a1bc60e53564f0066a">&#9670;&nbsp;</a></span>all_pairs_dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.all_pairs_dijkstra </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find shortest weighted paths and lengths between all nodes.

Parameters
----------
G : NetworkX graph

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edge[u][v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Yields
------
(node, (distance, path)) : (node obj, (dict, dict))
    Each source node has two associated dicts. The first holds distance
    keyed by target and the second holds paths keyed by target.
    (See single_source_dijkstra for the source/target node terminology.)
    If desired you can apply `dict()` to this function to create a dict
    keyed by source node to the two dicts.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; len_path = dict(nx.all_pairs_dijkstra(G))
&gt;&gt;&gt; print(len_path[3][0][1])
2
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"3 - {node}: {len_path[3][0][node]}")
3 - 0: 3
3 - 1: 2
3 - 2: 1
3 - 3: 0
3 - 4: 1
&gt;&gt;&gt; len_path[3][1][1]
[3, 2, 1]
&gt;&gt;&gt; for n, (dist, path) in nx.all_pairs_dijkstra(G):
...     print(path[1])
[0, 1]
[1]
[2, 1]
[3, 2, 1]
[4, 3, 2, 1]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The yielded dicts only have keys for reachable nodes.
</pre> 
</div>
</div>
<a id="ab315738b5d893fe6d12f4d7396a4c777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab315738b5d893fe6d12f4d7396a4c777">&#9670;&nbsp;</a></span>all_pairs_dijkstra_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.all_pairs_dijkstra_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest paths between all nodes in a weighted graph.

Parameters
----------
G : NetworkX graph

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
distance : dictionary
    Dictionary, keyed by source and target, of shortest paths.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; path = dict(nx.all_pairs_dijkstra_path(G))
&gt;&gt;&gt; print(path[0][4])
[0, 1, 2, 3, 4]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

See Also
--------
floyd_warshall, all_pairs_bellman_ford_path</pre> 
</div>
</div>
<a id="acca70fc51bf6bb5ad9d9e41e4451e5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca70fc51bf6bb5ad9d9e41e4451e5e6">&#9670;&nbsp;</a></span>all_pairs_dijkstra_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.all_pairs_dijkstra_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest path lengths between all nodes in a weighted graph.

Parameters
----------
G : NetworkX graph

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
distance : iterator
    (source, dictionary) iterator with dictionary keyed by target and
    shortest path length as the key value.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length = dict(nx.all_pairs_dijkstra_path_length(G))
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"1 - {node}: {length[1][node]}")
1 - 0: 1
1 - 1: 0
1 - 2: 1
1 - 3: 2
1 - 4: 3
&gt;&gt;&gt; length[3][2]
1
&gt;&gt;&gt; length[2][2]
0

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The dictionary returned only has keys for reachable node pairs.
</pre> 
</div>
</div>
<a id="a9e342fe36f78d22f22315472f5e4845a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e342fe36f78d22f22315472f5e4845a">&#9670;&nbsp;</a></span>bellman_ford_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.bellman_ford_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the shortest path from source to target in a weighted graph G.

Parameters
----------
G : NetworkX graph

source : node
    Starting node

target : node
    Ending node

weight: string, optional (default='weight')
    Edge data key corresponding to the edge weight

Returns
-------
path : list
    List of nodes in a shortest path.

Raises
------
NodeNotFound
    If `source` is not in `G`.

NetworkXNoPath
    If no path exists between source and target.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; print(nx.bellman_ford_path(G, 0, 4))
[0, 1, 2, 3, 4]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

See Also
--------
dijkstra_path, bellman_ford_path_length
</pre> 
</div>
</div>
<a id="a985b3fe02368560b5bfcf3506ab479f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985b3fe02368560b5bfcf3506ab479f7">&#9670;&nbsp;</a></span>bellman_ford_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.bellman_ford_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the shortest path length from source to target
in a weighted graph.

Parameters
----------
G : NetworkX graph

source : node label
    starting node for path

target : node label
    ending node for path

weight: string, optional (default='weight')
    Edge data key corresponding to the edge weight

Returns
-------
length : number
    Shortest path length.

Raises
------
NodeNotFound
    If `source` is not in `G`.

NetworkXNoPath
    If no path exists between source and target.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; print(nx.bellman_ford_path_length(G, 0, 4))
4

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

See Also
--------
dijkstra_path_length, bellman_ford_path
</pre> 
</div>
</div>
<a id="a3e0a3e61a52f47e5fd682a4df34aad6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0a3e61a52f47e5fd682a4df34aad6c">&#9670;&nbsp;</a></span>bellman_ford_predecessor_and_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.bellman_ford_predecessor_and_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>heuristic</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest path lengths and predecessors on shortest paths
in weighted graphs.

The algorithm has a running time of $O(mn)$ where $n$ is the number of
nodes and $m$ is the number of edges.  It is slower than Dijkstra but
can handle negative edge weights.

Parameters
----------
G : NetworkX graph
    The algorithm works for all types of graphs, including directed
    graphs and multigraphs.

source: node label
    Starting node for path

target : node label, optional
    Ending node for path

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

heuristic : bool
    Determines whether to use a heuristic to early detect negative
    cycles at a hopefully negligible cost.

Returns
-------
pred, dist : dictionaries
    Returns two dictionaries keyed by node to predecessor in the
    path and to the distance from the source respectively.

Raises
------
NodeNotFound
    If `source` is not in `G`.

NetworkXUnbounded
    If the (di)graph contains a negative cost (di)cycle, the
    algorithm raises an exception to indicate the presence of the
    negative cost (di)cycle.  Note: any negative weight edge in an
    undirected graph is a negative cost cycle.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5, create_using=nx.DiGraph())
&gt;&gt;&gt; pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0)
&gt;&gt;&gt; sorted(pred.items())
[(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]
&gt;&gt;&gt; sorted(dist.items())
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]

&gt;&gt;&gt; pred, dist = nx.bellman_ford_predecessor_and_distance(G, 0, 1)
&gt;&gt;&gt; sorted(pred.items())
[(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]
&gt;&gt;&gt; sorted(dist.items())
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]

&gt;&gt;&gt; G = nx.cycle_graph(5, create_using=nx.DiGraph())
&gt;&gt;&gt; G[1][2]["weight"] = -7
&gt;&gt;&gt; nx.bellman_ford_predecessor_and_distance(G, 0)
Traceback (most recent call last):
    ...
networkx.exception.NetworkXUnbounded: Negative cost cycle detected.

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The dictionaries returned only have keys for nodes reachable from
the source.

In the case where the (di)graph is not connected, if a component
not containing the source contains a negative cost (di)cycle, it
will not be detected.

In NetworkX v2.1 and prior, the source node had predecessor `[None]`.
In NetworkX v2.2 this changed to the source node having predecessor `[]`
</pre> 
</div>
</div>
<a id="a4eb8421faed983fc247d9ad2e789645d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb8421faed983fc247d9ad2e789645d">&#9670;&nbsp;</a></span>bidirectional_dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.bidirectional_dijkstra </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Dijkstra's algorithm for shortest paths using bidirectional search.

Parameters
----------
G : NetworkX graph

source : node
    Starting node.

target : node
    Ending node.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
length, path : number and list
    length is the distance from source to target.
    path is a list of nodes on a path from source to target.

Raises
------
NodeNotFound
    If either `source` or `target` is not in `G`.

NetworkXNoPath
    If no path exists between source and target.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length, path = nx.bidirectional_dijkstra(G, 0, 4)
&gt;&gt;&gt; print(length)
4
&gt;&gt;&gt; print(path)
[0, 1, 2, 3, 4]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

In practice  bidirectional Dijkstra is much more than twice as fast as
ordinary Dijkstra.

Ordinary Dijkstra expands nodes in a sphere-like manner from the
source. The radius of this sphere will eventually be the length
of the shortest path. Bidirectional Dijkstra will expand nodes
from both the source and the target, making two spheres of half
this radius. Volume of the first sphere is `\pi*r*r` while the
others are `2*\pi*r/2*r/2`, making up half the volume.

This algorithm is not guaranteed to work if edge weights
are negative or are floating point numbers
(overflows and roundoff errors can cause problems).

See Also
--------
shortest_path
shortest_path_length
</pre> 
</div>
</div>
<a id="a095dd1ac8fbd1166cdfec7a044b2a751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095dd1ac8fbd1166cdfec7a044b2a751">&#9670;&nbsp;</a></span>dijkstra_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.dijkstra_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the shortest weighted path from source to target in G.

Uses Dijkstra's Method to compute the shortest weighted path
between two nodes in a graph.

Parameters
----------
G : NetworkX graph

source : node
    Starting node

target : node
    Ending node

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
path : list
    List of nodes in a shortest path.

Raises
------
NodeNotFound
    If `source` is not in `G`.

NetworkXNoPath
    If no path exists between source and target.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; print(nx.dijkstra_path(G, 0, 4))
[0, 1, 2, 3, 4]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The weight function can be used to hide edges by returning None.
So ``weight = lambda u, v, d: 1 if d['color']=="red" else None``
will find the shortest red path.

The weight function can be used to include node weights.

&gt;&gt;&gt; def func(u, v, d):
...     node_u_wt = G.nodes[u].get("node_weight", 1)
...     node_v_wt = G.nodes[v].get("node_weight", 1)
...     edge_wt = d.get("weight", 1)
...     return node_u_wt / 2 + node_v_wt / 2 + edge_wt

In this example we take the average of start and end node
weights of an edge and add it to the weight of the edge.

The function :func:`single_source_dijkstra` computes both
path and length-of-path if you need both, use that.

See Also
--------
bidirectional_dijkstra
bellman_ford_path
single_source_dijkstra
</pre> 
</div>
</div>
<a id="a01a179e91d8496dabf25682da89b575b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a179e91d8496dabf25682da89b575b">&#9670;&nbsp;</a></span>dijkstra_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.dijkstra_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the shortest weighted path length in G from source to target.

Uses Dijkstra's Method to compute the shortest weighted path length
between two nodes in a graph.

Parameters
----------
G : NetworkX graph

source : node label
    starting node for path

target : node label
    ending node for path

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
length : number
    Shortest path length.

Raises
------
NodeNotFound
    If `source` is not in `G`.

NetworkXNoPath
    If no path exists between source and target.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; print(nx.dijkstra_path_length(G, 0, 4))
4

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The weight function can be used to hide edges by returning None.
So ``weight = lambda u, v, d: 1 if d['color']=="red" else None``
will find the shortest red path.

The function :func:`single_source_dijkstra` computes both
path and length-of-path if you need both, use that.

See Also
--------
bidirectional_dijkstra
bellman_ford_path_length
single_source_dijkstra</pre> 
</div>
</div>
<a id="aa626ff4e7f1c29c88f1fd9711b33b1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa626ff4e7f1c29c88f1fd9711b33b1ba">&#9670;&nbsp;</a></span>dijkstra_predecessor_and_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.dijkstra_predecessor_and_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute weighted shortest path length and predecessors.

Uses Dijkstra's Method to obtain the shortest weighted paths
and return dictionaries of predecessors for each node and
distance for each node from the `source`.

Parameters
----------
G : NetworkX graph

source : node label
    Starting node for path

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
pred, distance : dictionaries
    Returns two dictionaries representing a list of predecessors
    of a node and the distance to each node.
    Warning: If target is specified, the dicts are incomplete as they
    only contain information for the nodes along a path to target.

Raises
------
NodeNotFound
    If `source` is not in `G`.

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The list of predecessors contains more than one element only when
there are more than one shortest paths to the key node.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5, create_using=nx.DiGraph())
&gt;&gt;&gt; pred, dist = nx.dijkstra_predecessor_and_distance(G, 0)
&gt;&gt;&gt; sorted(pred.items())
[(0, []), (1, [0]), (2, [1]), (3, [2]), (4, [3])]
&gt;&gt;&gt; sorted(dist.items())
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]

&gt;&gt;&gt; pred, dist = nx.dijkstra_predecessor_and_distance(G, 0, 1)
&gt;&gt;&gt; sorted(pred.items())
[(0, []), (1, [0])]
&gt;&gt;&gt; sorted(dist.items())
[(0, 0), (1, 1)]
</pre> 
</div>
</div>
<a id="a5d375c09123fa049e92db19e16ce57fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d375c09123fa049e92db19e16ce57fd">&#9670;&nbsp;</a></span>goldberg_radzik()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.goldberg_radzik </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest path lengths and predecessors on shortest paths
in weighted graphs.

The algorithm has a running time of $O(mn)$ where $n$ is the number of
nodes and $m$ is the number of edges.  It is slower than Dijkstra but
can handle negative edge weights.

Parameters
----------
G : NetworkX graph
    The algorithm works for all types of graphs, including directed
    graphs and multigraphs.

source: node label
    Starting node for path

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
pred, dist : dictionaries
    Returns two dictionaries keyed by node to predecessor in the
    path and to the distance from the source respectively.

Raises
------
NodeNotFound
    If `source` is not in `G`.

NetworkXUnbounded
    If the (di)graph contains a negative cost (di)cycle, the
    algorithm raises an exception to indicate the presence of the
    negative cost (di)cycle.  Note: any negative weight edge in an
    undirected graph is a negative cost cycle.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5, create_using=nx.DiGraph())
&gt;&gt;&gt; pred, dist = nx.goldberg_radzik(G, 0)
&gt;&gt;&gt; sorted(pred.items())
[(0, None), (1, 0), (2, 1), (3, 2), (4, 3)]
&gt;&gt;&gt; sorted(dist.items())
[(0, 0), (1, 1), (2, 2), (3, 3), (4, 4)]

&gt;&gt;&gt; G = nx.cycle_graph(5, create_using=nx.DiGraph())
&gt;&gt;&gt; G[1][2]["weight"] = -7
&gt;&gt;&gt; nx.goldberg_radzik(G, 0)
Traceback (most recent call last):
    ...
networkx.exception.NetworkXUnbounded: Negative cost cycle detected.

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The dictionaries returned only have keys for nodes reachable from
the source.

In the case where the (di)graph is not connected, if a component
not containing the source contains a negative cost (di)cycle, it
will not be detected.</pre> 
</div>
</div>
<a id="a8b33735d56c0db02c1126dd8eed79650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b33735d56c0db02c1126dd8eed79650">&#9670;&nbsp;</a></span>johnson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.johnson </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Uses Johnson's Algorithm to compute shortest paths.

Johnson's Algorithm finds a shortest path between each pair of
nodes in a weighted graph even if negative weights are present.

Parameters
----------
G : NetworkX graph

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
distance : dictionary
    Dictionary, keyed by source and target, of shortest paths.

Raises
------
NetworkXError
    If given graph is not weighted.

Examples
--------
&gt;&gt;&gt; graph = nx.DiGraph()
&gt;&gt;&gt; graph.add_weighted_edges_from(
...     [("0", "3", 3), ("0", "1", -5), ("0", "2", 2), ("1", "2", 4), ("2", "3", 1)]
... )
&gt;&gt;&gt; paths = nx.johnson(graph, weight="weight")
&gt;&gt;&gt; paths["0"]["2"]
['0', '1', '2']

Notes
-----
Johnson's algorithm is suitable even for graphs with negative weights. It
works by using the BellmanFord algorithm to compute a transformation of
the input graph that removes all negative weights, allowing Dijkstra's
algorithm to be used on the transformed graph.

The time complexity of this algorithm is $O(n^2 \log n + n m)$,
where $n$ is the number of nodes and $m$ the number of edges in the
graph. For dense graphs, this may be faster than the FloydWarshall
algorithm.

See Also
--------
floyd_warshall_predecessor_and_distance
floyd_warshall_numpy
all_pairs_shortest_path
all_pairs_shortest_path_length
all_pairs_dijkstra_path
bellman_ford_predecessor_and_distance
all_pairs_bellman_ford_path
all_pairs_bellman_ford_path_length</pre> 
</div>
</div>
<a id="aee5f81cc7c6f46d1f11ec440ee37b930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5f81cc7c6f46d1f11ec440ee37b930">&#9670;&nbsp;</a></span>multi_source_dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.multi_source_dijkstra </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find shortest weighted paths and lengths from a given set of
source nodes.

Uses Dijkstra's algorithm to compute the shortest paths and lengths
between one of the source nodes and the given `target`, or all other
reachable nodes if not specified, for a weighted graph.

Parameters
----------
G : NetworkX graph

sources : non-empty set of nodes
    Starting nodes for paths. If this is just a set containing a
    single node, then all paths computed by this function will start
    from that node. If there are two or more nodes in the set, the
    computed paths may begin from any one of the start nodes.

target : node label, optional
    Ending node for path

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
distance, path : pair of dictionaries, or numeric and list
    If target is None, returns a tuple of two dictionaries keyed by node.
    The first dictionary stores distance from one of the source nodes.
    The second stores the path from one of the sources to that node.
    If target is not None, returns a tuple of (distance, path) where
    distance is the distance from source to target and path is a list
    representing the path from source to target.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length, path = nx.multi_source_dijkstra(G, {0, 4})
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"{node}: {length[node]}")
0: 0
1: 1
2: 2
3: 1
4: 0
&gt;&gt;&gt; path[1]
[0, 1]
&gt;&gt;&gt; path[3]
[4, 3]

&gt;&gt;&gt; length, path = nx.multi_source_dijkstra(G, {0, 4}, 1)
&gt;&gt;&gt; length
1
&gt;&gt;&gt; path
[0, 1]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The weight function can be used to hide edges by returning None.
So ``weight = lambda u, v, d: 1 if d['color']=="red" else None``
will find the shortest red path.

Based on the Python cookbook recipe (119466) at
https://code.activestate.com/recipes/119466/

This algorithm is not guaranteed to work if edge weights
are negative or are floating point numbers
(overflows and roundoff errors can cause problems).

Raises
------
ValueError
    If `sources` is empty.
NodeNotFound
    If any of `sources` is not in `G`.

See Also
--------
multi_source_dijkstra_path
multi_source_dijkstra_path_length</pre> 
</div>
</div>
<a id="a486bcb57503a86eea5888b1ce4ba8a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486bcb57503a86eea5888b1ce4ba8a3d">&#9670;&nbsp;</a></span>multi_source_dijkstra_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.multi_source_dijkstra_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find shortest weighted paths in G from a given set of source
nodes.

Compute shortest path between any of the source nodes and all other
reachable nodes for a weighted graph.

Parameters
----------
G : NetworkX graph

sources : non-empty set of nodes
    Starting nodes for paths. If this is just a set containing a
    single node, then all paths computed by this function will start
    from that node. If there are two or more nodes in the set, the
    computed paths may begin from any one of the start nodes.

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
paths : dictionary
    Dictionary of shortest paths keyed by target.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; path = nx.multi_source_dijkstra_path(G, {0, 4})
&gt;&gt;&gt; path[1]
[0, 1]
&gt;&gt;&gt; path[3]
[4, 3]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The weight function can be used to hide edges by returning None.
So ``weight = lambda u, v, d: 1 if d['color']=="red" else None``
will find the shortest red path.

Raises
------
ValueError
    If `sources` is empty.
NodeNotFound
    If any of `sources` is not in `G`.

See Also
--------
multi_source_dijkstra, multi_source_bellman_ford</pre> 
</div>
</div>
<a id="af0469ea487b81adb0071ccaef986efb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0469ea487b81adb0071ccaef986efb4">&#9670;&nbsp;</a></span>multi_source_dijkstra_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.multi_source_dijkstra_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find shortest weighted path lengths in G from a given set of
source nodes.

Compute the shortest path length between any of the source nodes and
all other reachable nodes for a weighted graph.

Parameters
----------
G : NetworkX graph

sources : non-empty set of nodes
    Starting nodes for paths. If this is just a set containing a
    single node, then all paths computed by this function will start
    from that node. If there are two or more nodes in the set, the
    computed paths may begin from any one of the start nodes.

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
length : dict
    Dict keyed by node to shortest path length to nearest source.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length = nx.multi_source_dijkstra_path_length(G, {0, 4})
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"{node}: {length[node]}")
0: 0
1: 1
2: 2
3: 1
4: 0

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The weight function can be used to hide edges by returning None.
So ``weight = lambda u, v, d: 1 if d['color']=="red" else None``
will find the shortest red path.

Raises
------
ValueError
    If `sources` is empty.
NodeNotFound
    If any of `sources` is not in `G`.

See Also
--------
multi_source_dijkstra</pre> 
</div>
</div>
<a id="adfecc0f26108aa59e45335af3a3c4357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfecc0f26108aa59e45335af3a3c4357">&#9670;&nbsp;</a></span>negative_edge_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.negative_edge_cycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>heuristic</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if there exists a negative edge cycle anywhere in G.

Parameters
----------
G : NetworkX graph

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

heuristic : bool
    Determines whether to use a heuristic to early detect negative
    cycles at a negligible cost. In case of graphs with a negative cycle,
    the performance of detection increases by at least an order of magnitude.

Returns
-------
negative_cycle : bool
    True if a negative edge cycle exists, otherwise False.

Examples
--------
&gt;&gt;&gt; G = nx.cycle_graph(5, create_using=nx.DiGraph())
&gt;&gt;&gt; print(nx.negative_edge_cycle(G))
False
&gt;&gt;&gt; G[1][2]["weight"] = -7
&gt;&gt;&gt; print(nx.negative_edge_cycle(G))
True

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

This algorithm uses bellman_ford_predecessor_and_distance() but finds
negative cycles on any component by first adding a new node connected to
every node, and starting bellman_ford_predecessor_and_distance on that
node.  It then removes that extra node.
</pre> 
</div>
</div>
<a id="a8c0ea1b941fbc772ac500e47c6fbbf06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0ea1b941fbc772ac500e47c6fbbf06">&#9670;&nbsp;</a></span>single_source_bellman_ford()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.single_source_bellman_ford </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest paths and lengths in a weighted graph G.

Uses Bellman-Ford algorithm for shortest paths.

Parameters
----------
G : NetworkX graph

source : node label
    Starting node for path

target : node label, optional
    Ending node for path

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
distance, path : pair of dictionaries, or numeric and list
    If target is None, returns a tuple of two dictionaries keyed by node.
    The first dictionary stores distance from one of the source nodes.
    The second stores the path from one of the sources to that node.
    If target is not None, returns a tuple of (distance, path) where
    distance is the distance from source to target and path is a list
    representing the path from source to target.

Raises
------
NodeNotFound
    If `source` is not in `G`.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length, path = nx.single_source_bellman_ford(G, 0)
&gt;&gt;&gt; print(length[4])
4
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"{node}: {length[node]}")
0: 0
1: 1
2: 2
3: 3
4: 4
&gt;&gt;&gt; path[4]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; length, path = nx.single_source_bellman_ford(G, 0, 1)
&gt;&gt;&gt; length
1
&gt;&gt;&gt; path
[0, 1]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

See Also
--------
single_source_dijkstra
single_source_bellman_ford_path
single_source_bellman_ford_path_length
</pre> 
</div>
</div>
<a id="a7193ad94b7b96b526d6f504fbd9928d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7193ad94b7b96b526d6f504fbd9928d3">&#9670;&nbsp;</a></span>single_source_bellman_ford_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.single_source_bellman_ford_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest path between source and all other reachable
nodes for a weighted graph.

Parameters
----------
G : NetworkX graph

source : node
    Starting node for path.

weight: string, optional (default='weight')
    Edge data key corresponding to the edge weight

Returns
-------
paths : dictionary
    Dictionary of shortest path lengths keyed by target.

Raises
------
NodeNotFound
    If `source` is not in `G`.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; path = nx.single_source_bellman_ford_path(G, 0)
&gt;&gt;&gt; path[4]
[0, 1, 2, 3, 4]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

See Also
--------
single_source_dijkstra, single_source_bellman_ford</pre> 
</div>
</div>
<a id="ac0621107112bb024e746959e343f53e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0621107112bb024e746959e343f53e3">&#9670;&nbsp;</a></span>single_source_bellman_ford_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.single_source_bellman_ford_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the shortest path length between source and all other
reachable nodes for a weighted graph.

Parameters
----------
G : NetworkX graph

source : node label
    Starting node for path

weight: string, optional (default='weight')
    Edge data key corresponding to the edge weight.

Returns
-------
length : iterator
    (target, shortest path length) iterator

Raises
------
NodeNotFound
    If `source` is not in `G`.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length = dict(nx.single_source_bellman_ford_path_length(G, 0))
&gt;&gt;&gt; length[4]
4
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"{node}: {length[node]}")
0: 0
1: 1
2: 2
3: 3
4: 4

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

See Also
--------
single_source_dijkstra, single_source_bellman_ford</pre> 
</div>
</div>
<a id="aefc651b4331fd0b95cac56fc491a0e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc651b4331fd0b95cac56fc491a0e81">&#9670;&nbsp;</a></span>single_source_dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.single_source_dijkstra </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find shortest weighted paths and lengths from a source node.

Compute the shortest path length between source and all other
reachable nodes for a weighted graph.

Uses Dijkstra's algorithm to compute shortest paths and lengths
between a source and all other reachable nodes in a weighted graph.

Parameters
----------
G : NetworkX graph

source : node label
    Starting node for path

target : node label, optional
    Ending node for path

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.


weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
distance, path : pair of dictionaries, or numeric and list.
    If target is None, paths and lengths to all nodes are computed.
    The return value is a tuple of two dictionaries keyed by target nodes.
    The first dictionary stores distance to each target node.
    The second stores the path to each target node.
    If target is not None, returns a tuple (distance, path), where
    distance is the distance from source to target and path is a list
    representing the path from source to target.

Raises
------
NodeNotFound
    If `source` is not in `G`.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length, path = nx.single_source_dijkstra(G, 0)
&gt;&gt;&gt; print(length[4])
4
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"{node}: {length[node]}")
0: 0
1: 1
2: 2
3: 3
4: 4
&gt;&gt;&gt; path[4]
[0, 1, 2, 3, 4]
&gt;&gt;&gt; length, path = nx.single_source_dijkstra(G, 0, 1)
&gt;&gt;&gt; length
1
&gt;&gt;&gt; path
[0, 1]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The weight function can be used to hide edges by returning None.
So ``weight = lambda u, v, d: 1 if d['color']=="red" else None``
will find the shortest red path.

Based on the Python cookbook recipe (119466) at
https://code.activestate.com/recipes/119466/

This algorithm is not guaranteed to work if edge weights
are negative or are floating point numbers
(overflows and roundoff errors can cause problems).

See Also
--------
single_source_dijkstra_path
single_source_dijkstra_path_length
single_source_bellman_ford
</pre> 
</div>
</div>
<a id="a9fce3a81151f15473e1801803a3a1028"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fce3a81151f15473e1801803a3a1028">&#9670;&nbsp;</a></span>single_source_dijkstra_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.single_source_dijkstra_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find shortest weighted paths in G from a source node.

Compute shortest path between source and all other reachable
nodes for a weighted graph.

Parameters
----------
G : NetworkX graph

source : node
    Starting node for path.

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
paths : dictionary
    Dictionary of shortest path lengths keyed by target.

Raises
------
NodeNotFound
    If `source` is not in `G`.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; path = nx.single_source_dijkstra_path(G, 0)
&gt;&gt;&gt; path[4]
[0, 1, 2, 3, 4]

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The weight function can be used to hide edges by returning None.
So ``weight = lambda u, v, d: 1 if d['color']=="red" else None``
will find the shortest red path.

See Also
--------
single_source_dijkstra, single_source_bellman_ford</pre> 
</div>
</div>
<a id="afec7f3d75b6973e3acc5019448258df7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec7f3d75b6973e3acc5019448258df7">&#9670;&nbsp;</a></span>single_source_dijkstra_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.weighted.single_source_dijkstra_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find shortest weighted path lengths in G from a source node.

Compute the shortest path length between source and all other
reachable nodes for a weighted graph.

Parameters
----------
G : NetworkX graph

source : node label
    Starting node for path

cutoff : integer or float, optional
    Length (sum of edge weights) at which the search is stopped.
    If cutoff is provided, only return paths with summed weight &lt;= cutoff.

weight : string or function
    If this is a string, then edge weights will be accessed via the
    edge attribute with this key (that is, the weight of the edge
    joining `u` to `v` will be ``G.edges[u, v][weight]``). If no
    such edge attribute exists, the weight of the edge is assumed to
    be one.

    If this is a function, the weight of an edge is the value
    returned by the function. The function must accept exactly three
    positional arguments: the two endpoints of an edge and the
    dictionary of edge attributes for that edge. The function must
    return a number.

Returns
-------
length : dict
    Dict keyed by node to shortest path length from source.

Raises
------
NodeNotFound
    If `source` is not in `G`.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length = nx.single_source_dijkstra_path_length(G, 0)
&gt;&gt;&gt; length[4]
4
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"{node}: {length[node]}")
0: 0
1: 1
2: 2
3: 3
4: 4

Notes
-----
Edge weight attributes must be numerical.
Distances are calculated as sums of weighted edges traversed.

The weight function can be used to hide edges by returning None.
So ``weight = lambda u, v, d: 1 if d['color']=="red" else None``
will find the shortest red path.

See Also
--------
single_source_dijkstra, single_source_bellman_ford_path_length</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
