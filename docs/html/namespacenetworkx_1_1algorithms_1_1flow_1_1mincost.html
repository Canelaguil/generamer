<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.flow.mincost Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow.html">flow</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1mincost.html">mincost</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.flow.mincost Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeb9bc47d477c57c0b0bd04161bae05bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1mincost.html#aeb9bc47d477c57c0b0bd04161bae05bc">min_cost_flow_cost</a> (G, demand=&quot;demand&quot;, capacity=&quot;capacity&quot;, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:aeb9bc47d477c57c0b0bd04161bae05bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891a006d4dc407fcf160c6d6be7e66d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1mincost.html#a891a006d4dc407fcf160c6d6be7e66d4">min_cost_flow</a> (G, demand=&quot;demand&quot;, capacity=&quot;capacity&quot;, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a891a006d4dc407fcf160c6d6be7e66d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f6e84c98d8ab823c1d0334d8034757"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1mincost.html#ac4f6e84c98d8ab823c1d0334d8034757">cost_of_flow</a> (G, flowDict, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:ac4f6e84c98d8ab823c1d0334d8034757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a42d78cf61bb03df04a91acc9484da"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1mincost.html#a25a42d78cf61bb03df04a91acc9484da">max_flow_min_cost</a> (G, s, t, capacity=&quot;capacity&quot;, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a25a42d78cf61bb03df04a91acc9484da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Minimum cost flow algorithms on directed connected graphs.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ac4f6e84c98d8ab823c1d0334d8034757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f6e84c98d8ab823c1d0334d8034757">&#9670;&nbsp;</a></span>cost_of_flow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.flow.mincost.cost_of_flow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flowDict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the cost of the flow given by flowDict on graph G.

Note that this function does not check for the validity of the
flow flowDict. This function will fail if the graph G and the
flow don't have the same edge set.

Parameters
----------
G : NetworkX graph
    DiGraph on which a minimum cost flow satisfying all demands is
    to be found.

weight : string
    Edges of the graph G are expected to have an attribute weight
    that indicates the cost incurred by sending one unit of flow on
    that edge. If not present, the weight is considered to be 0.
    Default value: 'weight'.

flowDict : dictionary
    Dictionary of dictionaries keyed by nodes such that
    flowDict[u][v] is the flow edge (u, v).

Returns
-------
cost : Integer, float
    The total cost of the flow. This is given by the sum over all
    edges of the product of the edge's flow and the edge's weight.

See also
--------
max_flow_min_cost, min_cost_flow, min_cost_flow_cost, network_simplex

Notes
-----
This algorithm is not guaranteed to work if edge weights or demands
are floating point numbers (overflows and roundoff errors can
cause problems). As a workaround you can use integer numbers by
multiplying the relevant edge attributes by a convenient
constant factor (eg 100).
</pre> 
</div>
</div>
<a id="a25a42d78cf61bb03df04a91acc9484da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a42d78cf61bb03df04a91acc9484da">&#9670;&nbsp;</a></span>max_flow_min_cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.flow.mincost.max_flow_min_cost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>&quot;capacity&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a maximum (s, t)-flow of minimum cost.

G is a digraph with edge costs and capacities. There is a source
node s and a sink node t. This function finds a maximum flow from
s to t whose total cost is minimized.

Parameters
----------
G : NetworkX graph
    DiGraph on which a minimum cost flow satisfying all demands is
    to be found.

s: node label
    Source of the flow.

t: node label
    Destination of the flow.

capacity: string
    Edges of the graph G are expected to have an attribute capacity
    that indicates how much flow the edge can support. If this
    attribute is not present, the edge is considered to have
    infinite capacity. Default value: 'capacity'.

weight: string
    Edges of the graph G are expected to have an attribute weight
    that indicates the cost incurred by sending one unit of flow on
    that edge. If not present, the weight is considered to be 0.
    Default value: 'weight'.

Returns
-------
flowDict: dictionary
    Dictionary of dictionaries keyed by nodes such that
    flowDict[u][v] is the flow edge (u, v).

Raises
------
NetworkXError
    This exception is raised if the input graph is not directed or
    not connected.

NetworkXUnbounded
    This exception is raised if there is an infinite capacity path
    from s to t in G. In this case there is no maximum flow. This
    exception is also raised if the digraph G has a cycle of
    negative cost and infinite capacity. Then, the cost of a flow
    is unbounded below.

See also
--------
cost_of_flow, min_cost_flow, min_cost_flow_cost, network_simplex

Notes
-----
This algorithm is not guaranteed to work if edge weights or demands
are floating point numbers (overflows and roundoff errors can
cause problems). As a workaround you can use integer numbers by
multiplying the relevant edge attributes by a convenient
constant factor (eg 100).

Examples
--------
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_edges_from(
...     [
...         (1, 2, {"capacity": 12, "weight": 4}),
...         (1, 3, {"capacity": 20, "weight": 6}),
...         (2, 3, {"capacity": 6, "weight": -3}),
...         (2, 6, {"capacity": 14, "weight": 1}),
...         (3, 4, {"weight": 9}),
...         (3, 5, {"capacity": 10, "weight": 5}),
...         (4, 2, {"capacity": 19, "weight": 13}),
...         (4, 5, {"capacity": 4, "weight": 0}),
...         (5, 7, {"capacity": 28, "weight": 2}),
...         (6, 5, {"capacity": 11, "weight": 1}),
...         (6, 7, {"weight": 8}),
...         (7, 4, {"capacity": 6, "weight": 6}),
...     ]
... )
&gt;&gt;&gt; mincostFlow = nx.max_flow_min_cost(G, 1, 7)
&gt;&gt;&gt; mincost = nx.cost_of_flow(G, mincostFlow)
&gt;&gt;&gt; mincost
373
&gt;&gt;&gt; from networkx.algorithms.flow import maximum_flow
&gt;&gt;&gt; maxFlow = maximum_flow(G, 1, 7)[1]
&gt;&gt;&gt; nx.cost_of_flow(G, maxFlow) &gt;= mincost
True
&gt;&gt;&gt; mincostFlowValue = sum((mincostFlow[u][7] for u in G.predecessors(7))) - sum(
...     (mincostFlow[7][v] for v in G.successors(7))
... )
&gt;&gt;&gt; mincostFlowValue == nx.maximum_flow_value(G, 1, 7)
True</pre> 
</div>
</div>
<a id="a891a006d4dc407fcf160c6d6be7e66d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891a006d4dc407fcf160c6d6be7e66d4">&#9670;&nbsp;</a></span>min_cost_flow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.flow.mincost.min_cost_flow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>demand</em> = <code>&quot;demand&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>&quot;capacity&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a minimum cost flow satisfying all demands in digraph G.

G is a digraph with edge costs and capacities and in which nodes
have demand, i.e., they want to send or receive some amount of
flow. A negative demand means that the node wants to send flow, a
positive demand means that the node want to receive flow. A flow on
the digraph G satisfies all demand if the net flow into each node
is equal to the demand of that node.

Parameters
----------
G : NetworkX graph
    DiGraph on which a minimum cost flow satisfying all demands is
    to be found.

demand : string
    Nodes of the graph G are expected to have an attribute demand
    that indicates how much flow a node wants to send (negative
    demand) or receive (positive demand). Note that the sum of the
    demands should be 0 otherwise the problem in not feasible. If
    this attribute is not present, a node is considered to have 0
    demand. Default value: 'demand'.

capacity : string
    Edges of the graph G are expected to have an attribute capacity
    that indicates how much flow the edge can support. If this
    attribute is not present, the edge is considered to have
    infinite capacity. Default value: 'capacity'.

weight : string
    Edges of the graph G are expected to have an attribute weight
    that indicates the cost incurred by sending one unit of flow on
    that edge. If not present, the weight is considered to be 0.
    Default value: 'weight'.

Returns
-------
flowDict : dictionary
    Dictionary of dictionaries keyed by nodes such that
    flowDict[u][v] is the flow edge (u, v).

Raises
------
NetworkXError
    This exception is raised if the input graph is not directed or
    not connected.

NetworkXUnfeasible
    This exception is raised in the following situations:

        * The sum of the demands is not zero. Then, there is no
          flow satisfying all demands.
        * There is no flow satisfying all demand.

NetworkXUnbounded
    This exception is raised if the digraph G has a cycle of
    negative cost and infinite capacity. Then, the cost of a flow
    satisfying all demands is unbounded below.

See also
--------
cost_of_flow, max_flow_min_cost, min_cost_flow_cost, network_simplex

Notes
-----
This algorithm is not guaranteed to work if edge weights or demands
are floating point numbers (overflows and roundoff errors can
cause problems). As a workaround you can use integer numbers by
multiplying the relevant edge attributes by a convenient
constant factor (eg 100).

Examples
--------
A simple example of a min cost flow problem.

&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_node("a", demand=-5)
&gt;&gt;&gt; G.add_node("d", demand=5)
&gt;&gt;&gt; G.add_edge("a", "b", weight=3, capacity=4)
&gt;&gt;&gt; G.add_edge("a", "c", weight=6, capacity=10)
&gt;&gt;&gt; G.add_edge("b", "d", weight=1, capacity=9)
&gt;&gt;&gt; G.add_edge("c", "d", weight=2, capacity=5)
&gt;&gt;&gt; flowDict = nx.min_cost_flow(G)
</pre> 
</div>
</div>
<a id="aeb9bc47d477c57c0b0bd04161bae05bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9bc47d477c57c0b0bd04161bae05bc">&#9670;&nbsp;</a></span>min_cost_flow_cost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.flow.mincost.min_cost_flow_cost </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>demand</em> = <code>&quot;demand&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>&quot;capacity&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the cost of a minimum cost flow satisfying all demands in digraph G.

G is a digraph with edge costs and capacities and in which nodes
have demand, i.e., they want to send or receive some amount of
flow. A negative demand means that the node wants to send flow, a
positive demand means that the node want to receive flow. A flow on
the digraph G satisfies all demand if the net flow into each node
is equal to the demand of that node.

Parameters
----------
G : NetworkX graph
    DiGraph on which a minimum cost flow satisfying all demands is
    to be found.

demand : string
    Nodes of the graph G are expected to have an attribute demand
    that indicates how much flow a node wants to send (negative
    demand) or receive (positive demand). Note that the sum of the
    demands should be 0 otherwise the problem in not feasible. If
    this attribute is not present, a node is considered to have 0
    demand. Default value: 'demand'.

capacity : string
    Edges of the graph G are expected to have an attribute capacity
    that indicates how much flow the edge can support. If this
    attribute is not present, the edge is considered to have
    infinite capacity. Default value: 'capacity'.

weight : string
    Edges of the graph G are expected to have an attribute weight
    that indicates the cost incurred by sending one unit of flow on
    that edge. If not present, the weight is considered to be 0.
    Default value: 'weight'.

Returns
-------
flowCost : integer, float
    Cost of a minimum cost flow satisfying all demands.

Raises
------
NetworkXError
    This exception is raised if the input graph is not directed or
    not connected.

NetworkXUnfeasible
    This exception is raised in the following situations:

        * The sum of the demands is not zero. Then, there is no
          flow satisfying all demands.
        * There is no flow satisfying all demand.

NetworkXUnbounded
    This exception is raised if the digraph G has a cycle of
    negative cost and infinite capacity. Then, the cost of a flow
    satisfying all demands is unbounded below.

See also
--------
cost_of_flow, max_flow_min_cost, min_cost_flow, network_simplex

Notes
-----
This algorithm is not guaranteed to work if edge weights or demands
are floating point numbers (overflows and roundoff errors can
cause problems). As a workaround you can use integer numbers by
multiplying the relevant edge attributes by a convenient
constant factor (eg 100).

Examples
--------
A simple example of a min cost flow problem.

&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_node("a", demand=-5)
&gt;&gt;&gt; G.add_node("d", demand=5)
&gt;&gt;&gt; G.add_edge("a", "b", weight=3, capacity=4)
&gt;&gt;&gt; G.add_edge("a", "c", weight=6, capacity=10)
&gt;&gt;&gt; G.add_edge("b", "d", weight=1, capacity=9)
&gt;&gt;&gt; G.add_edge("c", "d", weight=2, capacity=5)
&gt;&gt;&gt; flowCost = nx.min_cost_flow_cost(G)
&gt;&gt;&gt; flowCost
24
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
