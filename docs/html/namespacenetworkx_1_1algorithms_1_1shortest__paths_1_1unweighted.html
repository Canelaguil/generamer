<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.shortest_paths.unweighted Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths.html">shortest_paths</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1unweighted.html">unweighted</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.shortest_paths.unweighted Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab8850fb3b6673b6b89af23eab6c72b6f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1unweighted.html#ab8850fb3b6673b6b89af23eab6c72b6f">single_source_shortest_path_length</a> (G, source, cutoff=None)</td></tr>
<tr class="separator:ab8850fb3b6673b6b89af23eab6c72b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5fa6d9513e007e37df23b6d53bedbb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1unweighted.html#a0e5fa6d9513e007e37df23b6d53bedbb">single_target_shortest_path_length</a> (G, target, cutoff=None)</td></tr>
<tr class="separator:a0e5fa6d9513e007e37df23b6d53bedbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9260ea54a81be0a03461317aa4622be"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1unweighted.html#ac9260ea54a81be0a03461317aa4622be">all_pairs_shortest_path_length</a> (G, cutoff=None)</td></tr>
<tr class="separator:ac9260ea54a81be0a03461317aa4622be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ec04fdd8442bb9261c266a31a75f75"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1unweighted.html#aa5ec04fdd8442bb9261c266a31a75f75">bidirectional_shortest_path</a> (G, source, target)</td></tr>
<tr class="separator:aa5ec04fdd8442bb9261c266a31a75f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f1b06d8b948cf3dc4d6e1a22e81211"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1unweighted.html#a38f1b06d8b948cf3dc4d6e1a22e81211">single_source_shortest_path</a> (G, source, cutoff=None)</td></tr>
<tr class="separator:a38f1b06d8b948cf3dc4d6e1a22e81211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a81a0f62206e34a3087502c69041446"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1unweighted.html#a0a81a0f62206e34a3087502c69041446">single_target_shortest_path</a> (G, target, cutoff=None)</td></tr>
<tr class="separator:a0a81a0f62206e34a3087502c69041446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80914ca8e34b5cc1623e739b6e4eba82"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1unweighted.html#a80914ca8e34b5cc1623e739b6e4eba82">all_pairs_shortest_path</a> (G, cutoff=None)</td></tr>
<tr class="separator:a80914ca8e34b5cc1623e739b6e4eba82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d99327e99d49d8179e7b60fd48740a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1shortest__paths_1_1unweighted.html#a7d99327e99d49d8179e7b60fd48740a7">predecessor</a> (G, source, target=None, cutoff=None, return_seen=None)</td></tr>
<tr class="separator:a7d99327e99d49d8179e7b60fd48740a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Shortest path algorithms for unweighted graphs.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a80914ca8e34b5cc1623e739b6e4eba82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80914ca8e34b5cc1623e739b6e4eba82">&#9670;&nbsp;</a></span>all_pairs_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.unweighted.all_pairs_shortest_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest paths between all nodes.

Parameters
----------
G : NetworkX graph

cutoff : integer, optional
    Depth at which to stop the search. Only paths of length at most
    `cutoff` are returned.

Returns
-------
lengths : dictionary
    Dictionary, keyed by source and target, of shortest paths.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; path = dict(nx.all_pairs_shortest_path(G))
&gt;&gt;&gt; print(path[0][4])
[0, 1, 2, 3, 4]

See Also
--------
floyd_warshall</pre> 
</div>
</div>
<a id="ac9260ea54a81be0a03461317aa4622be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9260ea54a81be0a03461317aa4622be">&#9670;&nbsp;</a></span>all_pairs_shortest_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.unweighted.all_pairs_shortest_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Computes the shortest path lengths between all nodes in `G`.

Parameters
----------
G : NetworkX graph

cutoff : integer, optional
    Depth at which to stop the search. Only paths of length at most
    `cutoff` are returned.

Returns
-------
lengths : iterator
    (source, dictionary) iterator with dictionary keyed by target and
    shortest path length as the key value.

Notes
-----
The iterator returned only has reachable node pairs.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length = dict(nx.all_pairs_shortest_path_length(G))
&gt;&gt;&gt; for node in [0, 1, 2, 3, 4]:
...     print(f"1 - {node}: {length[1][node]}")
1 - 0: 1
1 - 1: 0
1 - 2: 1
1 - 3: 2
1 - 4: 3
&gt;&gt;&gt; length[3][2]
1
&gt;&gt;&gt; length[2][2]
0</pre> 
</div>
</div>
<a id="aa5ec04fdd8442bb9261c266a31a75f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ec04fdd8442bb9261c266a31a75f75">&#9670;&nbsp;</a></span>bidirectional_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.unweighted.bidirectional_shortest_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of nodes in a shortest path between source and target.

Parameters
----------
G : NetworkX graph

source : node label
   starting node for path

target : node label
   ending node for path

Returns
-------
path: list
   List of nodes in a path from source to target.

Raises
------
NetworkXNoPath
   If no path exists between source and target.

See Also
--------
shortest_path

Notes
-----
This algorithm is used by shortest_path(G, source, target).
</pre> 
</div>
</div>
<a id="a7d99327e99d49d8179e7b60fd48740a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d99327e99d49d8179e7b60fd48740a7">&#9670;&nbsp;</a></span>predecessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.unweighted.predecessor </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>return_seen</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns dict of predecessors for the path from source to all nodes in G


Parameters
----------
G : NetworkX graph

source : node label
   Starting node for path

target : node label, optional
   Ending node for path. If provided only predecessors between
   source and target are returned

cutoff : integer, optional
    Depth to stop the search. Only paths of length &lt;= cutoff are returned.


Returns
-------
pred : dictionary
    Dictionary, keyed by node, of predecessors in the shortest path.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; list(G)
[0, 1, 2, 3]
&gt;&gt;&gt; nx.predecessor(G, 0)
{0: [], 1: [0], 2: [1], 3: [2]}</pre> 
</div>
</div>
<a id="a38f1b06d8b948cf3dc4d6e1a22e81211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f1b06d8b948cf3dc4d6e1a22e81211">&#9670;&nbsp;</a></span>single_source_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.unweighted.single_source_shortest_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest path between source
and all other nodes reachable from source.

Parameters
----------
G : NetworkX graph

source : node label
   Starting node for path

cutoff : integer, optional
    Depth to stop the search. Only paths of length &lt;= cutoff are returned.

Returns
-------
lengths : dictionary
    Dictionary, keyed by target, of shortest paths.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; path = nx.single_source_shortest_path(G, 0)
&gt;&gt;&gt; path[4]
[0, 1, 2, 3, 4]

Notes
-----
The shortest path is not necessarily unique. So there can be multiple
paths between the source and each target node, all of which have the
same 'shortest' length. For each target node, this function returns
only one of those paths.

See Also
--------
shortest_path
</pre> 
</div>
</div>
<a id="ab8850fb3b6673b6b89af23eab6c72b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8850fb3b6673b6b89af23eab6c72b6f">&#9670;&nbsp;</a></span>single_source_shortest_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.unweighted.single_source_shortest_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the shortest path lengths from source to all reachable nodes.

Parameters
----------
G : NetworkX graph

source : node
   Starting node for path

cutoff : integer, optional
    Depth to stop the search. Only paths of length &lt;= cutoff are returned.

Returns
-------
lengths : dict
    Dict keyed by node to shortest path length to source.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5)
&gt;&gt;&gt; length = nx.single_source_shortest_path_length(G, 0)
&gt;&gt;&gt; length[4]
4
&gt;&gt;&gt; for node in length:
...     print(f"{node}: {length[node]}")
0: 0
1: 1
2: 2
3: 3
4: 4

See Also
--------
shortest_path_length
</pre> 
</div>
</div>
<a id="a0a81a0f62206e34a3087502c69041446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a81a0f62206e34a3087502c69041446">&#9670;&nbsp;</a></span>single_target_shortest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.unweighted.single_target_shortest_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute shortest path to target from all nodes that reach target.

Parameters
----------
G : NetworkX graph

target : node label
   Target node for path

cutoff : integer, optional
    Depth to stop the search. Only paths of length &lt;= cutoff are returned.

Returns
-------
lengths : dictionary
    Dictionary, keyed by target, of shortest paths.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5, create_using=nx.DiGraph())
&gt;&gt;&gt; path = nx.single_target_shortest_path(G, 4)
&gt;&gt;&gt; path[0]
[0, 1, 2, 3, 4]

Notes
-----
The shortest path is not necessarily unique. So there can be multiple
paths between the source and each target node, all of which have the
same 'shortest' length. For each target node, this function returns
only one of those paths.

See Also
--------
shortest_path, single_source_shortest_path
</pre> 
</div>
</div>
<a id="a0e5fa6d9513e007e37df23b6d53bedbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5fa6d9513e007e37df23b6d53bedbb">&#9670;&nbsp;</a></span>single_target_shortest_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.shortest_paths.unweighted.single_target_shortest_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the shortest path lengths to target from all reachable nodes.

Parameters
----------
G : NetworkX graph

target : node
   Target node for path

cutoff : integer, optional
    Depth to stop the search. Only paths of length &lt;= cutoff are returned.

Returns
-------
lengths : iterator
    (source, shortest path length) iterator

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(5, create_using=nx.DiGraph())
&gt;&gt;&gt; length = dict(nx.single_target_shortest_path_length(G, 4))
&gt;&gt;&gt; length[0]
4
&gt;&gt;&gt; for node in range(5):
...     print(f"{node}: {length[node]}")
0: 4
1: 3
2: 2
3: 1
4: 0

See Also
--------
single_source_shortest_path_length, shortest_path_length
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
