<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.summarization Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1summarization.html">summarization</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.summarization Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a76e504c9155b6b0e797ed530ff73d0a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1summarization.html#a76e504c9155b6b0e797ed530ff73d0a7">dedensify</a> (G, threshold, prefix=None, copy=True)</td></tr>
<tr class="separator:a76e504c9155b6b0e797ed530ff73d0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0445ab90444d00989bb2e81c66a90370"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1summarization.html#a0445ab90444d00989bb2e81c66a90370">snap_aggregation</a> (G, node_attributes, edge_attributes=(), prefix=&quot;Supernode-&quot;, supernode_attribute=&quot;group&quot;, superedge_attribute=&quot;types&quot;)</td></tr>
<tr class="separator:a0445ab90444d00989bb2e81c66a90370"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Graph summarization finds smaller representations of graphs resulting in faster
runtime of algorithms, reduced storage needs, and noise reduction.
Summarization has applications in areas such as visualization, pattern mining,
clustering and community detection, and more.  Core graph summarization
techniques are grouping/aggregation, bit-compression,
simplification/sparsification, and influence based. Graph summarization
algorithms often produce either summary graphs in the form of supergraphs or
sparsified graphs, or a list of independent structures. Supergraphs are the
most common product, which consist of supernodes and original nodes and are
connected by edges and superedges, which represent aggregate edges between
nodes and supernodes.

Grouping/aggregation based techniques compress graphs by representing
close/connected nodes and edges in a graph by a single node/edge in a
supergraph. Nodes can be grouped together into supernodes based on their
structural similarities or proximity within a graph to reduce the total number
of nodes in a graph. Edge-grouping techniques group edges into lossy/lossless
nodes called compressor or virtual nodes to reduce the total number of edges in
a graph. Edge-grouping techniques can be lossless, meaning that they can be
used to re-create the original graph, or techniques can be lossy, requiring
less space to store the summary graph, but at the expense of lower
recontruction accuracy of the original graph.

Bit-compression techniques minimize the amount of information needed to
describe the original graph, while revealing structural patterns in the
original graph.  The two-part minimum description length (MDL) is often used to
represent the model and the original graph in terms of the model.  A key
difference between graph compression and graph summarization is that graph
summarization focuses on finding structural patterns within the original graph,
whereas graph compression focuses on compressions the original graph to be as
small as possible.  **NOTE**: Some bit-compression methods exist solely to
compress a graph without creating a summary graph or finding comprehensible
structural patterns.

Simplification/Sparsification techniques attempt to create a sparse
representation of a graph by removing unimportant nodes and edges from the
graph.  Sparsified graphs differ from supergraphs created by
grouping/aggregation by only containing a subset of the original nodes and
edges of the original graph.

Influence based techniques aim to find a high-level description of influence
propagation in a large graph.  These methods are scarce and have been mostly
applied to social graphs.

*dedensification* is a grouping/aggregation based technique to compress the
neighborhoods around high-degree nodes in unweighted graphs by adding
compressor nodes that summarize multiple edges of the same type to
high-degree nodes (nodes with a degree greater than a given threshold).
Dedensification was developed for the purpose of increasing performance of
query processing around high-degree nodes in graph databases and enables direct
operations on the compressed graph.  The structural patterns surrounding
high-degree nodes in the original is preserved while using fewer edges and
adding a small number of compressor nodes.  The degree of nodes present in the
original graph is also preserved. The current implementation of dedensification
supports graphs with one edge type.

For more information on graph summarization, see `Graph Summarization Methods
and Applications: A Survey &lt;https://dl.acm.org/doi/abs/10.1145/3186727&gt;`_
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a76e504c9155b6b0e797ed530ff73d0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e504c9155b6b0e797ed530ff73d0a7">&#9670;&nbsp;</a></span>dedensify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.summarization.dedensify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compresses neighborhoods around high-degree nodes

Reduces the number of edges to high-degree nodes by adding compressor nodes
that summarize multiple edges of the same type to high-degree nodes (nodes
with a degree greater than a given threshold).  Dedensification also has
the added benefit of reducing the number of edges around high-degree nodes.
The implementation currently supports graphs with a single edge type.

Parameters
----------
G: graph
   A networkx graph
threshold: int
   Minimum degree threshold of a node to be considered a high degree node.
   The threshold must be greater than or equal to 2.
prefix: str or None, optional (default: None)
   An optional prefix for denoting compressor nodes
copy: bool, optional (default: True)
   Indicates if dedensification should be done inplace

Returns
-------
dedensified networkx graph : (graph, set)
    2-tuple of the dedensified graph and set of compressor nodes

Notes
-----
According to the algorithm in [1]_, removes edges in a graph by
compressing/decompressing the neighborhoods around high degree nodes by
adding compressor nodes that summarize multiple edges of the same type
to high-degree nodes.  Dedensification will only add a compressor node when
doing so will reduce the total number of edges in the given graph. This
implementation currently supports graphs with a single edge type.

Examples
--------
Dedensification will only add compressor nodes when doing so would result
in fewer edges::

    &gt;&gt;&gt; original_graph = nx.DiGraph()
    &gt;&gt;&gt; original_graph.add_nodes_from(
    ...     ["1", "2", "3", "4", "5", "6", "A", "B", "C"]
    ... )
    &gt;&gt;&gt; original_graph.add_edges_from(
    ...     [
    ...         ("1", "C"), ("1", "B"),
    ...         ("2", "C"), ("2", "B"), ("2", "A"),
    ...         ("3", "B"), ("3", "A"), ("3", "6"),
    ...         ("4", "C"), ("4", "B"), ("4", "A"),
    ...         ("5", "B"), ("5", "A"),
    ...         ("6", "5"),
    ...         ("A", "6")
    ...     ]
    ... )
    &gt;&gt;&gt; c_graph, c_nodes = nx.dedensify(original_graph, threshold=2)
    &gt;&gt;&gt; original_graph.number_of_edges()
    15
    &gt;&gt;&gt; c_graph.number_of_edges()
    14

A dedensified, directed graph can be "densified" to reconstruct the
original graph::

    &gt;&gt;&gt; original_graph = nx.DiGraph()
    &gt;&gt;&gt; original_graph.add_nodes_from(
    ...     ["1", "2", "3", "4", "5", "6", "A", "B", "C"]
    ... )
    &gt;&gt;&gt; original_graph.add_edges_from(
    ...     [
    ...         ("1", "C"), ("1", "B"),
    ...         ("2", "C"), ("2", "B"), ("2", "A"),
    ...         ("3", "B"), ("3", "A"), ("3", "6"),
    ...         ("4", "C"), ("4", "B"), ("4", "A"),
    ...         ("5", "B"), ("5", "A"),
    ...         ("6", "5"),
    ...         ("A", "6")
    ...     ]
    ... )
    &gt;&gt;&gt; c_graph, c_nodes = nx.dedensify(original_graph, threshold=2)
    &gt;&gt;&gt; # re-densifies the compressed graph into the original graph
    &gt;&gt;&gt; for c_node in c_nodes:
    ...     all_neighbors = set(nx.all_neighbors(c_graph, c_node))
    ...     out_neighbors = set(c_graph.neighbors(c_node))
    ...     for out_neighbor in out_neighbors:
    ...         c_graph.remove_edge(c_node, out_neighbor)
    ...     in_neighbors = all_neighbors - out_neighbors
    ...     for in_neighbor in in_neighbors:
    ...         c_graph.remove_edge(in_neighbor, c_node)
    ...         for out_neighbor in out_neighbors:
    ...             c_graph.add_edge(in_neighbor, out_neighbor)
    ...     c_graph.remove_node(c_node)
    ...
    &gt;&gt;&gt; nx.is_isomorphic(original_graph, c_graph)
    True

References
----------
.. [1] Maccioni, A., &amp; Abadi, D. J. (2016, August).
   Scalable pattern matching over compressed graphs via dedensification.
   In Proceedings of the 22nd ACM SIGKDD International Conference on
   Knowledge Discovery and Data Mining (pp. 1755-1764).
   http://www.cs.umd.edu/~abadi/papers/graph-dedense.pdf
</pre> 
</div>
</div>
<a id="a0445ab90444d00989bb2e81c66a90370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0445ab90444d00989bb2e81c66a90370">&#9670;&nbsp;</a></span>snap_aggregation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.summarization.snap_aggregation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node_attributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_attributes</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prefix</em> = <code>&quot;Supernode-&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>supernode_attribute</em> = <code>&quot;group&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>superedge_attribute</em> = <code>&quot;types&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a summary graph based on attributes and connectivity.

This function uses the Summarization by Grouping Nodes on Attributes
and Pairwise edges (SNAP) algorithm for summarizing a given
graph by grouping nodes by node attributes and their edge attributes
into supernodes in a summary graph.  This name SNAP should not be
confused with the Stanford Network Analysis Project (SNAP).

Here is a high-level view of how this algorithm works:

1) Group nodes by node attribute values.

2) Iteratively split groups until all nodes in each group have edges
to nodes in the same groups. That is, until all the groups are homogeneous
in their member nodes' edges to other groups.  For example,
if all the nodes in group A only have edge to nodes in group B, then the
group is homogeneous and does not need to be split. If all nodes in group B
have edges with nodes in groups {A, C}, but some also have edges with other
nodes in B, then group B is not homogeneous and needs to be split into
groups have edges with {A, C} and a group of nodes having
edges with {A, B, C}.  This way, viewers of the summary graph can
assume that all nodes in the group have the exact same node attributes and
the exact same edges.

3) Build the output summary graph, where the groups are represented by
super-nodes. Edges represent the edges shared between all the nodes in each
respective groups.

A SNAP summary graph can be used to visualize graphs that are too large to display
or visually analyze, or to efficiently identify sets of similar nodes with similar connectivity
patterns to other sets of similar nodes based on specified node and/or edge attributes in a graph.

Parameters
----------
G: graph
    Networkx Graph to be summarized
edge_attributes: iterable, optional
    An iterable of the edge attributes considered in the summarization process.  If provided, unique
    combinations of the attribute values found in the graph are used to
    determine the edge types in the graph.  If not provided, all edges
    are considered to be of the same type.
prefix: str
    The prefix used to denote supernodes in the summary graph. Defaults to 'Supernode-'.
supernode_attribute: str
    The node attribute for recording the supernode groupings of nodes. Defaults to 'group'.
superedge_attribute: str
    The edge attribute for recording the edge types of multiple edges. Defaults to 'types'.

Returns
-------
networkx.Graph: summary graph

Examples
--------
SNAP aggregation takes a graph and summarizes it in the context of user-provided
node and edge attributes such that a viewer can more easily extract and
analyze the information represented by the graph

&gt;&gt;&gt; nodes = {
...     "A": dict(color="Red"),
...     "B": dict(color="Red"),
...     "C": dict(color="Red"),
...     "D": dict(color="Red"),
...     "E": dict(color="Blue"),
...     "F": dict(color="Blue"),
... }
&gt;&gt;&gt; edges = [
...     ("A", "E", "Strong"),
...     ("B", "F", "Strong"),
...     ("C", "E", "Weak"),
...     ("D", "F", "Weak"),
... ]
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; for node in nodes:
...     attributes = nodes[node]
...     G.add_node(node, **attributes)
...
&gt;&gt;&gt; for source, target, type in edges:
...     G.add_edge(source, target, type=type)
...
&gt;&gt;&gt; node_attributes = ('color', )
&gt;&gt;&gt; edge_attributes = ('type', )
&gt;&gt;&gt; summary_graph = nx.snap_aggregation(G, node_attributes=node_attributes, edge_attributes=edge_attributes)

Notes
-----
The summary graph produced is called a maximum Attribute-edge
compatible (AR-compatible) grouping.  According to [1]_, an
AR-compatible grouping means that all nodes in each group have the same
exact node attribute values and the same exact edges and
edge types to one or more nodes in the same groups.  The maximal
AR-compatible grouping is the grouping with the minimal cardinality.

The AR-compatible grouping is the most detailed grouping provided by
any of the SNAP algorithms.

References
----------
.. [1] Y. Tian, R. A. Hankins, and J. M. Patel. Efficient aggregation
   for graph summarization. In Proc. 2008 ACM-SIGMOD Int. Conf.
   Management of Data (SIGMOD’08), pages 567–580, Vancouver, Canada,
   June 2008.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
