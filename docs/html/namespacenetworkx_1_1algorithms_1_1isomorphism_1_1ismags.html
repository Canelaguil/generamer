<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.isomorphism.ismags Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism.html">isomorphism</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1ismags.html">ismags</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.isomorphism.ismags Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1isomorphism_1_1ismags_1_1ISMAGS.html">ISMAGS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adeaeb2412166ed583ba1f5911656cd5e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1ismags.html#adeaeb2412166ed583ba1f5911656cd5e">are_all_equal</a> (iterable)</td></tr>
<tr class="separator:adeaeb2412166ed583ba1f5911656cd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0d10c0c3ce712095d568c54676d43b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1ismags.html#a8a0d10c0c3ce712095d568c54676d43b">make_partitions</a> (items, test)</td></tr>
<tr class="separator:a8a0d10c0c3ce712095d568c54676d43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9231036839a88c188ab79f4f2b123362"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1ismags.html#a9231036839a88c188ab79f4f2b123362">partition_to_color</a> (partitions)</td></tr>
<tr class="separator:a9231036839a88c188ab79f4f2b123362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac307ece4bd5b6920883130d6f3c1145"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1ismags.html#aac307ece4bd5b6920883130d6f3c1145">intersect</a> (collection_of_sets)</td></tr>
<tr class="separator:aac307ece4bd5b6920883130d6f3c1145"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">****************
ISMAGS Algorithm
****************

Provides a Python implementation of the ISMAGS algorithm. [1]_

It is capable of finding (subgraph) isomorphisms between two graphs, taking the
symmetry of the subgraph into account. In most cases the VF2 algorithm is
faster (at least on small graphs) than this implementation, but in some cases
there is an exponential number of isomorphisms that are symmetrically
equivalent. In that case, the ISMAGS algorithm will provide only one solution
per symmetry group.

&gt;&gt;&gt; petersen = nx.petersen_graph()
&gt;&gt;&gt; ismags = nx.isomorphism.ISMAGS(petersen, petersen)
&gt;&gt;&gt; isomorphisms = list(ismags.isomorphisms_iter(symmetry=False))
&gt;&gt;&gt; len(isomorphisms)
120
&gt;&gt;&gt; isomorphisms = list(ismags.isomorphisms_iter(symmetry=True))
&gt;&gt;&gt; answer = [{0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9}]
&gt;&gt;&gt; answer == isomorphisms
True

In addition, this implementation also provides an interface to find the
largest common induced subgraph [2]_ between any two graphs, again taking
symmetry into account. Given `graph` and `subgraph` the algorithm will remove
nodes from the `subgraph` until `subgraph` is isomorphic to a subgraph of
`graph`. Since only the symmetry of `subgraph` is taken into account it is
worth thinking about how you provide your graphs:

&gt;&gt;&gt; graph1 = nx.path_graph(4)
&gt;&gt;&gt; graph2 = nx.star_graph(3)
&gt;&gt;&gt; ismags = nx.isomorphism.ISMAGS(graph1, graph2)
&gt;&gt;&gt; ismags.is_isomorphic()
False
&gt;&gt;&gt; largest_common_subgraph = list(ismags.largest_common_subgraph())
&gt;&gt;&gt; answer = [{1: 0, 0: 1, 2: 2}, {2: 0, 1: 1, 3: 2}]
&gt;&gt;&gt; answer == largest_common_subgraph
True
&gt;&gt;&gt; ismags2 = nx.isomorphism.ISMAGS(graph2, graph1)
&gt;&gt;&gt; largest_common_subgraph = list(ismags2.largest_common_subgraph())
&gt;&gt;&gt; answer = [
...     {1: 0, 0: 1, 2: 2},
...     {1: 0, 0: 1, 3: 2},
...     {2: 0, 0: 1, 1: 2},
...     {2: 0, 0: 1, 3: 2},
...     {3: 0, 0: 1, 1: 2},
...     {3: 0, 0: 1, 2: 2},
... ]
&gt;&gt;&gt; answer == largest_common_subgraph
True

However, when not taking symmetry into account, it doesn't matter:

&gt;&gt;&gt; largest_common_subgraph = list(ismags.largest_common_subgraph(symmetry=False))
&gt;&gt;&gt; answer = [
...     {1: 0, 0: 1, 2: 2},
...     {1: 0, 2: 1, 0: 2},
...     {2: 0, 1: 1, 3: 2},
...     {2: 0, 3: 1, 1: 2},
...     {1: 0, 0: 1, 2: 3},
...     {1: 0, 2: 1, 0: 3},
...     {2: 0, 1: 1, 3: 3},
...     {2: 0, 3: 1, 1: 3},
...     {1: 0, 0: 2, 2: 3},
...     {1: 0, 2: 2, 0: 3},
...     {2: 0, 1: 2, 3: 3},
...     {2: 0, 3: 2, 1: 3},
... ]
&gt;&gt;&gt; answer == largest_common_subgraph
True
&gt;&gt;&gt; largest_common_subgraph = list(ismags2.largest_common_subgraph(symmetry=False))
&gt;&gt;&gt; answer = [
...     {1: 0, 0: 1, 2: 2},
...     {1: 0, 0: 1, 3: 2},
...     {2: 0, 0: 1, 1: 2},
...     {2: 0, 0: 1, 3: 2},
...     {3: 0, 0: 1, 1: 2},
...     {3: 0, 0: 1, 2: 2},
...     {1: 1, 0: 2, 2: 3},
...     {1: 1, 0: 2, 3: 3},
...     {2: 1, 0: 2, 1: 3},
...     {2: 1, 0: 2, 3: 3},
...     {3: 1, 0: 2, 1: 3},
...     {3: 1, 0: 2, 2: 3},
... ]
&gt;&gt;&gt; answer == largest_common_subgraph
True

Notes
-----
 - The current implementation works for undirected graphs only. The algorithm
   in general should work for directed graphs as well though.
 - Node keys for both provided graphs need to be fully orderable as well as
   hashable.
 - Node and edge equality is assumed to be transitive: if A is equal to B, and
   B is equal to C, then A is equal to C.

References
----------
.. [1] M. Houbraken, S. Demeyer, T. Michoel, P. Audenaert, D. Colle,
   M. Pickavet, "The Index-Based Subgraph Matching Algorithm with General
   Symmetries (ISMAGS): Exploiting Symmetry for Faster Subgraph
   Enumeration", PLoS One 9(5): e97896, 2014.
   https://doi.org/10.1371/journal.pone.0097896
.. [2] https://en.wikipedia.org/wiki/Maximum_common_induced_subgraph
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="adeaeb2412166ed583ba1f5911656cd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeaeb2412166ed583ba1f5911656cd5e">&#9670;&nbsp;</a></span>are_all_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.ismags.are_all_equal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns ``True`` if and only if all elements in `iterable` are equal; and
``False`` otherwise.

Parameters
----------
iterable: collections.abc.Iterable
    The container whose elements will be checked.

Returns
-------
bool
    ``True`` iff all elements in `iterable` compare equal, ``False``
    otherwise.
</pre> 
</div>
</div>
<a id="aac307ece4bd5b6920883130d6f3c1145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac307ece4bd5b6920883130d6f3c1145">&#9670;&nbsp;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.ismags.intersect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>collection_of_sets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given an collection of sets, returns the intersection of those sets.

Parameters
----------
collection_of_sets: collections.abc.Collection[set]
    A collection of sets.

Returns
-------
set
    An intersection of all sets in `collection_of_sets`. Will have the same
    type as the item initially taken from `collection_of_sets`.
</pre> 
</div>
</div>
<a id="a8a0d10c0c3ce712095d568c54676d43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0d10c0c3ce712095d568c54676d43b">&#9670;&nbsp;</a></span>make_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.ismags.make_partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Partitions items into sets based on the outcome of ``test(item1, item2)``.
Pairs of items for which `test` returns `True` end up in the same set.

Parameters
----------
items : collections.abc.Iterable[collections.abc.Hashable]
    Items to partition
test : collections.abc.Callable[collections.abc.Hashable, collections.abc.Hashable]
    A function that will be called with 2 arguments, taken from items.
    Should return `True` if those 2 items need to end up in the same
    partition, and `False` otherwise.

Returns
-------
list[set]
    A list of sets, with each set containing part of the items in `items`,
    such that ``all(test(*pair) for pair in  itertools.combinations(set, 2))
    == True``

Notes
-----
The function `test` is assumed to be transitive: if ``test(a, b)`` and
``test(b, c)`` return ``True``, then ``test(a, c)`` must also be ``True``.
</pre> 
</div>
</div>
<a id="a9231036839a88c188ab79f4f2b123362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9231036839a88c188ab79f4f2b123362">&#9670;&nbsp;</a></span>partition_to_color()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.ismags.partition_to_color </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>partitions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Creates a dictionary with for every item in partition for every partition
in partitions the index of partition in partitions.

Parameters
----------
partitions: collections.abc.Sequence[collections.abc.Iterable]
    As returned by :func:`make_partitions`.

Returns
-------
dict
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
