<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: numpy.lib.nanfunctions Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib.html">lib</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html">nanfunctions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">numpy.lib.nanfunctions Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e2e3d5692a3b58cd6a1ec33af0789e0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a8e2e3d5692a3b58cd6a1ec33af0789e0">nanmin</a> (a, axis=None, out=None, keepdims=np._NoValue)</td></tr>
<tr class="separator:a8e2e3d5692a3b58cd6a1ec33af0789e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162941364126b496b7b4140a6fed4202"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a162941364126b496b7b4140a6fed4202">nanmax</a> (a, axis=None, out=None, keepdims=np._NoValue)</td></tr>
<tr class="separator:a162941364126b496b7b4140a6fed4202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835b6215d99db0102994600c63acb588"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a835b6215d99db0102994600c63acb588">nanargmin</a> (a, axis=None)</td></tr>
<tr class="separator:a835b6215d99db0102994600c63acb588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23fc5bd2a6de7b40b293243ed9cd95c7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a23fc5bd2a6de7b40b293243ed9cd95c7">nanargmax</a> (a, axis=None)</td></tr>
<tr class="separator:a23fc5bd2a6de7b40b293243ed9cd95c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763c827042a377c7ac967cd3b703694b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a763c827042a377c7ac967cd3b703694b">nansum</a> (a, axis=None, dtype=None, out=None, keepdims=np._NoValue)</td></tr>
<tr class="separator:a763c827042a377c7ac967cd3b703694b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5e7f7084f8d2535e4506776ac0c98f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a7c5e7f7084f8d2535e4506776ac0c98f">nanprod</a> (a, axis=None, dtype=None, out=None, keepdims=np._NoValue)</td></tr>
<tr class="separator:a7c5e7f7084f8d2535e4506776ac0c98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda36044421269514fdf5636cddb32a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#abda36044421269514fdf5636cddb32a0">nancumsum</a> (a, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:abda36044421269514fdf5636cddb32a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bccbe7cb1e5d6900166312043d34e14"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a0bccbe7cb1e5d6900166312043d34e14">nancumprod</a> (a, axis=None, dtype=None, out=None)</td></tr>
<tr class="separator:a0bccbe7cb1e5d6900166312043d34e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a625e2e39b5b888f941c359b85f962022"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a625e2e39b5b888f941c359b85f962022">nanmean</a> (a, axis=None, dtype=None, out=None, keepdims=np._NoValue)</td></tr>
<tr class="separator:a625e2e39b5b888f941c359b85f962022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8860b2b8666f170298c8e7c23cf592b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#ac8860b2b8666f170298c8e7c23cf592b">nanmedian</a> (a, axis=None, out=None, overwrite_input=False, keepdims=np._NoValue)</td></tr>
<tr class="separator:ac8860b2b8666f170298c8e7c23cf592b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb5edb6795a7ac5109de2579da1dc03"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a1fb5edb6795a7ac5109de2579da1dc03">nanpercentile</a> (a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=np._NoValue)</td></tr>
<tr class="separator:a1fb5edb6795a7ac5109de2579da1dc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb8de27a8087256d8205db0e4151bd4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a5eb8de27a8087256d8205db0e4151bd4">nanquantile</a> (a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=np._NoValue)</td></tr>
<tr class="separator:a5eb8de27a8087256d8205db0e4151bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74b1b732ed44e858f6610c2f8e09836"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#aa74b1b732ed44e858f6610c2f8e09836">nanvar</a> (a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue)</td></tr>
<tr class="separator:aa74b1b732ed44e858f6610c2f8e09836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb96436d04b671c696d194e3feb1317d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#acb96436d04b671c696d194e3feb1317d">nanstd</a> (a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue)</td></tr>
<tr class="separator:acb96436d04b671c696d194e3feb1317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5d66ace42e50dfe8f961bdaad0c9ff6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a5d66ace42e50dfe8f961bdaad0c9ff6e">array_function_dispatch</a></td></tr>
<tr class="separator:a5d66ace42e50dfe8f961bdaad0c9ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909a2bb150c1b122fe91d94ae7774659"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1lib_1_1nanfunctions.html#a909a2bb150c1b122fe91d94ae7774659">module</a></td></tr>
<tr class="separator:a909a2bb150c1b122fe91d94ae7774659"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions that ignore NaN.

Functions
---------

- `nanmin` -- minimum non-NaN value
- `nanmax` -- maximum non-NaN value
- `nanargmin` -- index of minimum non-NaN value
- `nanargmax` -- index of maximum non-NaN value
- `nansum` -- sum of non-NaN values
- `nanprod` -- product of non-NaN values
- `nancumsum` -- cumulative sum of non-NaN values
- `nancumprod` -- cumulative product of non-NaN values
- `nanmean` -- mean of non-NaN values
- `nanvar` -- variance of non-NaN values
- `nanstd` -- standard deviation of non-NaN values
- `nanmedian` -- median of non-NaN values
- `nanquantile` -- qth quantile of non-NaN values
- `nanpercentile` -- qth percentile of non-NaN values</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a23fc5bd2a6de7b40b293243ed9cd95c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23fc5bd2a6de7b40b293243ed9cd95c7">&#9670;&nbsp;</a></span>nanargmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanargmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices of the maximum values in the specified axis ignoring
NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the
results cannot be trusted if a slice contains only NaNs and -Infs.


Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which to operate.  By default flattened input is used.

Returns
-------
index_array : ndarray
    An array of indices or a single index value.

See Also
--------
argmax, nanargmin

Examples
--------
&gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])
&gt;&gt;&gt; np.argmax(a)
0
&gt;&gt;&gt; np.nanargmax(a)
1
&gt;&gt;&gt; np.nanargmax(a, axis=0)
array([1, 0])
&gt;&gt;&gt; np.nanargmax(a, axis=1)
array([1, 1])</pre> 
</div>
</div>
<a id="a835b6215d99db0102994600c63acb588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835b6215d99db0102994600c63acb588">&#9670;&nbsp;</a></span>nanargmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanargmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the indices of the minimum values in the specified axis ignoring
NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results
cannot be trusted if a slice contains only NaNs and Infs.

Parameters
----------
a : array_like
    Input data.
axis : int, optional
    Axis along which to operate.  By default flattened input is used.

Returns
-------
index_array : ndarray
    An array of indices or a single index value.

See Also
--------
argmin, nanargmax

Examples
--------
&gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])
&gt;&gt;&gt; np.argmin(a)
0
&gt;&gt;&gt; np.nanargmin(a)
2
&gt;&gt;&gt; np.nanargmin(a, axis=0)
array([1, 1])
&gt;&gt;&gt; np.nanargmin(a, axis=1)
array([1, 0])</pre> 
</div>
</div>
<a id="a0bccbe7cb1e5d6900166312043d34e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bccbe7cb1e5d6900166312043d34e14">&#9670;&nbsp;</a></span>nancumprod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nancumprod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the cumulative product of array elements over a given axis treating Not a
Numbers (NaNs) as one.  The cumulative product does not change when NaNs are
encountered and leading NaNs are replaced by ones.

Ones are returned for slices that are all-NaN or empty.

.. versionadded:: 1.12.0

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative product is computed.  By default
    the input is flattened.
dtype : dtype, optional
    Type of the returned array, as well as of the accumulator in which
    the elements are multiplied.  If *dtype* is not specified, it
    defaults to the dtype of `a`, unless `a` has an integer dtype with
    a precision less than that of the default platform integer.  In
    that case, the default platform integer is used instead.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type of the resulting values will be cast if necessary.

Returns
-------
nancumprod : ndarray
    A new array holding the result is returned unless `out` is
    specified, in which case it is returned.

See Also
--------
numpy.cumprod : Cumulative product across array propagating NaNs.
isnan : Show which elements are NaN.

Examples
--------
&gt;&gt;&gt; np.nancumprod(1)
array([1])
&gt;&gt;&gt; np.nancumprod([1])
array([1])
&gt;&gt;&gt; np.nancumprod([1, np.nan])
array([1.,  1.])
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nancumprod(a)
array([1.,  2.,  6.,  6.])
&gt;&gt;&gt; np.nancumprod(a, axis=0)
array([[1.,  2.],
       [3.,  2.]])
&gt;&gt;&gt; np.nancumprod(a, axis=1)
array([[1.,  2.],
       [3.,  3.]])</pre> 
</div>
</div>
<a id="abda36044421269514fdf5636cddb32a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda36044421269514fdf5636cddb32a0">&#9670;&nbsp;</a></span>nancumsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nancumsum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the cumulative sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.  The cumulative sum does not change when NaNs are
encountered and leading NaNs are replaced by zeros.

Zeros are returned for slices that are all-NaN or empty.

.. versionadded:: 1.12.0

Parameters
----------
a : array_like
    Input array.
axis : int, optional
    Axis along which the cumulative sum is computed. The default
    (None) is to compute the cumsum over the flattened array.
dtype : dtype, optional
    Type of the returned array and of the accumulator in which the
    elements are summed.  If `dtype` is not specified, it defaults
    to the dtype of `a`, unless `a` has an integer dtype with a
    precision less than that of the default platform integer.  In
    that case, the default platform integer is used.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output
    but the type will be cast if necessary. See :ref:`ufuncs-output-type` for
    more details.

Returns
-------
nancumsum : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which it is returned. The result has the same
    size as `a`, and the same shape as `a` if `axis` is not None
    or `a` is a 1-d array.

See Also
--------
numpy.cumsum : Cumulative sum across array propagating NaNs.
isnan : Show which elements are NaN.

Examples
--------
&gt;&gt;&gt; np.nancumsum(1)
array([1])
&gt;&gt;&gt; np.nancumsum([1])
array([1])
&gt;&gt;&gt; np.nancumsum([1, np.nan])
array([1.,  1.])
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nancumsum(a)
array([1.,  3.,  6.,  6.])
&gt;&gt;&gt; np.nancumsum(a, axis=0)
array([[1.,  2.],
       [4.,  2.]])
&gt;&gt;&gt; np.nancumsum(a, axis=1)
array([[1.,  3.],
       [3.,  3.]])</pre> 
</div>
</div>
<a id="a162941364126b496b7b4140a6fed4202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162941364126b496b7b4140a6fed4202">&#9670;&nbsp;</a></span>nanmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the maximum of an array or maximum along an axis, ignoring any
NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is
raised and NaN is returned for that slice.

Parameters
----------
a : array_like
    Array containing numbers whose maximum is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the maximum is computed. The default is to compute
    the maximum of the flattened array.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    :ref:`ufuncs-output-type` for more details.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If the value is anything but the default, then
    `keepdims` will be passed through to the `max` method
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

    .. versionadded:: 1.8.0

Returns
-------
nanmax : ndarray
    An array with the same shape as `a`, with the specified axis removed.
    If `a` is a 0-d array, or if axis is None, an ndarray scalar is
    returned.  The same dtype as `a` is returned.

See Also
--------
nanmin :
    The minimum value of an array along a given axis, ignoring any NaNs.
amax :
    The maximum value of an array along a given axis, propagating any NaNs.
fmax :
    Element-wise maximum of two arrays, ignoring any NaNs.
maximum :
    Element-wise maximum of two arrays, propagating any NaNs.
isnan :
    Shows which elements are Not a Number (NaN).
isfinite:
    Shows which elements are neither NaN nor infinity.

amin, fmin, minimum

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.

If the input has a integer type the function is equivalent to np.max.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanmax(a)
3.0
&gt;&gt;&gt; np.nanmax(a, axis=0)
array([3.,  2.])
&gt;&gt;&gt; np.nanmax(a, axis=1)
array([2.,  3.])

When positive infinity and negative infinity are present:

&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.NINF])
2.0
&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.inf])
inf</pre> 
</div>
</div>
<a id="a625e2e39b5b888f941c359b85f962022"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a625e2e39b5b888f941c359b85f962022">&#9670;&nbsp;</a></span>nanmean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanmean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the arithmetic mean along the specified axis, ignoring NaNs.

Returns the average of the array elements.  The average is taken over
the flattened array by default, otherwise over the specified axis.
`float64` intermediate and return values are used for integer inputs.

For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array containing numbers whose mean is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the means are computed. The default is to compute
    the mean of the flattened array.
dtype : data-type, optional
    Type to use in computing the mean.  For integer inputs, the default
    is `float64`; for inexact inputs, it is the same as the input
    dtype.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    :ref:`ufuncs-output-type` for more details.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If the value is anything but the default, then
    `keepdims` will be passed through to the `mean` or `sum` methods
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

Returns
-------
m : ndarray, see dtype parameter above
    If `out=None`, returns a new array containing the mean values,
    otherwise a reference to the output array is returned. Nan is
    returned for slices that contain only NaNs.

See Also
--------
average : Weighted average
mean : Arithmetic mean taken while not ignoring NaNs
var, nanvar

Notes
-----
The arithmetic mean is the sum of the non-NaN elements along the axis
divided by the number of non-NaN elements.

Note that for floating-point input, the mean is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32`.  Specifying a
higher-precision accumulator using the `dtype` keyword can alleviate
this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])
&gt;&gt;&gt; np.nanmean(a)
2.6666666666666665
&gt;&gt;&gt; np.nanmean(a, axis=0)
array([2.,  4.])
&gt;&gt;&gt; np.nanmean(a, axis=1)
array([1.,  3.5]) # may vary</pre> 
</div>
</div>
<a id="ac8860b2b8666f170298c8e7c23cf592b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8860b2b8666f170298c8e7c23cf592b">&#9670;&nbsp;</a></span>nanmedian()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanmedian </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the median along the specified axis, while ignoring NaNs.

Returns the median of the array elements.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array.
axis : {int, sequence of int, None}, optional
    Axis or axes along which the medians are computed. The default
    is to compute the median along a flattened version of the array.
    A sequence of axes is supported since version 1.9.0.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
   If True, then allow use of memory of input array `a` for
   calculations. The input array will be modified by the call to
   `median`. This will save memory when you do not need to preserve
   the contents of the input array. Treat the input as undefined,
   but it will probably be fully or partially sorted. Default is
   False. If `overwrite_input` is ``True`` and `a` is not already an
   `ndarray`, an error will be raised.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If this is anything but the default value it will be passed
    through (in the special case of an empty array) to the
    `mean` function of the underlying array.  If the array is
    a sub-class and `mean` does not have the kwarg `keepdims` this
    will raise a RuntimeError.

Returns
-------
median : ndarray
    A new array holding the result. If the input contains integers
    or floats smaller than ``float64``, then the output data-type is
    ``np.float64``.  Otherwise, the data-type of the output is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
mean, median, percentile

Notes
-----
Given a vector ``V`` of length ``N``, the median of ``V`` is the
middle value of a sorted copy of ``V``, ``V_sorted`` - i.e.,
``V_sorted[(N-1)/2]``, when ``N`` is odd and the average of the two
middle values of ``V_sorted`` when ``N`` is even.

Examples
--------
&gt;&gt;&gt; a = np.array([[10.0, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a[0, 1] = np.nan
&gt;&gt;&gt; a
array([[10., nan,  4.],
       [ 3.,  2.,  1.]])
&gt;&gt;&gt; np.median(a)
nan
&gt;&gt;&gt; np.nanmedian(a)
3.0
&gt;&gt;&gt; np.nanmedian(a, axis=0)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; np.median(a, axis=1)
array([nan,  2.])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanmedian(b, axis=1, overwrite_input=True)
array([7.,  2.])
&gt;&gt;&gt; assert not np.all(a==b)
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanmedian(b, axis=None, overwrite_input=True)
3.0
&gt;&gt;&gt; assert not np.all(a==b)</pre> 
</div>
</div>
<a id="a8e2e3d5692a3b58cd6a1ec33af0789e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2e3d5692a3b58cd6a1ec33af0789e0">&#9670;&nbsp;</a></span>nanmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return minimum of an array or minimum along an axis, ignoring any NaNs.
When all-NaN slices are encountered a ``RuntimeWarning`` is raised and
Nan is returned for that slice.

Parameters
----------
a : array_like
    Array containing numbers whose minimum is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the minimum is computed. The default is to compute
    the minimum of the flattened array.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``; if provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    :ref:`ufuncs-output-type` for more details.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If the value is anything but the default, then
    `keepdims` will be passed through to the `min` method
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

    .. versionadded:: 1.8.0

Returns
-------
nanmin : ndarray
    An array with the same shape as `a`, with the specified axis
    removed.  If `a` is a 0-d array, or if axis is None, an ndarray
    scalar is returned.  The same dtype as `a` is returned.

See Also
--------
nanmax :
    The maximum value of an array along a given axis, ignoring any NaNs.
amin :
    The minimum value of an array along a given axis, propagating any NaNs.
fmin :
    Element-wise minimum of two arrays, ignoring any NaNs.
minimum :
    Element-wise minimum of two arrays, propagating any NaNs.
isnan :
    Shows which elements are Not a Number (NaN).
isfinite:
    Shows which elements are neither NaN nor infinity.

amax, fmax, maximum

Notes
-----
NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic
(IEEE 754). This means that Not a Number is not equivalent to infinity.
Positive infinity is treated as a very large number and negative
infinity is treated as a very small (i.e. negative) number.

If the input has a integer type the function is equivalent to np.min.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanmin(a)
1.0
&gt;&gt;&gt; np.nanmin(a, axis=0)
array([1.,  2.])
&gt;&gt;&gt; np.nanmin(a, axis=1)
array([1.,  3.])

When positive infinity and negative infinity are present:

&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.inf])
1.0
&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.NINF])
-inf</pre> 
</div>
</div>
<a id="a1fb5edb6795a7ac5109de2579da1dc03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb5edb6795a7ac5109de2579da1dc03">&#9670;&nbsp;</a></span>nanpercentile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanpercentile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>'linear'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the qth percentile of the data along the specified axis,
while ignoring nan values.

Returns the qth percentile(s) of the array elements.

.. versionadded:: 1.9.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array, containing
    nan values to be ignored.
q : array_like of float
    Percentile or sequence of percentiles to compute, which must be between
    0 and 100 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the percentiles are computed. The
    default is to compute the percentile(s) along a flattened
    version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by intermediate
    calculations, to save memory. In this case, the contents of the input
    `a` after this function completes is undefined.
interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    This optional parameter specifies the interpolation method to
    use when the desired percentile lies between two data points
    ``i &lt; j``:

    * 'linear': ``i + (j - i) * fraction``, where ``fraction``
      is the fractional part of the index surrounded by ``i``
      and ``j``.
    * 'lower': ``i``.
    * 'higher': ``j``.
    * 'nearest': ``i`` or ``j``, whichever is nearest.
    * 'midpoint': ``(i + j) / 2``.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

    If this is anything but the default value it will be passed
    through (in the special case of an empty array) to the
    `mean` function of the underlying array.  If the array is
    a sub-class and `mean` does not have the kwarg `keepdims` this
    will raise a RuntimeError.

Returns
-------
percentile : scalar or ndarray
    If `q` is a single percentile and `axis=None`, then the result
    is a scalar. If multiple percentiles are given, first axis of
    the result corresponds to the percentiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
nanmean
nanmedian : equivalent to ``nanpercentile(..., 50)``
percentile, median, mean
nanquantile : equivalent to nanpercentile, but with q in the range [0, 1].

Notes
-----
Given a vector ``V`` of length ``N``, the ``q``-th percentile of
``V`` is the value ``q/100`` of the way from the minimum to the
maximum in a sorted copy of ``V``. The values and distances of
the two nearest neighbors as well as the `interpolation` parameter
will determine the percentile if the normalized ranking does not
match the location of ``q`` exactly. This function is the same as
the median if ``q=50``, the same as the minimum if ``q=0`` and the
same as the maximum if ``q=100``.

Examples
--------
&gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])
&gt;&gt;&gt; a[0][1] = np.nan
&gt;&gt;&gt; a
array([[10.,  nan,   4.],
      [ 3.,   2.,   1.]])
&gt;&gt;&gt; np.percentile(a, 50)
nan
&gt;&gt;&gt; np.nanpercentile(a, 50)
3.0
&gt;&gt;&gt; np.nanpercentile(a, 50, axis=0)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; np.nanpercentile(a, 50, axis=1, keepdims=True)
array([[7.],
       [2.]])
&gt;&gt;&gt; m = np.nanpercentile(a, 50, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.nanpercentile(a, 50, axis=0, out=out)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; m
array([6.5,  2. ,  2.5])

&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanpercentile(b, 50, axis=1, overwrite_input=True)
array([7., 2.])
&gt;&gt;&gt; assert not np.all(a==b)</pre> 
</div>
</div>
<a id="a7c5e7f7084f8d2535e4506776ac0c98f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5e7f7084f8d2535e4506776ac0c98f">&#9670;&nbsp;</a></span>nanprod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanprod </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the product of array elements over a given axis treating Not a
Numbers (NaNs) as ones.

One is returned for slices that are all-NaN or empty.

.. versionadded:: 1.10.0

Parameters
----------
a : array_like
    Array containing numbers whose product is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the product is computed. The default is to compute
    the product of the flattened array.
dtype : data-type, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  By default, the dtype of `a` is used.  An
    exception is when `a` has an integer type with less precision than
    the platform (u)intp. In that case, the default will be either
    (u)int32 or (u)int64 depending on whether the platform is 32 or 64
    bits. For inexact inputs, dtype must be inexact.
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``. If provided, it must have the same shape as the
    expected output, but the type will be cast if necessary. See
    :ref:`ufuncs-output-type` for more details. The casting of NaN to integer
    can yield unexpected results.
keepdims : bool, optional
    If True, the axes which are reduced are left in the result as
    dimensions with size one. With this option, the result will
    broadcast correctly against the original `arr`.

Returns
-------
nanprod : ndarray
    A new array holding the result is returned unless `out` is
    specified, in which case it is returned.

See Also
--------
numpy.prod : Product across array propagating NaNs.
isnan : Show which elements are NaN.

Examples
--------
&gt;&gt;&gt; np.nanprod(1)
1
&gt;&gt;&gt; np.nanprod([1])
1
&gt;&gt;&gt; np.nanprod([1, np.nan])
1.0
&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])
&gt;&gt;&gt; np.nanprod(a)
6.0
&gt;&gt;&gt; np.nanprod(a, axis=0)
array([3., 2.])</pre> 
</div>
</div>
<a id="a5eb8de27a8087256d8205db0e4151bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb8de27a8087256d8205db0e4151bd4">&#9670;&nbsp;</a></span>nanquantile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanquantile </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>overwrite_input</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interpolation</em> = <code>'linear'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the qth quantile of the data along the specified axis,
while ignoring nan values.
Returns the qth quantile(s) of the array elements.

.. versionadded:: 1.15.0

Parameters
----------
a : array_like
    Input array or object that can be converted to an array, containing
    nan values to be ignored
q : array_like of float
    Quantile or sequence of quantiles to compute, which must be between
    0 and 1 inclusive.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the quantiles are computed. The
    default is to compute the quantile(s) along a flattened
    version of the array.
out : ndarray, optional
    Alternative output array in which to place the result. It must
    have the same shape and buffer length as the expected output,
    but the type (of the output) will be cast if necessary.
overwrite_input : bool, optional
    If True, then allow the input array `a` to be modified by intermediate
    calculations, to save memory. In this case, the contents of the input
    `a` after this function completes is undefined.
interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
    This optional parameter specifies the interpolation method to
    use when the desired quantile lies between two data points
    ``i &lt; j``:

    * linear: ``i + (j - i) * fraction``, where ``fraction``
      is the fractional part of the index surrounded by ``i``
      and ``j``.
    * lower: ``i``.
    * higher: ``j``.
    * nearest: ``i`` or ``j``, whichever is nearest.
    * midpoint: ``(i + j) / 2``.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left in
    the result as dimensions with size one. With this option, the
    result will broadcast correctly against the original array `a`.

    If this is anything but the default value it will be passed
    through (in the special case of an empty array) to the
    `mean` function of the underlying array.  If the array is
    a sub-class and `mean` does not have the kwarg `keepdims` this
    will raise a RuntimeError.

Returns
-------
quantile : scalar or ndarray
    If `q` is a single percentile and `axis=None`, then the result
    is a scalar. If multiple quantiles are given, first axis of
    the result corresponds to the quantiles. The other axes are
    the axes that remain after the reduction of `a`. If the input
    contains integers or floats smaller than ``float64``, the output
    data-type is ``float64``. Otherwise, the output data-type is the
    same as that of the input. If `out` is specified, that array is
    returned instead.

See Also
--------
quantile
nanmean, nanmedian
nanmedian : equivalent to ``nanquantile(..., 0.5)``
nanpercentile : same as nanquantile, but with q in the range [0, 100].

Examples
--------
&gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])
&gt;&gt;&gt; a[0][1] = np.nan
&gt;&gt;&gt; a
array([[10.,  nan,   4.],
      [ 3.,   2.,   1.]])
&gt;&gt;&gt; np.quantile(a, 0.5)
nan
&gt;&gt;&gt; np.nanquantile(a, 0.5)
3.0
&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=1, keepdims=True)
array([[7.],
       [2.]])
&gt;&gt;&gt; m = np.nanquantile(a, 0.5, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0, out=out)
array([6.5, 2. , 2.5])
&gt;&gt;&gt; m
array([6.5,  2. ,  2.5])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.nanquantile(b, 0.5, axis=1, overwrite_input=True)
array([7., 2.])
&gt;&gt;&gt; assert not np.all(a==b)
</pre> 
</div>
</div>
<a id="acb96436d04b671c696d194e3feb1317d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb96436d04b671c696d194e3feb1317d">&#9670;&nbsp;</a></span>nanstd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanstd </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the standard deviation along the specified axis, while
ignoring NaNs.

Returns the standard deviation, a measure of the spread of a
distribution, of the non-NaN array elements. The standard deviation is
computed for the flattened array by default, otherwise over the
specified axis.

For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Calculate the standard deviation of the non-NaN values.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the standard deviation is computed. The default is
    to compute the standard deviation of the flattened array.
dtype : dtype, optional
    Type to use in computing the standard deviation. For arrays of
    integer type the default is float64, for arrays of float types it
    is the same as the array type.
out : ndarray, optional
    Alternative output array in which to place the result. It must have
    the same shape as the expected output but the type (of the
    calculated values) will be cast if necessary.
ddof : int, optional
    Means Delta Degrees of Freedom.  The divisor used in calculations
    is ``N - ddof``, where ``N`` represents the number of non-NaN
    elements.  By default `ddof` is zero.

keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.

    If this value is anything but the default it is passed through
    as-is to the relevant functions of the sub-classes.  If these
    functions do not have a `keepdims` kwarg, a RuntimeError will
    be raised.

Returns
-------
standard_deviation : ndarray, see dtype parameter above.
    If `out` is None, return a new array containing the standard
    deviation, otherwise return a reference to the output array. If
    ddof is &gt;= the number of non-NaN elements in a slice or the slice
    contains only NaNs, then the result for that slice is NaN.

See Also
--------
var, mean, std
nanvar, nanmean
:ref:`ufuncs-output-type`

Notes
-----
The standard deviation is the square root of the average of the squared
deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.

The average squared deviation is normally calculated as
``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is
specified, the divisor ``N - ddof`` is used instead. In standard
statistical practice, ``ddof=1`` provides an unbiased estimator of the
variance of the infinite population. ``ddof=0`` provides a maximum
likelihood estimate of the variance for normally distributed variables.
The standard deviation computed in this function is the square root of
the estimated variance, so even with ``ddof=1``, it will not be an
unbiased estimate of the standard deviation per se.

Note that, for complex numbers, `std` takes the absolute value before
squaring, so that the result is always real and nonnegative.

For floating-point input, the *std* is computed using the same
precision the input has. Depending on the input data, this can cause
the results to be inaccurate, especially for float32 (see example
below).  Specifying a higher-accuracy accumulator using the `dtype`
keyword can alleviate this issue.

Examples
--------
&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])
&gt;&gt;&gt; np.nanstd(a)
1.247219128924647
&gt;&gt;&gt; np.nanstd(a, axis=0)
array([1., 0.])
&gt;&gt;&gt; np.nanstd(a, axis=1)
array([0.,  0.5]) # may vary</pre> 
</div>
</div>
<a id="a763c827042a377c7ac967cd3b703694b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a763c827042a377c7ac967cd3b703694b">&#9670;&nbsp;</a></span>nansum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nansum </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the sum of array elements over a given axis treating Not a
Numbers (NaNs) as zero.

In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or
empty. In later versions zero is returned.

Parameters
----------
a : array_like
    Array containing numbers whose sum is desired. If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the sum is computed. The default is to compute the
    sum of the flattened array.
dtype : data-type, optional
    The type of the returned array and of the accumulator in which the
    elements are summed.  By default, the dtype of `a` is used.  An
    exception is when `a` has an integer type with less precision than
    the platform (u)intp. In that case, the default will be either
    (u)int32 or (u)int64 depending on whether the platform is 32 or 64
    bits. For inexact inputs, dtype must be inexact.

    .. versionadded:: 1.8.0
out : ndarray, optional
    Alternate output array in which to place the result.  The default
    is ``None``. If provided, it must have the same shape as the
    expected output, but the type will be cast if necessary.  See
    :ref:`ufuncs-output-type` for more details. The casting of NaN to integer
    can yield unexpected results.

    .. versionadded:: 1.8.0
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.


    If the value is anything but the default, then
    `keepdims` will be passed through to the `mean` or `sum` methods
    of sub-classes of `ndarray`.  If the sub-classes methods
    does not implement `keepdims` any exceptions will be raised.

    .. versionadded:: 1.8.0

Returns
-------
nansum : ndarray.
    A new array holding the result is returned unless `out` is
    specified, in which it is returned. The result has the same
    size as `a`, and the same shape as `a` if `axis` is not None
    or `a` is a 1-d array.

See Also
--------
numpy.sum : Sum across array propagating NaNs.
isnan : Show which elements are NaN.
isfinite : Show which elements are not NaN or +/-inf.

Notes
-----
If both positive and negative infinity are present, the sum will be Not
A Number (NaN).

Examples
--------
&gt;&gt;&gt; np.nansum(1)
1
&gt;&gt;&gt; np.nansum([1])
1
&gt;&gt;&gt; np.nansum([1, np.nan])
1.0
&gt;&gt;&gt; a = np.array([[1, 1], [1, np.nan]])
&gt;&gt;&gt; np.nansum(a)
3.0
&gt;&gt;&gt; np.nansum(a, axis=0)
array([2.,  1.])
&gt;&gt;&gt; np.nansum([1, np.nan, np.inf])
inf
&gt;&gt;&gt; np.nansum([1, np.nan, np.NINF])
-inf
&gt;&gt;&gt; from numpy.testing import suppress_warnings
&gt;&gt;&gt; with suppress_warnings() as sup:
...     sup.filter(RuntimeWarning)
...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present
nan</pre> 
</div>
</div>
<a id="aa74b1b732ed44e858f6610c2f8e09836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74b1b732ed44e858f6610c2f8e09836">&#9670;&nbsp;</a></span>nanvar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.lib.nanfunctions.nanvar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddof</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>np._NoValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the variance along the specified axis, while ignoring NaNs.

Returns the variance of the array elements, a measure of the spread of
a distribution.  The variance is computed for the flattened array by
default, otherwise over the specified axis.

For all-NaN slices or slices with zero degrees of freedom, NaN is
returned and a `RuntimeWarning` is raised.

.. versionadded:: 1.8.0

Parameters
----------
a : array_like
    Array containing numbers whose variance is desired.  If `a` is not an
    array, a conversion is attempted.
axis : {int, tuple of int, None}, optional
    Axis or axes along which the variance is computed.  The default is to compute
    the variance of the flattened array.
dtype : data-type, optional
    Type to use in computing the variance.  For arrays of integer type
    the default is `float64`; for arrays of float types it is the same as
    the array type.
out : ndarray, optional
    Alternate output array in which to place the result.  It must have
    the same shape as the expected output, but the type is cast if
    necessary.
ddof : int, optional
    "Delta Degrees of Freedom": the divisor used in the calculation is
    ``N - ddof``, where ``N`` represents the number of non-NaN
    elements. By default `ddof` is zero.
keepdims : bool, optional
    If this is set to True, the axes which are reduced are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the original `a`.


Returns
-------
variance : ndarray, see dtype parameter above
    If `out` is None, return a new array containing the variance,
    otherwise return a reference to the output array. If ddof is &gt;= the
    number of non-NaN elements in a slice or the slice contains only
    NaNs, then the result for that slice is NaN.

See Also
--------
std : Standard deviation
mean : Average
var : Variance while not ignoring NaNs
nanstd, nanmean
:ref:`ufuncs-output-type`

Notes
-----
The variance is the average of the squared deviations from the mean,
i.e.,  ``var = mean(abs(x - x.mean())**2)``.

The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
If, however, `ddof` is specified, the divisor ``N - ddof`` is used
instead.  In standard statistical practice, ``ddof=1`` provides an
unbiased estimator of the variance of a hypothetical infinite
population.  ``ddof=0`` provides a maximum likelihood estimate of the
variance for normally distributed variables.

Note that for complex numbers, the absolute value is taken before
squaring, so that the result is always real and nonnegative.

For floating-point input, the variance is computed using the same
precision the input has.  Depending on the input data, this can cause
the results to be inaccurate, especially for `float32` (see example
below).  Specifying a higher-accuracy accumulator using the ``dtype``
keyword can alleviate this issue.

For this function to work on sub-classes of ndarray, they must define
`sum` with the kwarg `keepdims`

Examples
--------
&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])
&gt;&gt;&gt; np.nanvar(a)
1.5555555555555554
&gt;&gt;&gt; np.nanvar(a, axis=0)
array([1.,  0.])
&gt;&gt;&gt; np.nanvar(a, axis=1)
array([0.,  0.25])  # may vary</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5d66ace42e50dfe8f961bdaad0c9ff6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d66ace42e50dfe8f961bdaad0c9ff6e">&#9670;&nbsp;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a909a2bb150c1b122fe91d94ae7774659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909a2bb150c1b122fe91d94ae7774659">&#9670;&nbsp;</a></span>module</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.lib.nanfunctions.module</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
