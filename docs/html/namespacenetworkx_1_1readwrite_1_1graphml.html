<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.readwrite.graphml Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1readwrite.html">readwrite</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1readwrite_1_1graphml.html">graphml</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">networkx.readwrite.graphml Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1readwrite_1_1graphml_1_1GraphML.html">GraphML</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1readwrite_1_1graphml_1_1GraphMLReader.html">GraphMLReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1readwrite_1_1graphml_1_1GraphMLWriter.html">GraphMLWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1readwrite_1_1graphml_1_1GraphMLWriterLxml.html">GraphMLWriterLxml</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1readwrite_1_1graphml_1_1IncrementalElement.html">IncrementalElement</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a402f85085b78287200232129e44d5415"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1readwrite_1_1graphml.html#a402f85085b78287200232129e44d5415">write_graphml_xml</a> (G, path, encoding=&quot;utf-8&quot;, prettyprint=True, infer_numeric_types=False, named_key_ids=False, edge_id_from_attribute=None)</td></tr>
<tr class="separator:a402f85085b78287200232129e44d5415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b8982d923038f1e66ce2863daa637f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1readwrite_1_1graphml.html#aa2b8982d923038f1e66ce2863daa637f">write_graphml_lxml</a> (G, path, encoding=&quot;utf-8&quot;, prettyprint=True, infer_numeric_types=False, named_key_ids=False, edge_id_from_attribute=None)</td></tr>
<tr class="separator:aa2b8982d923038f1e66ce2863daa637f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cad67ecd404c7d3c5aa7e3a960c698"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1readwrite_1_1graphml.html#ae3cad67ecd404c7d3c5aa7e3a960c698">generate_graphml</a> (G, encoding=&quot;utf-8&quot;, prettyprint=True, named_key_ids=False, edge_id_from_attribute=None)</td></tr>
<tr class="separator:ae3cad67ecd404c7d3c5aa7e3a960c698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8347c9f63d34bba3e57c48f043835e2e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1readwrite_1_1graphml.html#a8347c9f63d34bba3e57c48f043835e2e">read_graphml</a> (path, node_type=str, edge_key_type=int, force_multigraph=False)</td></tr>
<tr class="separator:a8347c9f63d34bba3e57c48f043835e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeff394d286bd6994a649c8bdddd5a17"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1readwrite_1_1graphml.html#abeff394d286bd6994a649c8bdddd5a17">parse_graphml</a> (graphml_string, node_type=str, edge_key_type=int, force_multigraph=False)</td></tr>
<tr class="separator:abeff394d286bd6994a649c8bdddd5a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afaaee57deeaba21fc4c70f107fe39da1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1readwrite_1_1graphml.html#afaaee57deeaba21fc4c70f107fe39da1">mode</a></td></tr>
<tr class="separator:afaaee57deeaba21fc4c70f107fe39da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50907e2aab4ec16b4d6a25916ef67bb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1readwrite_1_1graphml.html#a50907e2aab4ec16b4d6a25916ef67bb7">write_graphml</a></td></tr>
<tr class="separator:a50907e2aab4ec16b4d6a25916ef67bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">*******
GraphML
*******
Read and write graphs in GraphML format.

This implementation does not support mixed graphs (directed and unidirected
edges together), hyperedges, nested graphs, or ports.

"GraphML is a comprehensive and easy-to-use file format for graphs. It
consists of a language core to describe the structural properties of a
graph and a flexible extension mechanism to add application-specific
data. Its main features include support of

    * directed, undirected, and mixed graphs,
    * hypergraphs,
    * hierarchical graphs,
    * graphical representations,
    * references to external data,
    * application-specific attribute data, and
    * light-weight parsers.

Unlike many other file formats for graphs, GraphML does not use a
custom syntax. Instead, it is based on XML and hence ideally suited as
a common denominator for all kinds of services generating, archiving,
or processing graphs."

http://graphml.graphdrawing.org/

Format
------
GraphML is an XML format.  See
http://graphml.graphdrawing.org/specification.html for the specification and
http://graphml.graphdrawing.org/primer/graphml-primer.html
for examples.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ae3cad67ecd404c7d3c5aa7e3a960c698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3cad67ecd404c7d3c5aa7e3a960c698">&#9670;&nbsp;</a></span>generate_graphml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.readwrite.graphml.generate_graphml </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prettyprint</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>named_key_ids</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_id_from_attribute</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate GraphML lines for G

Parameters
----------
G : graph
   A networkx graph
encoding : string (optional)
   Encoding for text data.
prettyprint : bool (optional)
   If True use line breaks and indenting in output XML.
named_key_ids : bool (optional)
   If True use attr.name as value for key elements' id attribute.
edge_id_from_attribute : dict key (optional)
    If provided, the graphml edge id is set by looking up the corresponding
    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,
    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; linefeed = chr(10)  # linefeed = \n
&gt;&gt;&gt; s = linefeed.join(nx.generate_graphml(G))
&gt;&gt;&gt; for line in nx.generate_graphml(G):  # doctest: +SKIP
...     print(line)

Notes
-----
This implementation does not support mixed graphs (directed and unidirected
edges together) hyperedges, nested graphs, or ports.
</pre> 
</div>
</div>
<a id="abeff394d286bd6994a649c8bdddd5a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeff394d286bd6994a649c8bdddd5a17">&#9670;&nbsp;</a></span>parse_graphml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.readwrite.graphml.parse_graphml </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graphml_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node_type</em> = <code>str</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_key_type</em> = <code>int</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_multigraph</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read graph in GraphML format from string.

Parameters
----------
graphml_string : string
   String containing graphml information
   (e.g., contents of a graphml file).

node_type: Python type (default: str)
   Convert node ids to this type

edge_key_type: Python type (default: int)
   Convert graphml edge ids to this type. Multigraphs use id as edge key.
   Non-multigraphs add to edge attribute dict with name "id".

force_multigraph : bool (default: False)
   If True, return a multigraph with edge keys. If False (the default)
   return a multigraph when multiedges are in the graph.


Returns
-------
graph: NetworkX graph
    If no parallel edges are found a Graph or DiGraph is returned.
    Otherwise a MultiGraph or MultiDiGraph is returned.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; linefeed = chr(10)  # linefeed = \n
&gt;&gt;&gt; s = linefeed.join(nx.generate_graphml(G))
&gt;&gt;&gt; H = nx.parse_graphml(s)

Notes
-----
Default node and edge attributes are not propagated to each node and edge.
They can be obtained from `G.graph` and applied to node and edge attributes
if desired using something like this:

&gt;&gt;&gt; default_color = G.graph["node_default"]["color"]  # doctest: +SKIP
&gt;&gt;&gt; for node, data in G.nodes(data=True):  # doctest: +SKIP
...     if "color" not in data:
...         data["color"] = default_color
&gt;&gt;&gt; default_color = G.graph["edge_default"]["color"]  # doctest: +SKIP
&gt;&gt;&gt; for u, v, data in G.edges(data=True):  # doctest: +SKIP
...     if "color" not in data:
...         data["color"] = default_color

This implementation does not support mixed graphs (directed and unidirected
edges together), hypergraphs, nested graphs, or ports.

For multigraphs the GraphML edge "id" will be used as the edge
key.  If not specified then they "key" attribute will be used.  If
there is no "key" attribute a default NetworkX multigraph edge key
will be provided.</pre> 
</div>
</div>
<a id="a8347c9f63d34bba3e57c48f043835e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8347c9f63d34bba3e57c48f043835e2e">&#9670;&nbsp;</a></span>read_graphml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.readwrite.graphml.read_graphml </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node_type</em> = <code>str</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_key_type</em> = <code>int</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_multigraph</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Read graph in GraphML format from path.

Parameters
----------
path : file or string
   File or filename to write.
   Filenames ending in .gz or .bz2 will be compressed.

node_type: Python type (default: str)
   Convert node ids to this type

edge_key_type: Python type (default: int)
   Convert graphml edge ids to this type. Multigraphs use id as edge key.
   Non-multigraphs add to edge attribute dict with name "id".

force_multigraph : bool (default: False)
   If True, return a multigraph with edge keys. If False (the default)
   return a multigraph when multiedges are in the graph.

Returns
-------
graph: NetworkX graph
    If parallel edges are present or `force_multigraph=True` then
    a MultiGraph or MultiDiGraph is returned. Otherwise a Graph/DiGraph.
    The returned graph is directed if the file indicates it should be.

Notes
-----
Default node and edge attributes are not propagated to each node and edge.
They can be obtained from `G.graph` and applied to node and edge attributes
if desired using something like this:

&gt;&gt;&gt; default_color = G.graph["node_default"]["color"]  # doctest: +SKIP
&gt;&gt;&gt; for node, data in G.nodes(data=True):  # doctest: +SKIP
...     if "color" not in data:
...         data["color"] = default_color
&gt;&gt;&gt; default_color = G.graph["edge_default"]["color"]  # doctest: +SKIP
&gt;&gt;&gt; for u, v, data in G.edges(data=True):  # doctest: +SKIP
...     if "color" not in data:
...         data["color"] = default_color

This implementation does not support mixed graphs (directed and unidirected
edges together), hypergraphs, nested graphs, or ports.

For multigraphs the GraphML edge "id" will be used as the edge
key.  If not specified then they "key" attribute will be used.  If
there is no "key" attribute a default NetworkX multigraph edge key
will be provided.

Files with the yEd "yfiles" extension can be read. The type of the node's
shape is preserved in the `shape_type` node attribute.

yEd compressed files ("file.graphmlz" extension) can be read by renaming
the file to "file.graphml.gz".</pre> 
</div>
</div>
<a id="aa2b8982d923038f1e66ce2863daa637f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b8982d923038f1e66ce2863daa637f">&#9670;&nbsp;</a></span>write_graphml_lxml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.readwrite.graphml.write_graphml_lxml </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prettyprint</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>infer_numeric_types</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>named_key_ids</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_id_from_attribute</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write G in GraphML XML format to path

This function uses the LXML framework and should be faster than
the version using the xml library.

Parameters
----------
G : graph
   A networkx graph
path : file or string
   File or filename to write.
   Filenames ending in .gz or .bz2 will be compressed.
encoding : string (optional)
   Encoding for text data.
prettyprint : bool (optional)
   If True use line breaks and indenting in output XML.
infer_numeric_types : boolean
   Determine if numeric types should be generalized.
   For example, if edges have both int and float 'weight' attributes,
   we infer in GraphML that both are floats.
named_key_ids : bool (optional)
   If True use attr.name as value for key elements' id attribute.
edge_id_from_attribute : dict key (optional)
    If provided, the graphml edge id is set by looking up the corresponding
    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,
    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; nx.write_graphml_lxml(G, "fourpath.graphml")

Notes
-----
This implementation does not support mixed graphs (directed
and unidirected edges together) hyperedges, nested graphs, or ports.
</pre> 
</div>
</div>
<a id="a402f85085b78287200232129e44d5415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402f85085b78287200232129e44d5415">&#9670;&nbsp;</a></span>write_graphml_xml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.readwrite.graphml.write_graphml_xml </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>&quot;utf-8&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prettyprint</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>infer_numeric_types</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>named_key_ids</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edge_id_from_attribute</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Write G in GraphML XML format to path

Parameters
----------
G : graph
   A networkx graph
path : file or string
   File or filename to write.
   Filenames ending in .gz or .bz2 will be compressed.
encoding : string (optional)
   Encoding for text data.
prettyprint : bool (optional)
   If True use line breaks and indenting in output XML.
infer_numeric_types : boolean
   Determine if numeric types should be generalized.
   For example, if edges have both int and float 'weight' attributes,
   we infer in GraphML that both are floats.
named_key_ids : bool (optional)
   If True use attr.name as value for key elements' id attribute.
edge_id_from_attribute : dict key (optional)
    If provided, the graphml edge id is set by looking up the corresponding
    edge data attribute keyed by this parameter. If `None` or the key does not exist in edge data,
    the edge id is set by the edge key if `G` is a MultiGraph, else the edge id is left unset.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(4)
&gt;&gt;&gt; nx.write_graphml(G, "test.graphml")

Notes
-----
This implementation does not support mixed graphs (directed
and unidirected edges together) hyperedges, nested graphs, or ports.
</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="afaaee57deeaba21fc4c70f107fe39da1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaaee57deeaba21fc4c70f107fe39da1">&#9670;&nbsp;</a></span>mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">networkx.readwrite.graphml.mode</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50907e2aab4ec16b4d6a25916ef67bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50907e2aab4ec16b4d6a25916ef67bb7">&#9670;&nbsp;</a></span>write_graphml</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">networkx.readwrite.graphml.write_graphml</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
