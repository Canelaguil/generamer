<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.flow.maxflow Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow.html">flow</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1maxflow.html">maxflow</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.flow.maxflow Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a66e4d2007ca288b02e49846a4a25994c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1maxflow.html#a66e4d2007ca288b02e49846a4a25994c">maximum_flow</a> (flowG, _s, _t, capacity=&quot;capacity&quot;, flow_func=None, kwargs)</td></tr>
<tr class="separator:a66e4d2007ca288b02e49846a4a25994c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1661c7cb34faa8bbe10d57cfc3ab3c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1maxflow.html#a1a1661c7cb34faa8bbe10d57cfc3ab3c">maximum_flow_value</a> (flowG, _s, _t, capacity=&quot;capacity&quot;, flow_func=None, kwargs)</td></tr>
<tr class="separator:a1a1661c7cb34faa8bbe10d57cfc3ab3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b42167cf296bb43dbd57f17926db3fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1maxflow.html#a2b42167cf296bb43dbd57f17926db3fc">minimum_cut</a> (flowG, _s, _t, capacity=&quot;capacity&quot;, flow_func=None, kwargs)</td></tr>
<tr class="separator:a2b42167cf296bb43dbd57f17926db3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a92d8e8d9389ce5daed1068317f5b5b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1maxflow.html#a5a92d8e8d9389ce5daed1068317f5b5b">minimum_cut_value</a> (flowG, _s, _t, capacity=&quot;capacity&quot;, flow_func=None, kwargs)</td></tr>
<tr class="separator:a5a92d8e8d9389ce5daed1068317f5b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a857a2f8be172db71de98b250db0394fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1maxflow.html#a857a2f8be172db71de98b250db0394fa">default_flow_func</a></td></tr>
<tr class="separator:a857a2f8be172db71de98b250db0394fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5243b2ab0dc59ea61b7a11730e419299"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1flow_1_1maxflow.html#a5243b2ab0dc59ea61b7a11730e419299">flow_funcs</a></td></tr>
<tr class="separator:a5243b2ab0dc59ea61b7a11730e419299"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Maximum flow (and minimum cut) algorithms on capacitated graphs.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a66e4d2007ca288b02e49846a4a25994c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e4d2007ca288b02e49846a4a25994c">&#9670;&nbsp;</a></span>maximum_flow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.flow.maxflow.maximum_flow </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flowG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>&quot;capacity&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a maximum single-commodity flow.

Parameters
----------
flowG : NetworkX graph
    Edges of the graph are expected to have an attribute called
    'capacity'. If this attribute is not present, the edge is
    considered to have infinite capacity.

_s : node
    Source node for the flow.

_t : node
    Sink node for the flow.

capacity : string
    Edges of the graph G are expected to have an attribute capacity
    that indicates how much flow the edge can support. If this
    attribute is not present, the edge is considered to have
    infinite capacity. Default value: 'capacity'.

flow_func : function
    A function for computing the maximum flow among a pair of nodes
    in a capacitated graph. The function has to accept at least three
    parameters: a Graph or Digraph, a source node, and a target node.
    And return a residual network that follows NetworkX conventions
    (see Notes). If flow_func is None, the default maximum
    flow function (:meth:`preflow_push`) is used. See below for
    alternative algorithms. The choice of the default function may change
    from version to version and should not be relied on. Default value:
    None.

kwargs : Any other keyword parameter is passed to the function that
    computes the maximum flow.

Returns
-------
flow_value : integer, float
    Value of the maximum flow, i.e., net outflow from the source.

flow_dict : dict
    A dictionary containing the value of the flow that went through
    each edge.

Raises
------
NetworkXError
    The algorithm does not support MultiGraph and MultiDiGraph. If
    the input graph is an instance of one of these two classes, a
    NetworkXError is raised.

NetworkXUnbounded
    If the graph has a path of infinite capacity, the value of a
    feasible flow on the graph is unbounded above and the function
    raises a NetworkXUnbounded.

See also
--------
:meth:`maximum_flow_value`
:meth:`minimum_cut`
:meth:`minimum_cut_value`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`

Notes
-----
The function used in the flow_func parameter has to return a residual
network that follows NetworkX conventions:

The residual network :samp:`R` from an input graph :samp:`G` has the
same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair
of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a
self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists
in :samp:`G`.

For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`
is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists
in :samp:`G` or zero otherwise. If the capacity is infinite,
:samp:`R[u][v]['capacity']` will have a high arbitrary finite value
that does not affect the solution of the problem. This value is stored in
:samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,
:samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and
satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.

The flow value, defined as the total flow into :samp:`t`, the sink, is
stored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using
only edges :samp:`(u, v)` such that
:samp:`R[u][v]['flow'] &lt; R[u][v]['capacity']` induces a minimum
:samp:`s`-:samp:`t` cut.

Specific algorithms may store extra data in :samp:`R`.

The function should supports an optional boolean parameter value_only. When
True, it can optionally terminate the algorithm as soon as the maximum flow
value and the minimum cut can be determined.

Examples
--------
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_edge("x", "a", capacity=3.0)
&gt;&gt;&gt; G.add_edge("x", "b", capacity=1.0)
&gt;&gt;&gt; G.add_edge("a", "c", capacity=3.0)
&gt;&gt;&gt; G.add_edge("b", "c", capacity=5.0)
&gt;&gt;&gt; G.add_edge("b", "d", capacity=4.0)
&gt;&gt;&gt; G.add_edge("d", "e", capacity=2.0)
&gt;&gt;&gt; G.add_edge("c", "y", capacity=2.0)
&gt;&gt;&gt; G.add_edge("e", "y", capacity=3.0)

maximum_flow returns both the value of the maximum flow and a
dictionary with all flows.

&gt;&gt;&gt; flow_value, flow_dict = nx.maximum_flow(G, "x", "y")
&gt;&gt;&gt; flow_value
3.0
&gt;&gt;&gt; print(flow_dict["x"]["b"])
1.0

You can also use alternative algorithms for computing the
maximum flow by using the flow_func parameter.

&gt;&gt;&gt; from networkx.algorithms.flow import shortest_augmenting_path
&gt;&gt;&gt; flow_value == nx.maximum_flow(G, "x", "y", flow_func=shortest_augmenting_path)[
...     0
... ]
True</pre> 
</div>
</div>
<a id="a1a1661c7cb34faa8bbe10d57cfc3ab3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1661c7cb34faa8bbe10d57cfc3ab3c">&#9670;&nbsp;</a></span>maximum_flow_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.flow.maxflow.maximum_flow_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flowG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>&quot;capacity&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the value of maximum single-commodity flow.

Parameters
----------
flowG : NetworkX graph
    Edges of the graph are expected to have an attribute called
    'capacity'. If this attribute is not present, the edge is
    considered to have infinite capacity.

_s : node
    Source node for the flow.

_t : node
    Sink node for the flow.

capacity : string
    Edges of the graph G are expected to have an attribute capacity
    that indicates how much flow the edge can support. If this
    attribute is not present, the edge is considered to have
    infinite capacity. Default value: 'capacity'.

flow_func : function
    A function for computing the maximum flow among a pair of nodes
    in a capacitated graph. The function has to accept at least three
    parameters: a Graph or Digraph, a source node, and a target node.
    And return a residual network that follows NetworkX conventions
    (see Notes). If flow_func is None, the default maximum
    flow function (:meth:`preflow_push`) is used. See below for
    alternative algorithms. The choice of the default function may change
    from version to version and should not be relied on. Default value:
    None.

kwargs : Any other keyword parameter is passed to the function that
    computes the maximum flow.

Returns
-------
flow_value : integer, float
    Value of the maximum flow, i.e., net outflow from the source.

Raises
------
NetworkXError
    The algorithm does not support MultiGraph and MultiDiGraph. If
    the input graph is an instance of one of these two classes, a
    NetworkXError is raised.

NetworkXUnbounded
    If the graph has a path of infinite capacity, the value of a
    feasible flow on the graph is unbounded above and the function
    raises a NetworkXUnbounded.

See also
--------
:meth:`maximum_flow`
:meth:`minimum_cut`
:meth:`minimum_cut_value`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`

Notes
-----
The function used in the flow_func parameter has to return a residual
network that follows NetworkX conventions:

The residual network :samp:`R` from an input graph :samp:`G` has the
same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair
of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a
self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists
in :samp:`G`.

For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`
is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists
in :samp:`G` or zero otherwise. If the capacity is infinite,
:samp:`R[u][v]['capacity']` will have a high arbitrary finite value
that does not affect the solution of the problem. This value is stored in
:samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,
:samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and
satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.

The flow value, defined as the total flow into :samp:`t`, the sink, is
stored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using
only edges :samp:`(u, v)` such that
:samp:`R[u][v]['flow'] &lt; R[u][v]['capacity']` induces a minimum
:samp:`s`-:samp:`t` cut.

Specific algorithms may store extra data in :samp:`R`.

The function should supports an optional boolean parameter value_only. When
True, it can optionally terminate the algorithm as soon as the maximum flow
value and the minimum cut can be determined.

Examples
--------
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_edge("x", "a", capacity=3.0)
&gt;&gt;&gt; G.add_edge("x", "b", capacity=1.0)
&gt;&gt;&gt; G.add_edge("a", "c", capacity=3.0)
&gt;&gt;&gt; G.add_edge("b", "c", capacity=5.0)
&gt;&gt;&gt; G.add_edge("b", "d", capacity=4.0)
&gt;&gt;&gt; G.add_edge("d", "e", capacity=2.0)
&gt;&gt;&gt; G.add_edge("c", "y", capacity=2.0)
&gt;&gt;&gt; G.add_edge("e", "y", capacity=3.0)

maximum_flow_value computes only the value of the
maximum flow:

&gt;&gt;&gt; flow_value = nx.maximum_flow_value(G, "x", "y")
&gt;&gt;&gt; flow_value
3.0

You can also use alternative algorithms for computing the
maximum flow by using the flow_func parameter.

&gt;&gt;&gt; from networkx.algorithms.flow import shortest_augmenting_path
&gt;&gt;&gt; flow_value == nx.maximum_flow_value(
...     G, "x", "y", flow_func=shortest_augmenting_path
... )
True</pre> 
</div>
</div>
<a id="a2b42167cf296bb43dbd57f17926db3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b42167cf296bb43dbd57f17926db3fc">&#9670;&nbsp;</a></span>minimum_cut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.flow.maxflow.minimum_cut </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flowG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>&quot;capacity&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the value and the node partition of a minimum (s, t)-cut.

Use the max-flow min-cut theorem, i.e., the capacity of a minimum
capacity cut is equal to the flow value of a maximum flow.

Parameters
----------
flowG : NetworkX graph
    Edges of the graph are expected to have an attribute called
    'capacity'. If this attribute is not present, the edge is
    considered to have infinite capacity.

_s : node
    Source node for the flow.

_t : node
    Sink node for the flow.

capacity : string
    Edges of the graph G are expected to have an attribute capacity
    that indicates how much flow the edge can support. If this
    attribute is not present, the edge is considered to have
    infinite capacity. Default value: 'capacity'.

flow_func : function
    A function for computing the maximum flow among a pair of nodes
    in a capacitated graph. The function has to accept at least three
    parameters: a Graph or Digraph, a source node, and a target node.
    And return a residual network that follows NetworkX conventions
    (see Notes). If flow_func is None, the default maximum
    flow function (:meth:`preflow_push`) is used. See below for
    alternative algorithms. The choice of the default function may change
    from version to version and should not be relied on. Default value:
    None.

kwargs : Any other keyword parameter is passed to the function that
    computes the maximum flow.

Returns
-------
cut_value : integer, float
    Value of the minimum cut.

partition : pair of node sets
    A partitioning of the nodes that defines a minimum cut.

Raises
------
NetworkXUnbounded
    If the graph has a path of infinite capacity, all cuts have
    infinite capacity and the function raises a NetworkXError.

See also
--------
:meth:`maximum_flow`
:meth:`maximum_flow_value`
:meth:`minimum_cut_value`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`

Notes
-----
The function used in the flow_func parameter has to return a residual
network that follows NetworkX conventions:

The residual network :samp:`R` from an input graph :samp:`G` has the
same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair
of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a
self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists
in :samp:`G`.

For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`
is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists
in :samp:`G` or zero otherwise. If the capacity is infinite,
:samp:`R[u][v]['capacity']` will have a high arbitrary finite value
that does not affect the solution of the problem. This value is stored in
:samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,
:samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and
satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.

The flow value, defined as the total flow into :samp:`t`, the sink, is
stored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using
only edges :samp:`(u, v)` such that
:samp:`R[u][v]['flow'] &lt; R[u][v]['capacity']` induces a minimum
:samp:`s`-:samp:`t` cut.

Specific algorithms may store extra data in :samp:`R`.

The function should supports an optional boolean parameter value_only. When
True, it can optionally terminate the algorithm as soon as the maximum flow
value and the minimum cut can be determined.

Examples
--------
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_edge("x", "a", capacity=3.0)
&gt;&gt;&gt; G.add_edge("x", "b", capacity=1.0)
&gt;&gt;&gt; G.add_edge("a", "c", capacity=3.0)
&gt;&gt;&gt; G.add_edge("b", "c", capacity=5.0)
&gt;&gt;&gt; G.add_edge("b", "d", capacity=4.0)
&gt;&gt;&gt; G.add_edge("d", "e", capacity=2.0)
&gt;&gt;&gt; G.add_edge("c", "y", capacity=2.0)
&gt;&gt;&gt; G.add_edge("e", "y", capacity=3.0)

minimum_cut computes both the value of the
minimum cut and the node partition:

&gt;&gt;&gt; cut_value, partition = nx.minimum_cut(G, "x", "y")
&gt;&gt;&gt; reachable, non_reachable = partition

'partition' here is a tuple with the two sets of nodes that define
the minimum cut. You can compute the cut set of edges that induce
the minimum cut as follows:

&gt;&gt;&gt; cutset = set()
&gt;&gt;&gt; for u, nbrs in ((n, G[n]) for n in reachable):
...     cutset.update((u, v) for v in nbrs if v in non_reachable)
&gt;&gt;&gt; print(sorted(cutset))
[('c', 'y'), ('x', 'b')]
&gt;&gt;&gt; cut_value == sum(G.edges[u, v]["capacity"] for (u, v) in cutset)
True

You can also use alternative algorithms for computing the
minimum cut by using the flow_func parameter.

&gt;&gt;&gt; from networkx.algorithms.flow import shortest_augmenting_path
&gt;&gt;&gt; cut_value == nx.minimum_cut(G, "x", "y", flow_func=shortest_augmenting_path)[0]
True</pre> 
</div>
</div>
<a id="a5a92d8e8d9389ce5daed1068317f5b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a92d8e8d9389ce5daed1068317f5b5b">&#9670;&nbsp;</a></span>minimum_cut_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.flow.maxflow.minimum_cut_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flowG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>&quot;capacity&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>flow_func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the value of a minimum (s, t)-cut.

Use the max-flow min-cut theorem, i.e., the capacity of a minimum
capacity cut is equal to the flow value of a maximum flow.

Parameters
----------
flowG : NetworkX graph
    Edges of the graph are expected to have an attribute called
    'capacity'. If this attribute is not present, the edge is
    considered to have infinite capacity.

_s : node
    Source node for the flow.

_t : node
    Sink node for the flow.

capacity : string
    Edges of the graph G are expected to have an attribute capacity
    that indicates how much flow the edge can support. If this
    attribute is not present, the edge is considered to have
    infinite capacity. Default value: 'capacity'.

flow_func : function
    A function for computing the maximum flow among a pair of nodes
    in a capacitated graph. The function has to accept at least three
    parameters: a Graph or Digraph, a source node, and a target node.
    And return a residual network that follows NetworkX conventions
    (see Notes). If flow_func is None, the default maximum
    flow function (:meth:`preflow_push`) is used. See below for
    alternative algorithms. The choice of the default function may change
    from version to version and should not be relied on. Default value:
    None.

kwargs : Any other keyword parameter is passed to the function that
    computes the maximum flow.

Returns
-------
cut_value : integer, float
    Value of the minimum cut.

Raises
------
NetworkXUnbounded
    If the graph has a path of infinite capacity, all cuts have
    infinite capacity and the function raises a NetworkXError.

See also
--------
:meth:`maximum_flow`
:meth:`maximum_flow_value`
:meth:`minimum_cut`
:meth:`edmonds_karp`
:meth:`preflow_push`
:meth:`shortest_augmenting_path`

Notes
-----
The function used in the flow_func parameter has to return a residual
network that follows NetworkX conventions:

The residual network :samp:`R` from an input graph :samp:`G` has the
same nodes as :samp:`G`. :samp:`R` is a DiGraph that contains a pair
of edges :samp:`(u, v)` and :samp:`(v, u)` iff :samp:`(u, v)` is not a
self-loop, and at least one of :samp:`(u, v)` and :samp:`(v, u)` exists
in :samp:`G`.

For each edge :samp:`(u, v)` in :samp:`R`, :samp:`R[u][v]['capacity']`
is equal to the capacity of :samp:`(u, v)` in :samp:`G` if it exists
in :samp:`G` or zero otherwise. If the capacity is infinite,
:samp:`R[u][v]['capacity']` will have a high arbitrary finite value
that does not affect the solution of the problem. This value is stored in
:samp:`R.graph['inf']`. For each edge :samp:`(u, v)` in :samp:`R`,
:samp:`R[u][v]['flow']` represents the flow function of :samp:`(u, v)` and
satisfies :samp:`R[u][v]['flow'] == -R[v][u]['flow']`.

The flow value, defined as the total flow into :samp:`t`, the sink, is
stored in :samp:`R.graph['flow_value']`. Reachability to :samp:`t` using
only edges :samp:`(u, v)` such that
:samp:`R[u][v]['flow'] &lt; R[u][v]['capacity']` induces a minimum
:samp:`s`-:samp:`t` cut.

Specific algorithms may store extra data in :samp:`R`.

The function should supports an optional boolean parameter value_only. When
True, it can optionally terminate the algorithm as soon as the maximum flow
value and the minimum cut can be determined.

Examples
--------
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_edge("x", "a", capacity=3.0)
&gt;&gt;&gt; G.add_edge("x", "b", capacity=1.0)
&gt;&gt;&gt; G.add_edge("a", "c", capacity=3.0)
&gt;&gt;&gt; G.add_edge("b", "c", capacity=5.0)
&gt;&gt;&gt; G.add_edge("b", "d", capacity=4.0)
&gt;&gt;&gt; G.add_edge("d", "e", capacity=2.0)
&gt;&gt;&gt; G.add_edge("c", "y", capacity=2.0)
&gt;&gt;&gt; G.add_edge("e", "y", capacity=3.0)

minimum_cut_value computes only the value of the
minimum cut:

&gt;&gt;&gt; cut_value = nx.minimum_cut_value(G, "x", "y")
&gt;&gt;&gt; cut_value
3.0

You can also use alternative algorithms for computing the
minimum cut by using the flow_func parameter.

&gt;&gt;&gt; from networkx.algorithms.flow import shortest_augmenting_path
&gt;&gt;&gt; cut_value == nx.minimum_cut_value(
...     G, "x", "y", flow_func=shortest_augmenting_path
... )
True</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a857a2f8be172db71de98b250db0394fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857a2f8be172db71de98b250db0394fa">&#9670;&nbsp;</a></span>default_flow_func</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">networkx.algorithms.flow.maxflow.default_flow_func</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5243b2ab0dc59ea61b7a11730e419299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5243b2ab0dc59ea61b7a11730e419299">&#9670;&nbsp;</a></span>flow_funcs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">networkx.algorithms.flow.maxflow.flow_funcs</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
