<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.bipartite.centrality Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite.html">bipartite</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1centrality.html">centrality</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.bipartite.centrality Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a98a64581dd9879f03a3c698f360bab2d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1centrality.html#a98a64581dd9879f03a3c698f360bab2d">degree_centrality</a> (G, nodes)</td></tr>
<tr class="separator:a98a64581dd9879f03a3c698f360bab2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709a14c14c168b920c5c80569364ff9f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1centrality.html#a709a14c14c168b920c5c80569364ff9f">betweenness_centrality</a> (G, nodes)</td></tr>
<tr class="separator:a709a14c14c168b920c5c80569364ff9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d12405f1ad5f68f8d32f71e32fea4a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1centrality.html#af8d12405f1ad5f68f8d32f71e32fea4a">closeness_centrality</a> (G, nodes, normalized=True)</td></tr>
<tr class="separator:af8d12405f1ad5f68f8d32f71e32fea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a709a14c14c168b920c5c80569364ff9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709a14c14c168b920c5c80569364ff9f">&#9670;&nbsp;</a></span>betweenness_centrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.centrality.betweenness_centrality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute betweenness centrality for nodes in a bipartite network.

Betweenness centrality of a node `v` is the sum of the
fraction of all-pairs shortest paths that pass through `v`.

Values of betweenness are normalized by the maximum possible
value which for bipartite graphs is limited by the relative size
of the two node sets [1]_.

Let `n` be the number of nodes in the node set `U` and
`m` be the number of nodes in the node set `V`, then
nodes in `U` are normalized by dividing by

.. math::

   \frac{1}{2} [m^2 (s + 1)^2 + m (s + 1)(2t - s - 1) - t (2s - t + 3)] ,

where

.. math::

    s = (n - 1) \div m , t = (n - 1) \mod m ,

and nodes in `V` are normalized by dividing by

.. math::

    \frac{1}{2} [n^2 (p + 1)^2 + n (p + 1)(2r - p - 1) - r (2p - r + 3)] ,

where,

.. math::

    p = (m - 1) \div n , r = (m - 1) \mod n .

Parameters
----------
G : graph
    A bipartite graph

nodes : list or container
    Container with all nodes in one bipartite node set.

Returns
-------
betweenness : dictionary
    Dictionary keyed by node with bipartite betweenness centrality
    as the value.

See Also
--------
degree_centrality
closeness_centrality
:func:`~networkx.algorithms.bipartite.basic.sets`
:func:`~networkx.algorithms.bipartite.basic.is_bipartite`

Notes
-----
The nodes input parameter must contain all nodes in one bipartite node set,
but the dictionary returned contains all nodes from both node sets.
See :mod:`bipartite documentation &lt;networkx.algorithms.bipartite&gt;`
for further details on how bipartite graphs are handled in NetworkX.


References
----------
.. [1] Borgatti, S.P. and Halgin, D. In press. "Analyzing Affiliation
    Networks". In Carrington, P. and Scott, J. (eds) The Sage Handbook
    of Social Network Analysis. Sage Publications.
    https://dx.doi.org/10.4135/9781446294413.n28
</pre> 
</div>
</div>
<a id="af8d12405f1ad5f68f8d32f71e32fea4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d12405f1ad5f68f8d32f71e32fea4a">&#9670;&nbsp;</a></span>closeness_centrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.centrality.closeness_centrality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the closeness centrality for nodes in a bipartite network.

The closeness of a node is the distance to all other nodes in the
graph or in the case that the graph is not connected to all other nodes
in the connected component containing that node.

Parameters
----------
G : graph
    A bipartite network

nodes : list or container
    Container with all nodes in one bipartite node set.

normalized : bool, optional
  If True (default) normalize by connected component size.

Returns
-------
closeness : dictionary
    Dictionary keyed by node with bipartite closeness centrality
    as the value.

See Also
--------
betweenness_centrality
degree_centrality
:func:`~networkx.algorithms.bipartite.basic.sets`
:func:`~networkx.algorithms.bipartite.basic.is_bipartite`

Notes
-----
The nodes input parameter must contain all nodes in one bipartite node set,
but the dictionary returned contains all nodes from both node sets.
See :mod:`bipartite documentation &lt;networkx.algorithms.bipartite&gt;`
for further details on how bipartite graphs are handled in NetworkX.


Closeness centrality is normalized by the minimum distance possible.
In the bipartite case the minimum distance for a node in one bipartite
node set is 1 from all nodes in the other node set and 2 from all
other nodes in its own set [1]_. Thus the closeness centrality
for node `v`  in the two bipartite sets `U` with
`n` nodes and `V` with `m` nodes is

.. math::

    c_{v} = \frac{m + 2(n - 1)}{d}, \mbox{for} v \in U,

    c_{v} = \frac{n + 2(m - 1)}{d}, \mbox{for} v \in V,

where `d` is the sum of the distances from `v` to all
other nodes.

Higher values of closeness  indicate higher centrality.

As in the unipartite case, setting normalized=True causes the
values to normalized further to n-1 / size(G)-1 where n is the
number of nodes in the connected part of graph containing the
node.  If the graph is not completely connected, this algorithm
computes the closeness centrality for each connected part
separately.

References
----------
.. [1] Borgatti, S.P. and Halgin, D. In press. "Analyzing Affiliation
    Networks". In Carrington, P. and Scott, J. (eds) The Sage Handbook
    of Social Network Analysis. Sage Publications.
    https://dx.doi.org/10.4135/9781446294413.n28
</pre> 
</div>
</div>
<a id="a98a64581dd9879f03a3c698f360bab2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a64581dd9879f03a3c698f360bab2d">&#9670;&nbsp;</a></span>degree_centrality()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.centrality.degree_centrality </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the degree centrality for nodes in a bipartite network.

The degree centrality for a node `v` is the fraction of nodes
connected to it.

Parameters
----------
G : graph
   A bipartite network

nodes : list or container
  Container with all nodes in one bipartite node set.

Returns
-------
centrality : dictionary
   Dictionary keyed by node with bipartite degree centrality as the value.

See Also
--------
betweenness_centrality
closeness_centrality
:func:`~networkx.algorithms.bipartite.basic.sets`
:func:`~networkx.algorithms.bipartite.basic.is_bipartite`

Notes
-----
The nodes input parameter must contain all nodes in one bipartite node set,
but the dictionary returned contains all nodes from both bipartite node
sets. See :mod:`bipartite documentation &lt;networkx.algorithms.bipartite&gt;`
for further details on how bipartite graphs are handled in NetworkX.

For unipartite networks, the degree centrality values are
normalized by dividing by the maximum possible degree (which is
`n-1` where `n` is the number of nodes in G).

In the bipartite case, the maximum possible degree of a node in a
bipartite node set is the number of nodes in the opposite node set
[1]_.  The degree centrality for a node `v` in the bipartite
sets `U` with `n` nodes and `V` with `m` nodes is

.. math::

    d_{v} = \frac{deg(v)}{m}, \mbox{for} v \in U ,

    d_{v} = \frac{deg(v)}{n}, \mbox{for} v \in V ,


where `deg(v)` is the degree of node `v`.

References
----------
.. [1] Borgatti, S.P. and Halgin, D. In press. "Analyzing Affiliation
    Networks". In Carrington, P. and Scott, J. (eds) The Sage Handbook
    of Social Network Analysis. Sage Publications.
    https://dx.doi.org/10.4135/9781446294413.n28
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
