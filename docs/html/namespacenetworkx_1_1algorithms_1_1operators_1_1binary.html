<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.operators.binary Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1operators.html">operators</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1operators_1_1binary.html">binary</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.operators.binary Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a50ec19daf9362376b5b30a6cecd15332"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1operators_1_1binary.html#a50ec19daf9362376b5b30a6cecd15332">union</a> (G, H, rename=(None, None), name=None)</td></tr>
<tr class="separator:a50ec19daf9362376b5b30a6cecd15332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a3e1feb5877673d0f4398390ee0827"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1operators_1_1binary.html#a24a3e1feb5877673d0f4398390ee0827">disjoint_union</a> (G, H)</td></tr>
<tr class="separator:a24a3e1feb5877673d0f4398390ee0827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbc0da1f63a3b76f5180a315493b2045"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1operators_1_1binary.html#adbc0da1f63a3b76f5180a315493b2045">intersection</a> (G, H)</td></tr>
<tr class="separator:adbc0da1f63a3b76f5180a315493b2045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1344a1a58fd6b4c9b548ec21696106"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1operators_1_1binary.html#a7f1344a1a58fd6b4c9b548ec21696106">difference</a> (G, H)</td></tr>
<tr class="separator:a7f1344a1a58fd6b4c9b548ec21696106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3003e6b8541bbe1ee2b7ef1339a490"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1operators_1_1binary.html#a5e3003e6b8541bbe1ee2b7ef1339a490">symmetric_difference</a> (G, H)</td></tr>
<tr class="separator:a5e3003e6b8541bbe1ee2b7ef1339a490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac06181fb38342d26d2425f250de7320"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1operators_1_1binary.html#aac06181fb38342d26d2425f250de7320">compose</a> (G, H)</td></tr>
<tr class="separator:aac06181fb38342d26d2425f250de7320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccd668d718078b0f4578e55274e590f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1operators_1_1binary.html#a4ccd668d718078b0f4578e55274e590f">full_join</a> (G, H, rename=(None, None))</td></tr>
<tr class="separator:a4ccd668d718078b0f4578e55274e590f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Operations on graphs including union, intersection, difference.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="aac06181fb38342d26d2425f250de7320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac06181fb38342d26d2425f250de7320">&#9670;&nbsp;</a></span>compose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.operators.binary.compose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a new graph of G composed with H.

Composition is the simple union of the node sets and edge sets.
The node sets of G and H do not need to be disjoint.

Parameters
----------
G, H : graph
   A NetworkX graph

Returns
-------
C: A new graph  with the same type as G

Notes
-----
It is recommended that G and H be either both directed or both undirected.
Attributes from H take precedent over attributes from G.

For MultiGraphs, the edges are identified by incident nodes AND edge-key.
This can cause surprises (i.e., edge `(1, 2)` may or may not be the same
in two graphs) if you use MultiGraph without keeping track of edge keys.
</pre> 
</div>
</div>
<a id="a7f1344a1a58fd6b4c9b548ec21696106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1344a1a58fd6b4c9b548ec21696106">&#9670;&nbsp;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.operators.binary.difference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a new graph that contains the edges that exist in G but not in H.

The node sets of H and G must be the same.

Parameters
----------
G,H : graph
   A NetworkX graph.  G and H must have the same node sets.

Returns
-------
D : A new graph with the same type as G.

Notes
-----
Attributes from the graph, nodes, and edges are not copied to the new
graph.  If you want a new graph of the difference of G and H with
the attributes (including edge data) from G use remove_nodes_from()
as follows:

&gt;&gt;&gt; G = nx.path_graph(3)
&gt;&gt;&gt; H = nx.path_graph(5)
&gt;&gt;&gt; R = G.copy()
&gt;&gt;&gt; R.remove_nodes_from(n for n in G if n in H)
</pre> 
</div>
</div>
<a id="a24a3e1feb5877673d0f4398390ee0827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a3e1feb5877673d0f4398390ee0827">&#9670;&nbsp;</a></span>disjoint_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.operators.binary.disjoint_union </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the disjoint union of graphs G and H.

This algorithm forces distinct integer node labels.

Parameters
----------
G,H : graph
   A NetworkX graph

Returns
-------
U : A union graph with the same type as G.

Notes
-----
A new graph is created, of the same class as G.  It is recommended
that G and H be either both directed or both undirected.

The nodes of G are relabeled 0 to len(G)-1, and the nodes of H are
relabeled len(G) to len(G)+len(H)-1.

Graph, edge, and node attributes are propagated from G and H
to the union graph.  If a graph attribute is present in both
G and H the value from H is used.
</pre> 
</div>
</div>
<a id="a4ccd668d718078b0f4578e55274e590f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccd668d718078b0f4578e55274e590f">&#9670;&nbsp;</a></span>full_join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.operators.binary.full_join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rename</em> = <code>(None,&#160;None)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the full join of graphs G and H.

Full join is the union of G and H in which all edges between
G and H are added.
The node sets of G and H must be disjoint,
otherwise an exception is raised.

Parameters
----------
G, H : graph
   A NetworkX graph

rename : bool , default=(None, None)
   Node names of G and H can be changed by specifying the tuple
   rename=('G-','H-') (for example).  Node "u" in G is then renamed
   "G-u" and "v" in H is renamed "H-v".

Returns
-------
U : The full join graph with the same type as G.

Notes
-----
It is recommended that G and H be either both directed or both undirected.

If G is directed, then edges from G to H are added as well as from H to G.

Note that full_join() does not produce parallel edges for MultiGraphs.

The full join operation of graphs G and H is the same as getting
their complement, performing a disjoint union, and finally getting
the complement of the resulting graph.

Graph, edge, and node attributes are propagated from G and H
to the union graph.  If a graph attribute is present in both
G and H the value from H is used.

See Also
--------
union
disjoint_union
</pre> 
</div>
</div>
<a id="adbc0da1f63a3b76f5180a315493b2045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbc0da1f63a3b76f5180a315493b2045">&#9670;&nbsp;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.operators.binary.intersection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a new graph that contains only the nodes and the edges that exist in
both G and H.

Parameters
----------
G,H : graph
   A NetworkX graph. G and H can have different node sets but must be both graphs or both multigraphs.

Raises
------
NetworkXError
    If one is a MultiGraph and the other one is a graph.

Returns
-------
GH : A new graph with the same type as G.

Notes
-----
Attributes from the graph, nodes, and edges are not copied to the new
graph.  If you want a new graph of the intersection of G and H
with the attributes (including edge data) from G use remove_nodes_from()
as follows

&gt;&gt;&gt; G = nx.path_graph(3)
&gt;&gt;&gt; H = nx.path_graph(5)
&gt;&gt;&gt; R = G.copy()
&gt;&gt;&gt; R.remove_nodes_from(n for n in G if n not in H)
&gt;&gt;&gt; R.remove_edges_from(e for e in G.edges if e not in H.edges)
</pre> 
</div>
</div>
<a id="a5e3003e6b8541bbe1ee2b7ef1339a490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3003e6b8541bbe1ee2b7ef1339a490">&#9670;&nbsp;</a></span>symmetric_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.operators.binary.symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns new graph with edges that exist in either G or H but not both.

The node sets of H and G must be the same.

Parameters
----------
G,H : graph
   A NetworkX graph.  G and H must have the same node sets.

Returns
-------
D : A new graph with the same type as G.

Notes
-----
Attributes from the graph, nodes, and edges are not copied to the new
graph.
</pre> 
</div>
</div>
<a id="a50ec19daf9362376b5b30a6cecd15332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ec19daf9362376b5b30a6cecd15332">&#9670;&nbsp;</a></span>union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.operators.binary.union </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rename</em> = <code>(None,&#160;None)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the union of graphs G and H.

Graphs G and H must be disjoint, otherwise an exception is raised.

Parameters
----------
G,H : graph
   A NetworkX graph

rename : bool , default=(None, None)
   Node names of G and H can be changed by specifying the tuple
   rename=('G-','H-') (for example).  Node "u" in G is then renamed
   "G-u" and "v" in H is renamed "H-v".

name : string
   Specify the name for the union graph

Returns
-------
U : A union graph with the same type as G.

Notes
-----
To force a disjoint union with node relabeling, use
disjoint_union(G,H) or convert_node_labels_to integers().

Graph, edge, and node attributes are propagated from G and H
to the union graph.  If a graph attribute is present in both
G and H the value from H is used.

See Also
--------
disjoint_union
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
