<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.generators.geometric Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1generators.html">generators</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1generators_1_1geometric.html">geometric</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.generators.geometric Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af251647619091b18e2f1042d974e6b29"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1geometric.html#af251647619091b18e2f1042d974e6b29">euclidean</a> (x, y)</td></tr>
<tr class="separator:af251647619091b18e2f1042d974e6b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca2553d54d1f2aeb54c71aa8d98e05f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1geometric.html#a4ca2553d54d1f2aeb54c71aa8d98e05f">geometric_edges</a> (G, radius, p)</td></tr>
<tr class="separator:a4ca2553d54d1f2aeb54c71aa8d98e05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0380de561153f3a41d8ea691df02370"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1geometric.html#aa0380de561153f3a41d8ea691df02370">random_geometric_graph</a> (n, radius, dim=2, pos=None, p=2, seed=None)</td></tr>
<tr class="separator:aa0380de561153f3a41d8ea691df02370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8a8e869f0ada3f64fabf3d53129d21"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1geometric.html#a9f8a8e869f0ada3f64fabf3d53129d21">soft_random_geometric_graph</a> (n, radius, dim=2, pos=None, p=2, p_dist=None, seed=None)</td></tr>
<tr class="separator:a9f8a8e869f0ada3f64fabf3d53129d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b2aa9a0067889b2dee22782d49ab28"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1geometric.html#ab0b2aa9a0067889b2dee22782d49ab28">geographical_threshold_graph</a> (n, theta, dim=2, pos=None, weight=None, metric=None, p_dist=None, seed=None)</td></tr>
<tr class="separator:ab0b2aa9a0067889b2dee22782d49ab28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9714b30e53e8104685d8b550db52e705"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1geometric.html#a9714b30e53e8104685d8b550db52e705">waxman_graph</a> (n, beta=0.4, alpha=0.1, L=None, domain=(0, 0, 1, 1), metric=None, seed=None)</td></tr>
<tr class="separator:a9714b30e53e8104685d8b550db52e705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23a02dfb8c6fd5f1ec50680c7f7a59e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1geometric.html#ac23a02dfb8c6fd5f1ec50680c7f7a59e">navigable_small_world_graph</a> (n, p=1, q=1, r=2, dim=2, seed=None)</td></tr>
<tr class="separator:ac23a02dfb8c6fd5f1ec50680c7f7a59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1924e6b8a54833447193d3ebdc2e81c4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1geometric.html#a1924e6b8a54833447193d3ebdc2e81c4">thresholded_random_geometric_graph</a> (n, radius, theta, dim=2, pos=None, weight=None, p=2, seed=None)</td></tr>
<tr class="separator:a1924e6b8a54833447193d3ebdc2e81c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Generators for geometric graphs.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="af251647619091b18e2f1042d974e6b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af251647619091b18e2f1042d974e6b29">&#9670;&nbsp;</a></span>euclidean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.geometric.euclidean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the Euclidean distance between the vectors ``x`` and ``y``.

Each of ``x`` and ``y`` can be any iterable of numbers. The
iterables must be of the same length.</pre> 
</div>
</div>
<a id="ab0b2aa9a0067889b2dee22782d49ab28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b2aa9a0067889b2dee22782d49ab28">&#9670;&nbsp;</a></span>geographical_threshold_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.geometric.geographical_threshold_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_dist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a geographical threshold graph.

The geographical threshold graph model places $n$ nodes uniformly at
random in a rectangular domain.  Each node $u$ is assigned a weight
$w_u$. Two nodes $u$ and $v$ are joined by an edge if

.. math::

   (w_u + w_v)h(r) \ge \theta

where `r` is the distance between `u` and `v`, h(r) is a probability of
connection as a function of `r`, and :math:`\theta` as the threshold
parameter. h(r) corresponds to the p_dist parameter.

Parameters
----------
n : int or iterable
    Number of nodes or iterable of nodes
theta: float
    Threshold value
dim : int, optional
    Dimension of graph
pos : dict
    Node positions as a dictionary of tuples keyed by node.
weight : dict
    Node weights as a dictionary of numbers keyed by node.
metric : function
    A metric on vectors of numbers (represented as lists or
    tuples). This must be a function that accepts two lists (or
    tuples) as input and yields a number as output. The function
    must also satisfy the four requirements of a `metric`_.
    Specifically, if $d$ is the function and $x$, $y$,
    and $z$ are vectors in the graph, then $d$ must satisfy

    1. $d(x, y) \ge 0$,
    2. $d(x, y) = 0$ if and only if $x = y$,
    3. $d(x, y) = d(y, x)$,
    4. $d(x, z) \le d(x, y) + d(y, z)$.

    If this argument is not specified, the Euclidean distance metric is
    used.

    .. _metric: https://en.wikipedia.org/wiki/Metric_%28mathematics%29
p_dist : function, optional
    A probability density function computing the probability of
    connecting two nodes that are of distance, r, computed by metric.
    The probability density function, `p_dist`, must
    be any function that takes the metric value as input
    and outputs a single probability value between 0-1.
    The scipy.stats package has many probability distribution functions
    implemented and tools for custom probability distribution
    definitions [2], and passing the .pdf method of scipy.stats
    distributions can be used here. If the probability
    function, `p_dist`, is not supplied, the default exponential function
    :math: `r^{-2}` is used.
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
Graph
    A random geographic threshold graph, undirected and without
    self-loops.

    Each node has a node attribute ``pos`` that stores the
    position of that node in Euclidean space as provided by the
    ``pos`` keyword argument or, if ``pos`` was not provided, as
    generated by this function. Similarly, each node has a node
    attribute ``weight`` that stores the weight of that node as
    provided or as generated.

Examples
--------
Specify an alternate distance metric using the ``metric`` keyword
argument. For example, to use the `taxicab metric`_ instead of the
default `Euclidean metric`_::

    &gt;&gt;&gt; dist = lambda x, y: sum(abs(a - b) for a, b in zip(x, y))
    &gt;&gt;&gt; G = nx.geographical_threshold_graph(10, 0.1, metric=dist)

.. _taxicab metric: https://en.wikipedia.org/wiki/Taxicab_geometry
.. _Euclidean metric: https://en.wikipedia.org/wiki/Euclidean_distance

Notes
-----
If weights are not specified they are assigned to nodes by drawing randomly
from the exponential distribution with rate parameter $\lambda=1$.
To specify weights from a different distribution, use the `weight` keyword
argument::

&gt;&gt;&gt; import random
&gt;&gt;&gt; n = 20
&gt;&gt;&gt; w = {i: random.expovariate(5.0) for i in range(n)}
&gt;&gt;&gt; G = nx.geographical_threshold_graph(20, 50, weight=w)

If node positions are not specified they are randomly assigned from the
uniform distribution.

References
----------
.. [1] Masuda, N., Miwa, H., Konno, N.:
   Geographical threshold graphs with small-world and scale-free
   properties.
   Physical Review E 71, 036108 (2005)
.. [2]  Milan Bradonjić, Aric Hagberg and Allon G. Percus,
   Giant component and connectivity in geographical threshold graphs,
   in Algorithms and Models for the Web-Graph (WAW 2007),
   Antony Bonato and Fan Chung (Eds), pp. 209--216, 2007
</pre> 
</div>
</div>
<a id="a4ca2553d54d1f2aeb54c71aa8d98e05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca2553d54d1f2aeb54c71aa8d98e05f">&#9670;&nbsp;</a></span>geometric_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.geometric.geometric_edges </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns edge list of node pairs within `radius` of each other

Radius uses Minkowski distance metric `p`.
If scipy available, use scipy cKDTree to speed computation.
</pre> 
</div>
</div>
<a id="ac23a02dfb8c6fd5f1ec50680c7f7a59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23a02dfb8c6fd5f1ec50680c7f7a59e">&#9670;&nbsp;</a></span>navigable_small_world_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.geometric.navigable_small_world_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>q</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a navigable small-world graph.

A navigable small-world graph is a directed grid with additional long-range
connections that are chosen randomly.

  [...] we begin with a set of nodes [...] that are identified with the set
  of lattice points in an $n \times n$ square,
  $\{(i, j): i \in \{1, 2, \ldots, n\}, j \in \{1, 2, \ldots, n\}\}$,
  and we define the *lattice distance* between two nodes $(i, j)$ and
  $(k, l)$ to be the number of "lattice steps" separating them:
  $d((i, j), (k, l)) = |k - i| + |l - j|$.

  For a universal constant $p &gt;= 1$, the node $u$ has a directed edge to
  every other node within lattice distance $p$---these are its *local
  contacts*. For universal constants $q &gt;= 0$ and $r &gt;= 0$ we also
  construct directed edges from $u$ to $q$ other nodes (the *long-range
  contacts*) using independent random trials; the $i$th directed edge from
  $u$ has endpoint $v$ with probability proportional to $[d(u,v)]^{-r}$.

  -- [1]_

Parameters
----------
n : int
    The length of one side of the lattice; the number of nodes in
    the graph is therefore $n^2$.
p : int
    The diameter of short range connections. Each node is joined with every
    other node within this lattice distance.
q : int
    The number of long-range connections for each node.
r : float
    Exponent for decaying probability of connections.  The probability of
    connecting to a node at lattice distance $d$ is $1/d^r$.
dim : int
    Dimension of grid
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

References
----------
.. [1] J. Kleinberg. The small-world phenomenon: An algorithmic
   perspective. Proc. 32nd ACM Symposium on Theory of Computing, 2000.
</pre> 
</div>
</div>
<a id="aa0380de561153f3a41d8ea691df02370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0380de561153f3a41d8ea691df02370">&#9670;&nbsp;</a></span>random_geometric_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.geometric.random_geometric_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a random geometric graph in the unit cube of dimensions `dim`.

The random geometric graph model places `n` nodes uniformly at
random in the unit cube. Two nodes are joined by an edge if the
distance between the nodes is at most `radius`.

Edges are determined using a KDTree when SciPy is available.
This reduces the time complexity from $O(n^2)$ to $O(n)$.

Parameters
----------
n : int or iterable
    Number of nodes or iterable of nodes
radius: float
    Distance threshold value
dim : int, optional
    Dimension of graph
pos : dict, optional
    A dictionary keyed by node with node positions as values.
p : float, optional
    Which Minkowski distance metric to use.  `p` has to meet the condition
    ``1 &lt;= p &lt;= infinity``.

    If this argument is not specified, the :math:`L^2` metric
    (the Euclidean distance metric), p = 2 is used.
    This should not be confused with the `p` of an Erdős-Rényi random
    graph, which represents probability.
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
Graph
    A random geometric graph, undirected and without self-loops.
    Each node has a node attribute ``'pos'`` that stores the
    position of that node in Euclidean space as provided by the
    ``pos`` keyword argument or, if ``pos`` was not provided, as
    generated by this function.

Examples
--------
Create a random geometric graph on twenty nodes where nodes are joined by
an edge if their distance is at most 0.1::

&gt;&gt;&gt; G = nx.random_geometric_graph(20, 0.1)

Notes
-----
This uses a *k*-d tree to build the graph.

The `pos` keyword argument can be used to specify node positions so you
can create an arbitrary distribution and domain for positions.

For example, to use a 2D Gaussian distribution of node positions with mean
(0, 0) and standard deviation 2::

&gt;&gt;&gt; import random
&gt;&gt;&gt; n = 20
&gt;&gt;&gt; pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i in range(n)}
&gt;&gt;&gt; G = nx.random_geometric_graph(n, 0.2, pos=pos)

References
----------
.. [1] Penrose, Mathew, *Random Geometric Graphs*,
       Oxford Studies in Probability, 5, 2003.</pre> 
</div>
</div>
<a id="a9f8a8e869f0ada3f64fabf3d53129d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8a8e869f0ada3f64fabf3d53129d21">&#9670;&nbsp;</a></span>soft_random_geometric_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.geometric.soft_random_geometric_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_dist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a soft random geometric graph in the unit cube.

The soft random geometric graph [1] model places `n` nodes uniformly at
random in the unit cube in dimension `dim`. Two nodes of distance, `dist`,
computed by the `p`-Minkowski distance metric are joined by an edge with
probability `p_dist` if the computed distance metric value of the nodes
is at most `radius`, otherwise they are not joined.

Edges within `radius` of each other are determined using a KDTree when
SciPy is available. This reduces the time complexity from :math:`O(n^2)`
to :math:`O(n)`.

Parameters
----------
n : int or iterable
    Number of nodes or iterable of nodes
radius: float
    Distance threshold value
dim : int, optional
    Dimension of graph
pos : dict, optional
    A dictionary keyed by node with node positions as values.
p : float, optional
    Which Minkowski distance metric to use.
    `p` has to meet the condition ``1 &lt;= p &lt;= infinity``.

    If this argument is not specified, the :math:`L^2` metric
    (the Euclidean distance metric), p = 2 is used.

    This should not be confused with the `p` of an Erdős-Rényi random
    graph, which represents probability.
p_dist : function, optional
    A probability density function computing the probability of
    connecting two nodes that are of distance, dist, computed by the
    Minkowski distance metric. The probability density function, `p_dist`,
    must be any function that takes the metric value as input
    and outputs a single probability value between 0-1. The scipy.stats
    package has many probability distribution functions implemented and
    tools for custom probability distribution definitions [2], and passing
    the .pdf method of scipy.stats distributions can be used here.  If the
    probability function, `p_dist`, is not supplied, the default function
    is an exponential distribution with rate parameter :math:`\lambda=1`.
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
Graph
    A soft random geometric graph, undirected and without self-loops.
    Each node has a node attribute ``'pos'`` that stores the
    position of that node in Euclidean space as provided by the
    ``pos`` keyword argument or, if ``pos`` was not provided, as
    generated by this function.

Examples
--------
Default Graph:

G = nx.soft_random_geometric_graph(50, 0.2)

Custom Graph:

Create a soft random geometric graph on 100 uniformly distributed nodes
where nodes are joined by an edge with probability computed from an
exponential distribution with rate parameter :math:`\lambda=1` if their
Euclidean distance is at most 0.2.

Notes
-----
This uses a *k*-d tree to build the graph.

The `pos` keyword argument can be used to specify node positions so you
can create an arbitrary distribution and domain for positions.

For example, to use a 2D Gaussian distribution of node positions with mean
(0, 0) and standard deviation 2

The scipy.stats package can be used to define the probability distribution
with the .pdf method used as `p_dist`.

::

&gt;&gt;&gt; import random
&gt;&gt;&gt; import math
&gt;&gt;&gt; n = 100
&gt;&gt;&gt; pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i in range(n)}
&gt;&gt;&gt; p_dist = lambda dist: math.exp(-dist)
&gt;&gt;&gt; G = nx.soft_random_geometric_graph(n, 0.2, pos=pos, p_dist=p_dist)

References
----------
.. [1] Penrose, Mathew D. "Connectivity of soft random geometric graphs."
       The Annals of Applied Probability 26.2 (2016): 986-1028.
.. [2] scipy.stats -
       https://docs.scipy.org/doc/scipy/reference/tutorial/stats.html</pre> 
</div>
</div>
<a id="a1924e6b8a54833447193d3ebdc2e81c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1924e6b8a54833447193d3ebdc2e81c4">&#9670;&nbsp;</a></span>thresholded_random_geometric_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.geometric.thresholded_random_geometric_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dim</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pos</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a thresholded random geometric graph in the unit cube.

The thresholded random geometric graph [1] model places `n` nodes
uniformly at random in the unit cube of dimensions `dim`. Each node
`u` is assigned a weight :math:`w_u`. Two nodes `u` and `v` are
joined by an edge if they are within the maximum connection distance,
`radius` computed by the `p`-Minkowski distance and the summation of
weights :math:`w_u` + :math:`w_v` is greater than or equal
to the threshold parameter `theta`.

Edges within `radius` of each other are determined using a KDTree when
SciPy is available. This reduces the time complexity from :math:`O(n^2)`
to :math:`O(n)`.

Parameters
----------
n : int or iterable
    Number of nodes or iterable of nodes
radius: float
    Distance threshold value
theta: float
    Threshold value
dim : int, optional
    Dimension of graph
pos : dict, optional
    A dictionary keyed by node with node positions as values.
weight : dict, optional
    Node weights as a dictionary of numbers keyed by node.
p : float, optional (default 2)
    Which Minkowski distance metric to use.  `p` has to meet the condition
    ``1 &lt;= p &lt;= infinity``.

    If this argument is not specified, the :math:`L^2` metric
    (the Euclidean distance metric), p = 2 is used.

    This should not be confused with the `p` of an Erdős-Rényi random
    graph, which represents probability.
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
Graph
    A thresholded random geographic graph, undirected and without
    self-loops.

    Each node has a node attribute ``'pos'`` that stores the
    position of that node in Euclidean space as provided by the
    ``pos`` keyword argument or, if ``pos`` was not provided, as
    generated by this function. Similarly, each node has a nodethre
    attribute ``'weight'`` that stores the weight of that node as
    provided or as generated.

Examples
--------
Default Graph:

G = nx.thresholded_random_geometric_graph(50, 0.2, 0.1)

Custom Graph:

Create a thresholded random geometric graph on 50 uniformly distributed
nodes where nodes are joined by an edge if their sum weights drawn from
a exponential distribution with rate = 5 are &gt;= theta = 0.1 and their
Euclidean distance is at most 0.2.

Notes
-----
This uses a *k*-d tree to build the graph.

The `pos` keyword argument can be used to specify node positions so you
can create an arbitrary distribution and domain for positions.

For example, to use a 2D Gaussian distribution of node positions with mean
(0, 0) and standard deviation 2

If weights are not specified they are assigned to nodes by drawing randomly
from the exponential distribution with rate parameter :math:`\lambda=1`.
To specify weights from a different distribution, use the `weight` keyword
argument::

::

&gt;&gt;&gt; import random
&gt;&gt;&gt; import math
&gt;&gt;&gt; n = 50
&gt;&gt;&gt; pos = {i: (random.gauss(0, 2), random.gauss(0, 2)) for i in range(n)}
&gt;&gt;&gt; w = {i: random.expovariate(5.0) for i in range(n)}
&gt;&gt;&gt; G = nx.thresholded_random_geometric_graph(n, 0.2, 0.1, 2, pos, w)

References
----------
.. [1] http://cole-maclean.github.io/blog/files/thesis.pdf</pre> 
</div>
</div>
<a id="a9714b30e53e8104685d8b550db52e705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9714b30e53e8104685d8b550db52e705">&#9670;&nbsp;</a></span>waxman_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.geometric.waxman_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em> = <code>0.4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>(0,&#160;0,&#160;1,&#160;1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a Waxman random graph.

The Waxman random graph model places `n` nodes uniformly at random
in a rectangular domain. Each pair of nodes at distance `d` is
joined by an edge with probability

.. math::
        p = \beta \exp(-d / \alpha L).

This function implements both Waxman models, using the `L` keyword
argument.

* Waxman-1: if `L` is not specified, it is set to be the maximum distance
  between any pair of nodes.
* Waxman-2: if `L` is specified, the distance between a pair of nodes is
  chosen uniformly at random from the interval `[0, L]`.

Parameters
----------
n : int or iterable
    Number of nodes or iterable of nodes
beta: float
    Model parameter
alpha: float
    Model parameter
L : float, optional
    Maximum distance between nodes.  If not specified, the actual distance
    is calculated.
domain : four-tuple of numbers, optional
    Domain size, given as a tuple of the form `(x_min, y_min, x_max,
    y_max)`.
metric : function
    A metric on vectors of numbers (represented as lists or
    tuples). This must be a function that accepts two lists (or
    tuples) as input and yields a number as output. The function
    must also satisfy the four requirements of a `metric`_.
    Specifically, if $d$ is the function and $x$, $y$,
    and $z$ are vectors in the graph, then $d$ must satisfy

    1. $d(x, y) \ge 0$,
    2. $d(x, y) = 0$ if and only if $x = y$,
    3. $d(x, y) = d(y, x)$,
    4. $d(x, z) \le d(x, y) + d(y, z)$.

    If this argument is not specified, the Euclidean distance metric is
    used.

    .. _metric: https://en.wikipedia.org/wiki/Metric_%28mathematics%29

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
Graph
    A random Waxman graph, undirected and without self-loops. Each
    node has a node attribute ``'pos'`` that stores the position of
    that node in Euclidean space as generated by this function.

Examples
--------
Specify an alternate distance metric using the ``metric`` keyword
argument. For example, to use the "`taxicab metric`_" instead of the
default `Euclidean metric`_::

    &gt;&gt;&gt; dist = lambda x, y: sum(abs(a - b) for a, b in zip(x, y))
    &gt;&gt;&gt; G = nx.waxman_graph(10, 0.5, 0.1, metric=dist)

.. _taxicab metric: https://en.wikipedia.org/wiki/Taxicab_geometry
.. _Euclidean metric: https://en.wikipedia.org/wiki/Euclidean_distance

Notes
-----
Starting in NetworkX 2.0 the parameters alpha and beta align with their
usual roles in the probability distribution. In earlier versions their
positions in the expression were reversed. Their position in the calling
sequence reversed as well to minimize backward incompatibility.

References
----------
.. [1]  B. M. Waxman, *Routing of multipoint connections*.
   IEEE J. Select. Areas Commun. 6(9),(1988) 1617--1622.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
