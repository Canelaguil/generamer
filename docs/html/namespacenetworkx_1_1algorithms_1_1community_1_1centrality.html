<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.community.centrality Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1community.html">community</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1community_1_1centrality.html">centrality</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.community.centrality Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab3a5307cb7c52b8a9a3c389a44fd1b75"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1community_1_1centrality.html#ab3a5307cb7c52b8a9a3c389a44fd1b75">girvan_newman</a> (G, most_valuable_edge=None)</td></tr>
<tr class="separator:ab3a5307cb7c52b8a9a3c389a44fd1b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions for computing communities based on centrality notions.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ab3a5307cb7c52b8a9a3c389a44fd1b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a5307cb7c52b8a9a3c389a44fd1b75">&#9670;&nbsp;</a></span>girvan_newman()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.community.centrality.girvan_newman </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>most_valuable_edge</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds communities in a graph using the Girvan–Newman method.

Parameters
----------
G : NetworkX graph

most_valuable_edge : function
    Function that takes a graph as input and outputs an edge. The
    edge returned by this function will be recomputed and removed at
    each iteration of the algorithm.

    If not specified, the edge with the highest
    :func:`networkx.edge_betweenness_centrality` will be used.

Returns
-------
iterator
    Iterator over tuples of sets of nodes in `G`. Each set of node
    is a community, each tuple is a sequence of communities at a
    particular level of the algorithm.

Examples
--------
To get the first pair of communities::

    &gt;&gt;&gt; G = nx.path_graph(10)
    &gt;&gt;&gt; comp = girvan_newman(G)
    &gt;&gt;&gt; tuple(sorted(c) for c in next(comp))
    ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])

To get only the first *k* tuples of communities, use
:func:`itertools.islice`::

    &gt;&gt;&gt; import itertools
    &gt;&gt;&gt; G = nx.path_graph(8)
    &gt;&gt;&gt; k = 2
    &gt;&gt;&gt; comp = girvan_newman(G)
    &gt;&gt;&gt; for communities in itertools.islice(comp, k):
    ...     print(tuple(sorted(c) for c in communities))
    ...
    ([0, 1, 2, 3], [4, 5, 6, 7])
    ([0, 1], [2, 3], [4, 5, 6, 7])

To stop getting tuples of communities once the number of communities
is greater than *k*, use :func:`itertools.takewhile`::

    &gt;&gt;&gt; import itertools
    &gt;&gt;&gt; G = nx.path_graph(8)
    &gt;&gt;&gt; k = 4
    &gt;&gt;&gt; comp = girvan_newman(G)
    &gt;&gt;&gt; limited = itertools.takewhile(lambda c: len(c) &lt;= k, comp)
    &gt;&gt;&gt; for communities in limited:
    ...     print(tuple(sorted(c) for c in communities))
    ...
    ([0, 1, 2, 3], [4, 5, 6, 7])
    ([0, 1], [2, 3], [4, 5, 6, 7])
    ([0, 1], [2, 3], [4, 5], [6, 7])

To just choose an edge to remove based on the weight::

    &gt;&gt;&gt; from operator import itemgetter
    &gt;&gt;&gt; G = nx.path_graph(10)
    &gt;&gt;&gt; edges = G.edges()
    &gt;&gt;&gt; nx.set_edge_attributes(G, {(u, v): v for u, v in edges}, "weight")
    &gt;&gt;&gt; def heaviest(G):
    ...     u, v, w = max(G.edges(data="weight"), key=itemgetter(2))
    ...     return (u, v)
    ...
    &gt;&gt;&gt; comp = girvan_newman(G, most_valuable_edge=heaviest)
    &gt;&gt;&gt; tuple(sorted(c) for c in next(comp))
    ([0, 1, 2, 3, 4, 5, 6, 7, 8], [9])

To utilize edge weights when choosing an edge with, for example, the
highest betweenness centrality::

    &gt;&gt;&gt; from networkx import edge_betweenness_centrality as betweenness
    &gt;&gt;&gt; def most_central_edge(G):
    ...     centrality = betweenness(G, weight="weight")
    ...     return max(centrality, key=centrality.get)
    ...
    &gt;&gt;&gt; G = nx.path_graph(10)
    &gt;&gt;&gt; comp = girvan_newman(G, most_valuable_edge=most_central_edge)
    &gt;&gt;&gt; tuple(sorted(c) for c in next(comp))
    ([0, 1, 2, 3, 4], [5, 6, 7, 8, 9])

To specify a different ranking algorithm for edges, use the
`most_valuable_edge` keyword argument::

    &gt;&gt;&gt; from networkx import edge_betweenness_centrality
    &gt;&gt;&gt; from random import random
    &gt;&gt;&gt; def most_central_edge(G):
    ...     centrality = edge_betweenness_centrality(G)
    ...     max_cent = max(centrality.values())
    ...     # Scale the centrality values so they are between 0 and 1,
    ...     # and add some random noise.
    ...     centrality = {e: c / max_cent for e, c in centrality.items()}
    ...     # Add some random noise.
    ...     centrality = {e: c + random() for e, c in centrality.items()}
    ...     return max(centrality, key=centrality.get)
    ...
    &gt;&gt;&gt; G = nx.path_graph(10)
    &gt;&gt;&gt; comp = girvan_newman(G, most_valuable_edge=most_central_edge)

Notes
-----
The Girvan–Newman algorithm detects communities by progressively
removing edges from the original graph. The algorithm removes the
"most valuable" edge, traditionally the edge with the highest
betweenness centrality, at each step. As the graph breaks down into
pieces, the tightly knit community structure is exposed and the
result can be depicted as a dendrogram.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
