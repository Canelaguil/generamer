<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.generators.community Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1generators.html">generators</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html">community</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.generators.community Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5a923d44ea3d13312625c65b2e0ff58f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#a5a923d44ea3d13312625c65b2e0ff58f">caveman_graph</a> (l, k)</td></tr>
<tr class="separator:a5a923d44ea3d13312625c65b2e0ff58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d88705711d5144ae535c533a957a0d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#a28d88705711d5144ae535c533a957a0d">connected_caveman_graph</a> (l, k)</td></tr>
<tr class="separator:a28d88705711d5144ae535c533a957a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08eda5b90825de22cc1061ecb62f564"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#ad08eda5b90825de22cc1061ecb62f564">relaxed_caveman_graph</a> (l, k, p, seed=None)</td></tr>
<tr class="separator:ad08eda5b90825de22cc1061ecb62f564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c6dd9281e81b11a8fa71040950b420"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#a05c6dd9281e81b11a8fa71040950b420">random_partition_graph</a> (sizes, p_in, p_out, seed=None, directed=False)</td></tr>
<tr class="separator:a05c6dd9281e81b11a8fa71040950b420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16fcc8fc4eb0b626eb26c4e8a282ff1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#ae16fcc8fc4eb0b626eb26c4e8a282ff1">planted_partition_graph</a> (l, k, p_in, p_out, seed=None, directed=False)</td></tr>
<tr class="separator:ae16fcc8fc4eb0b626eb26c4e8a282ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252376cc2f95931d973271551c25bd1f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#a252376cc2f95931d973271551c25bd1f">gaussian_random_partition_graph</a> (n, s, v, p_in, p_out, directed=False, seed=None)</td></tr>
<tr class="separator:a252376cc2f95931d973271551c25bd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08598aa780b4d5021b99d82a6cd499c1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#a08598aa780b4d5021b99d82a6cd499c1">ring_of_cliques</a> (num_cliques, clique_size)</td></tr>
<tr class="separator:a08598aa780b4d5021b99d82a6cd499c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c382b5879da332996f5ec2bfea4c6b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#a75c382b5879da332996f5ec2bfea4c6b">windmill_graph</a> (n, k)</td></tr>
<tr class="separator:a75c382b5879da332996f5ec2bfea4c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4093ce10a6704e73cc39103ffcefb13b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#a4093ce10a6704e73cc39103ffcefb13b">stochastic_block_model</a> (sizes, p, nodelist=None, seed=None, directed=False, selfloops=False, sparse=True)</td></tr>
<tr class="separator:a4093ce10a6704e73cc39103ffcefb13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cd806ad1089ad3b643e09338fe2ba0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1generators_1_1community.html#a32cd806ad1089ad3b643e09338fe2ba0">LFR_benchmark_graph</a> (n, tau1, tau2, mu, average_degree=None, min_degree=None, max_degree=None, min_community=None, max_community=None, tol=1.0e-7, max_iters=500, seed=None)</td></tr>
<tr class="separator:a32cd806ad1089ad3b643e09338fe2ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Generators for classes of graphs used in studying social networks.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a5a923d44ea3d13312625c65b2e0ff58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a923d44ea3d13312625c65b2e0ff58f">&#9670;&nbsp;</a></span>caveman_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.caveman_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a caveman graph of `l` cliques of size `k`.

Parameters
----------
l : int
  Number of cliques
k : int
  Size of cliques

Returns
-------
G : NetworkX Graph
  caveman graph

Notes
-----
This returns an undirected graph, it can be converted to a directed
graph using :func:`nx.to_directed`, or a multigraph using
``nx.MultiGraph(nx.caveman_graph(l, k))``. Only the undirected version is
described in [1]_ and it is unclear which of the directed
generalizations is most useful.

Examples
--------
&gt;&gt;&gt; G = nx.caveman_graph(3, 3)

See also
--------

connected_caveman_graph

References
----------
.. [1] Watts, D. J. 'Networks, Dynamics, and the Small-World Phenomenon.'
   Amer. J. Soc. 105, 493-527, 1999.
</pre> 
</div>
</div>
<a id="a28d88705711d5144ae535c533a957a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d88705711d5144ae535c533a957a0d">&#9670;&nbsp;</a></span>connected_caveman_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.connected_caveman_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a connected caveman graph of `l` cliques of size `k`.

The connected caveman graph is formed by creating `n` cliques of size
`k`, then a single edge in each clique is rewired to a node in an
adjacent clique.

Parameters
----------
l : int
  number of cliques
k : int
  size of cliques (k at least 2 or NetworkXError is raised)

Returns
-------
G : NetworkX Graph
  connected caveman graph

Raises
------
NetworkXError
    If the size of cliques `k` is smaller than 2.

Notes
-----
This returns an undirected graph, it can be converted to a directed
graph using :func:`nx.to_directed`, or a multigraph using
``nx.MultiGraph(nx.caveman_graph(l, k))``. Only the undirected version is
described in [1]_ and it is unclear which of the directed
generalizations is most useful.

Examples
--------
&gt;&gt;&gt; G = nx.connected_caveman_graph(3, 3)

References
----------
.. [1] Watts, D. J. 'Networks, Dynamics, and the Small-World Phenomenon.'
   Amer. J. Soc. 105, 493-527, 1999.
</pre> 
</div>
</div>
<a id="a252376cc2f95931d973271551c25bd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252376cc2f95931d973271551c25bd1f">&#9670;&nbsp;</a></span>gaussian_random_partition_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.gaussian_random_partition_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>directed</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a Gaussian random partition graph.

A Gaussian random partition graph is created by creating k partitions
each with a size drawn from a normal distribution with mean s and variance
s/v. Nodes are connected within clusters with probability p_in and
between clusters with probability p_out[1]

Parameters
----------
n : int
  Number of nodes in the graph
s : float
  Mean cluster size
v : float
  Shape parameter. The variance of cluster size distribution is s/v.
p_in : float
  Probabilty of intra cluster connection.
p_out : float
  Probability of inter cluster connection.
directed : boolean, optional default=False
  Whether to create a directed graph or not
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
G : NetworkX Graph or DiGraph
  gaussian random partition graph

Raises
------
NetworkXError
  If s is &gt; n
  If p_in or p_out is not in [0,1]

Notes
-----
Note the number of partitions is dependent on s,v and n, and that the
last partition may be considerably smaller, as it is sized to simply
fill out the nodes [1]

See Also
--------
random_partition_graph

Examples
--------
&gt;&gt;&gt; G = nx.gaussian_random_partition_graph(100, 10, 10, 0.25, 0.1)
&gt;&gt;&gt; len(G)
100

References
----------
.. [1] Ulrik Brandes, Marco Gaertler, Dorothea Wagner,
   Experiments on Graph Clustering Algorithms,
   In the proceedings of the 11th Europ. Symp. Algorithms, 2003.
</pre> 
</div>
</div>
<a id="a32cd806ad1089ad3b643e09338fe2ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cd806ad1089ad3b643e09338fe2ba0">&#9670;&nbsp;</a></span>LFR_benchmark_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.LFR_benchmark_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tau1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tau2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>average_degree</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_degree</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_degree</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_community</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_community</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1.0e-7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iters</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the LFR benchmark graph.

This algorithm proceeds as follows:

1) Find a degree sequence with a power law distribution, and minimum
   value ``min_degree``, which has approximate average degree
   ``average_degree``. This is accomplished by either

   a) specifying ``min_degree`` and not ``average_degree``,
   b) specifying ``average_degree`` and not ``min_degree``, in which
      case a suitable minimum degree will be found.

   ``max_degree`` can also be specified, otherwise it will be set to
   ``n``. Each node *u* will have `\mu \mathrm{deg}(u)` edges
   joining it to nodes in communities other than its own and `(1 -
   \mu) \mathrm{deg}(u)` edges joining it to nodes in its own
   community.
2) Generate community sizes according to a power law distribution
   with exponent ``tau2``. If ``min_community`` and
   ``max_community`` are not specified they will be selected to be
   ``min_degree`` and ``max_degree``, respectively.  Community sizes
   are generated until the sum of their sizes equals ``n``.
3) Each node will be randomly assigned a community with the
   condition that the community is large enough for the node's
   intra-community degree, `(1 - \mu) \mathrm{deg}(u)` as
   described in step 2. If a community grows too large, a random node
   will be selected for reassignment to a new community, until all
   nodes have been assigned a community.
4) Each node *u* then adds `(1 - \mu) \mathrm{deg}(u)`
   intra-community edges and `\mu \mathrm{deg}(u)` inter-community
   edges.

Parameters
----------
n : int
    Number of nodes in the created graph.

tau1 : float
    Power law exponent for the degree distribution of the created
    graph. This value must be strictly greater than one.

tau2 : float
    Power law exponent for the community size distribution in the
    created graph. This value must be strictly greater than one.

mu : float
    Fraction of inter-community edges incident to each node. This
    value must be in the interval [0, 1].

average_degree : float
    Desired average degree of nodes in the created graph. This value
    must be in the interval [0, *n*]. Exactly one of this and
    ``min_degree`` must be specified, otherwise a
    :exc:`NetworkXError` is raised.

min_degree : int
    Minimum degree of nodes in the created graph. This value must be
    in the interval [0, *n*]. Exactly one of this and
    ``average_degree`` must be specified, otherwise a
    :exc:`NetworkXError` is raised.

max_degree : int
    Maximum degree of nodes in the created graph. If not specified,
    this is set to ``n``, the total number of nodes in the graph.

min_community : int
    Minimum size of communities in the graph. If not specified, this
    is set to ``min_degree``.

max_community : int
    Maximum size of communities in the graph. If not specified, this
    is set to ``n``, the total number of nodes in the graph.

tol : float
    Tolerance when comparing floats, specifically when comparing
    average degree values.

max_iters : int
    Maximum number of iterations to try to create the community sizes,
    degree distribution, and community affiliations.

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
G : NetworkX graph
    The LFR benchmark graph generated according to the specified
    parameters.

    Each node in the graph has a node attribute ``'community'`` that
    stores the community (that is, the set of nodes) that includes
    it.

Raises
------
NetworkXError
    If any of the parameters do not meet their upper and lower bounds:

    - ``tau1`` and ``tau2`` must be strictly greater than 1.
    - ``mu`` must be in [0, 1].
    - ``max_degree`` must be in {1, ..., *n*}.
    - ``min_community`` and ``max_community`` must be in {0, ...,
      *n*}.

    If not exactly one of ``average_degree`` and ``min_degree`` is
    specified.

    If ``min_degree`` is not specified and a suitable ``min_degree``
    cannot be found.

ExceededMaxIterations
    If a valid degree sequence cannot be created within
    ``max_iters`` number of iterations.

    If a valid set of community sizes cannot be created within
    ``max_iters`` number of iterations.

    If a valid community assignment cannot be created within ``10 *
    n * max_iters`` number of iterations.

Examples
--------
Basic usage::

    &gt;&gt;&gt; from networkx.generators.community import LFR_benchmark_graph
    &gt;&gt;&gt; n = 250
    &gt;&gt;&gt; tau1 = 3
    &gt;&gt;&gt; tau2 = 1.5
    &gt;&gt;&gt; mu = 0.1
    &gt;&gt;&gt; G = LFR_benchmark_graph(
    ...     n, tau1, tau2, mu, average_degree=5, min_community=20, seed=10
    ... )

Continuing the example above, you can get the communities from the
node attributes of the graph::

    &gt;&gt;&gt; communities = {frozenset(G.nodes[v]["community"]) for v in G}

Notes
-----
This algorithm differs slightly from the original way it was
presented in [1].

1) Rather than connecting the graph via a configuration model then
   rewiring to match the intra-community and inter-community
   degrees, we do this wiring explicitly at the end, which should be
   equivalent.
2) The code posted on the author's website [2] calculates the random
   power law distributed variables and their average using
   continuous approximations, whereas we use the discrete
   distributions here as both degree and community size are
   discrete.

Though the authors describe the algorithm as quite robust, testing
during development indicates that a somewhat narrower parameter set
is likely to successfully produce a graph. Some suggestions have
been provided in the event of exceptions.

References
----------
.. [1] "Benchmark graphs for testing community detection algorithms",
       Andrea Lancichinetti, Santo Fortunato, and Filippo Radicchi,
       Phys. Rev. E 78, 046110 2008
.. [2] https://www.santofortunato.net/resources</pre> 
</div>
</div>
<a id="ae16fcc8fc4eb0b626eb26c4e8a282ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16fcc8fc4eb0b626eb26c4e8a282ff1">&#9670;&nbsp;</a></span>planted_partition_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.planted_partition_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>directed</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the planted l-partition graph.

This model partitions a graph with n=l*k vertices in
l groups with k vertices each. Vertices of the same
group are linked with a probability p_in, and vertices
of different groups are linked with probability p_out.

Parameters
----------
l : int
  Number of groups
k : int
  Number of vertices in each group
p_in : float
  probability of connecting vertices within a group
p_out : float
  probability of connected vertices between groups
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.
directed : bool,optional (default=False)
  If True return a directed graph

Returns
-------
G : NetworkX Graph or DiGraph
  planted l-partition graph

Raises
------
NetworkXError
  If p_in,p_out are not in [0,1] or

Examples
--------
&gt;&gt;&gt; G = nx.planted_partition_graph(4, 3, 0.5, 0.1, seed=42)

See Also
--------
random_partition_model

References
----------
.. [1] A. Condon, R.M. Karp, Algorithms for graph partitioning
    on the planted partition model,
    Random Struct. Algor. 18 (2001) 116-140.

.. [2] Santo Fortunato 'Community Detection in Graphs' Physical Reports
   Volume 486, Issue 3-5 p. 75-174. https://arxiv.org/abs/0906.0612
</pre> 
</div>
</div>
<a id="a05c6dd9281e81b11a8fa71040950b420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c6dd9281e81b11a8fa71040950b420">&#9670;&nbsp;</a></span>random_partition_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.random_partition_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>directed</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the random partition graph with a partition of sizes.

A partition graph is a graph of communities with sizes defined by
s in sizes. Nodes in the same group are connected with probability
p_in and nodes of different groups are connected with probability
p_out.

Parameters
----------
sizes : list of ints
  Sizes of groups
p_in : float
  probability of edges with in groups
p_out : float
  probability of edges between groups
directed : boolean optional, default=False
  Whether to create a directed graph
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
G : NetworkX Graph or DiGraph
  random partition graph of size sum(gs)

Raises
------
NetworkXError
  If p_in or p_out is not in [0,1]

Examples
--------
&gt;&gt;&gt; G = nx.random_partition_graph([10, 10, 10], 0.25, 0.01)
&gt;&gt;&gt; len(G)
30
&gt;&gt;&gt; partition = G.graph["partition"]
&gt;&gt;&gt; len(partition)
3

Notes
-----
This is a generalization of the planted-l-partition described in
[1]_.  It allows for the creation of groups of any size.

The partition is store as a graph attribute 'partition'.

References
----------
.. [1] Santo Fortunato 'Community Detection in Graphs' Physical Reports
   Volume 486, Issue 3-5 p. 75-174. https://arxiv.org/abs/0906.0612
</pre> 
</div>
</div>
<a id="ad08eda5b90825de22cc1061ecb62f564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08eda5b90825de22cc1061ecb62f564">&#9670;&nbsp;</a></span>relaxed_caveman_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.relaxed_caveman_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a relaxed caveman graph.

A relaxed caveman graph starts with `l` cliques of size `k`.  Edges are
then randomly rewired with probability `p` to link different cliques.

Parameters
----------
l : int
  Number of groups
k : int
  Size of cliques
p : float
  Probabilty of rewiring each edge.
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
G : NetworkX Graph
  Relaxed Caveman Graph

Raises
------
NetworkXError
 If p is not in [0,1]

Examples
--------
&gt;&gt;&gt; G = nx.relaxed_caveman_graph(2, 3, 0.1, seed=42)

References
----------
.. [1] Santo Fortunato, Community Detection in Graphs,
   Physics Reports Volume 486, Issues 3-5, February 2010, Pages 75-174.
   https://arxiv.org/abs/0906.0612
</pre> 
</div>
</div>
<a id="a08598aa780b4d5021b99d82a6cd499c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08598aa780b4d5021b99d82a6cd499c1">&#9670;&nbsp;</a></span>ring_of_cliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.ring_of_cliques </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num_cliques</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>clique_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Defines a "ring of cliques" graph.

A ring of cliques graph is consisting of cliques, connected through single
links. Each clique is a complete graph.

Parameters
----------
num_cliques : int
    Number of cliques
clique_size : int
    Size of cliques

Returns
-------
G : NetworkX Graph
    ring of cliques graph

Raises
------
NetworkXError
    If the number of cliques is lower than 2 or
    if the size of cliques is smaller than 2.

Examples
--------
&gt;&gt;&gt; G = nx.ring_of_cliques(8, 4)

See Also
--------
connected_caveman_graph

Notes
-----
The `connected_caveman_graph` graph removes a link from each clique to
connect it with the next clique. Instead, the `ring_of_cliques` graph
simply adds the link without removing any link from the cliques.
</pre> 
</div>
</div>
<a id="a4093ce10a6704e73cc39103ffcefb13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4093ce10a6704e73cc39103ffcefb13b">&#9670;&nbsp;</a></span>stochastic_block_model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.stochastic_block_model </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodelist</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>directed</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>selfloops</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a stochastic block model graph.

This model partitions the nodes in blocks of arbitrary sizes, and places
edges between pairs of nodes independently, with a probability that depends
on the blocks.

Parameters
----------
sizes : list of ints
    Sizes of blocks
p : list of list of floats
    Element (r,s) gives the density of edges going from the nodes
    of group r to nodes of group s.
    p must match the number of groups (len(sizes) == len(p)),
    and it must be symmetric if the graph is undirected.
nodelist : list, optional
    The block tags are assigned according to the node identifiers
    in nodelist. If nodelist is None, then the ordering is the
    range [0,sum(sizes)-1].
seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.
directed : boolean optional, default=False
    Whether to create a directed graph or not.
selfloops : boolean optional, default=False
    Whether to include self-loops or not.
sparse: boolean optional, default=True
    Use the sparse heuristic to speed up the generator.

Returns
-------
g : NetworkX Graph or DiGraph
    Stochastic block model graph of size sum(sizes)

Raises
------
NetworkXError
  If probabilities are not in [0,1].
  If the probability matrix is not square (directed case).
  If the probability matrix is not symmetric (undirected case).
  If the sizes list does not match nodelist or the probability matrix.
  If nodelist contains duplicate.

Examples
--------
&gt;&gt;&gt; sizes = [75, 75, 300]
&gt;&gt;&gt; probs = [[0.25, 0.05, 0.02], [0.05, 0.35, 0.07], [0.02, 0.07, 0.40]]
&gt;&gt;&gt; g = nx.stochastic_block_model(sizes, probs, seed=0)
&gt;&gt;&gt; len(g)
450
&gt;&gt;&gt; H = nx.quotient_graph(g, g.graph["partition"], relabel=True)
&gt;&gt;&gt; for v in H.nodes(data=True):
...     print(round(v[1]["density"], 3))
...
0.245
0.348
0.405
&gt;&gt;&gt; for v in H.edges(data=True):
...     print(round(1.0 * v[2]["weight"] / (sizes[v[0]] * sizes[v[1]]), 3))
...
0.051
0.022
0.07

See Also
--------
random_partition_graph
planted_partition_graph
gaussian_random_partition_graph
gnp_random_graph

References
----------
.. [1] Holland, P. W., Laskey, K. B., &amp; Leinhardt, S.,
       "Stochastic blockmodels: First steps",
       Social networks, 5(2), 109-137, 1983.
</pre> 
</div>
</div>
<a id="a75c382b5879da332996f5ec2bfea4c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c382b5879da332996f5ec2bfea4c6b">&#9670;&nbsp;</a></span>windmill_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.generators.community.windmill_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a windmill graph.
A windmill graph is a graph of `n` cliques each of size `k` that are all
joined at one node.
It can be thought of as taking a disjoint union of `n` cliques of size `k`,
selecting one point from each, and contracting all of the selected points.
Alternatively, one could generate `n` cliques of size `k-1` and one node
that is connected to all other nodes in the graph.

Parameters
----------
n : int
    Number of cliques
k : int
    Size of cliques

Returns
-------
G : NetworkX Graph
    windmill graph with n cliques of size k

Raises
------
NetworkXError
    If the number of cliques is less than two
    If the size of the cliques are less than two

Examples
--------
&gt;&gt;&gt; G = nx.windmill_graph(4, 5)

Notes
-----
The node labeled `0` will be the node connected to all other nodes.
Note that windmill graphs are usually denoted `Wd(k,n)`, so the parameters
are in the opposite order as the parameters of this method.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
