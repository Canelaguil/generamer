<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.threshold Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html">threshold</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.threshold Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a473d58bddd35b77a537dcd6f8007d6d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a473d58bddd35b77a537dcd6f8007d6d6">is_threshold_graph</a> (G)</td></tr>
<tr class="separator:a473d58bddd35b77a537dcd6f8007d6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3941fdbefea9aefa8625b4b642156145"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a3941fdbefea9aefa8625b4b642156145">is_threshold_sequence</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a5b49bf4f8c08b7b87b61e20477ae4b00">degree_sequence</a>)</td></tr>
<tr class="separator:a3941fdbefea9aefa8625b4b642156145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9028c3c0a3a2fda4bf3b836189d3dc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a5b49bf4f8c08b7b87b61e20477ae4b00">degree_sequence</a>, with_labels=False, compact=False)</td></tr>
<tr class="separator:a0b9028c3c0a3a2fda4bf3b836189d3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16e6d28e3f28bffb1ffcb5c81068c9d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#aa16e6d28e3f28bffb1ffcb5c81068c9d">make_compact</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:aa16e6d28e3f28bffb1ffcb5c81068c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853782d9473275a93bcdc3c39d5ae2b4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a853782d9473275a93bcdc3c39d5ae2b4">uncompact</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:a853782d9473275a93bcdc3c39d5ae2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45645774713f4a3a1d0c1cf4ef407742"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a45645774713f4a3a1d0c1cf4ef407742">creation_sequence_to_weights</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:a45645774713f4a3a1d0c1cf4ef407742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af967d42f89e8b2692a23fee2e85edb07"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#af967d42f89e8b2692a23fee2e85edb07">weights_to_creation_sequence</a> (weights, threshold=1, with_labels=False, compact=False)</td></tr>
<tr class="separator:af967d42f89e8b2692a23fee2e85edb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd194f5a5c9317341cb7ef3bbe7568d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a3bd194f5a5c9317341cb7ef3bbe7568d">threshold_graph</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>, create_using=None)</td></tr>
<tr class="separator:a3bd194f5a5c9317341cb7ef3bbe7568d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a24579c8037720c0b9d0c88e9663e9c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a5a24579c8037720c0b9d0c88e9663e9c">find_alternating_4_cycle</a> (G)</td></tr>
<tr class="separator:a5a24579c8037720c0b9d0c88e9663e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442c5310f0de219f71300e356723bb74"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a442c5310f0de219f71300e356723bb74">find_threshold_graph</a> (G, create_using=None)</td></tr>
<tr class="separator:a442c5310f0de219f71300e356723bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6237b5b78122e1ffafc1a79588602939"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a6237b5b78122e1ffafc1a79588602939">find_creation_sequence</a> (G)</td></tr>
<tr class="separator:a6237b5b78122e1ffafc1a79588602939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f1353fc6cafd327fe4ff537357c5cf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a68f1353fc6cafd327fe4ff537357c5cf">triangles</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:a68f1353fc6cafd327fe4ff537357c5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1975d0019a04b726395579fa70d3e6e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a1975d0019a04b726395579fa70d3e6e8">triangle_sequence</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:a1975d0019a04b726395579fa70d3e6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef7458fd02d22f9c71a16cdb2159456"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#aeef7458fd02d22f9c71a16cdb2159456">cluster_sequence</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:aeef7458fd02d22f9c71a16cdb2159456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b49bf4f8c08b7b87b61e20477ae4b00"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a5b49bf4f8c08b7b87b61e20477ae4b00">degree_sequence</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:a5b49bf4f8c08b7b87b61e20477ae4b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e367378eb0fa95420bb45ffcca8226"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#af0e367378eb0fa95420bb45ffcca8226">density</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:af0e367378eb0fa95420bb45ffcca8226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41774a3d894859356bb1420f38932d10"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a41774a3d894859356bb1420f38932d10">degree_correlation</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:a41774a3d894859356bb1420f38932d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5db00fe713433e44e8ad2c0e665218a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#aa5db00fe713433e44e8ad2c0e665218a">shortest_path</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>, u, v)</td></tr>
<tr class="separator:aa5db00fe713433e44e8ad2c0e665218a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cb236bd0510a01652eee2affafa733"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#aa2cb236bd0510a01652eee2affafa733">shortest_path_length</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>, i)</td></tr>
<tr class="separator:aa2cb236bd0510a01652eee2affafa733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e55c1c531842e62260691227dceddf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a54e55c1c531842e62260691227dceddf">betweenness_sequence</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>, normalized=True)</td></tr>
<tr class="separator:a54e55c1c531842e62260691227dceddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b59a1ee1b0881a25fe09af9c935d42"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a99b59a1ee1b0881a25fe09af9c935d42">eigenvectors</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:a99b59a1ee1b0881a25fe09af9c935d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19415f0520a02f2ca7b565aba31355d9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a19415f0520a02f2ca7b565aba31355d9">spectral_projection</a> (u, eigenpairs)</td></tr>
<tr class="separator:a19415f0520a02f2ca7b565aba31355d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797878f69758f67495d1854275abf650"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a797878f69758f67495d1854275abf650">eigenvalues</a> (<a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0b9028c3c0a3a2fda4bf3b836189d3dc">creation_sequence</a>)</td></tr>
<tr class="separator:a797878f69758f67495d1854275abf650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40d1e006d0930b9ecaeaa6619336d89"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#ae40d1e006d0930b9ecaeaa6619336d89">random_threshold_sequence</a> (n, p, seed=None)</td></tr>
<tr class="separator:ae40d1e006d0930b9ecaeaa6619336d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680cc5ce051b5470709f290b460464e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a680cc5ce051b5470709f290b460464e2">right_d_threshold_sequence</a> (n, m)</td></tr>
<tr class="separator:a680cc5ce051b5470709f290b460464e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0e6232450ae760683623c67036f513"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#adf0e6232450ae760683623c67036f513">left_d_threshold_sequence</a> (n, m)</td></tr>
<tr class="separator:adf0e6232450ae760683623c67036f513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0048b193ccb63bedfa1565170bdf6283"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1threshold.html#a0048b193ccb63bedfa1565170bdf6283">swap_d</a> (cs, p_split=1.0, p_combine=1.0, seed=None)</td></tr>
<tr class="separator:a0048b193ccb63bedfa1565170bdf6283"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Threshold Graphs - Creation, manipulation and identification.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a54e55c1c531842e62260691227dceddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e55c1c531842e62260691227dceddf">&#9670;&nbsp;</a></span>betweenness_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.betweenness_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>normalized</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return betweenness for the threshold graph with the given creation
sequence.  The result is unscaled.  To scale the values
to the iterval [0,1] divide by (n-1)*(n-2).
</pre> 
</div>
</div>
<a id="aeef7458fd02d22f9c71a16cdb2159456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef7458fd02d22f9c71a16cdb2159456">&#9670;&nbsp;</a></span>cluster_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.cluster_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return cluster sequence for the given threshold graph creation sequence.
</pre> 
</div>
</div>
<a id="a0b9028c3c0a3a2fda4bf3b836189d3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b9028c3c0a3a2fda4bf3b836189d3dc">&#9670;&nbsp;</a></span>creation_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.creation_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>degree_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>with_labels</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compact</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determines the creation sequence for the given threshold degree sequence.

The creation sequence is a list of single characters 'd'
or 'i': 'd' for dominating or 'i' for isolated vertices.
Dominating vertices are connected to all vertices present when it
is added.  The first node added is by convention 'd'.
This list can be converted to a string if desired using "".join(cs)

If with_labels==True:
Returns a list of 2-tuples containing the vertex number
and a character 'd' or 'i' which describes the type of vertex.

If compact==True:
Returns the creation sequence in a compact form that is the number
of 'i's and 'd's alternating.
Examples:
[1,2,2,3] represents d,i,i,d,d,i,i,i
[3,1,2] represents d,d,d,i,d,d

Notice that the first number is the first vertex to be used for
construction and so is always 'd'.

with_labels and compact cannot both be True.

Returns None if the sequence is not a threshold sequence
</pre> 
</div>
</div>
<a id="a45645774713f4a3a1d0c1cf4ef407742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45645774713f4a3a1d0c1cf4ef407742">&#9670;&nbsp;</a></span>creation_sequence_to_weights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.creation_sequence_to_weights </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a list of node weights which create the threshold
graph designated by the creation sequence.  The weights
are scaled so that the threshold is 1.0.  The order of the
nodes is the same as that in the creation sequence.
</pre> 
</div>
</div>
<a id="a41774a3d894859356bb1420f38932d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41774a3d894859356bb1420f38932d10">&#9670;&nbsp;</a></span>degree_correlation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.degree_correlation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the degree-degree correlation over all edges.
</pre> 
</div>
</div>
<a id="a5b49bf4f8c08b7b87b61e20477ae4b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b49bf4f8c08b7b87b61e20477ae4b00">&#9670;&nbsp;</a></span>degree_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.degree_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return degree sequence for the threshold graph with the given
creation sequence
</pre> 
</div>
</div>
<a id="af0e367378eb0fa95420bb45ffcca8226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e367378eb0fa95420bb45ffcca8226">&#9670;&nbsp;</a></span>density()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.density </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the density of the graph with this creation_sequence.
The density is the fraction of possible edges present.
</pre> 
</div>
</div>
<a id="a797878f69758f67495d1854275abf650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797878f69758f67495d1854275abf650">&#9670;&nbsp;</a></span>eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.eigenvalues </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return sequence of eigenvalues of the Laplacian of the threshold
graph for the given creation_sequence.

Based on the Ferrer's diagram method.  The spectrum is integral
and is the conjugate of the degree sequence.

See::

  @Article{degree-merris-1994,
   author = {Russel Merris},
   title = {Degree maximal graphs are Laplacian integral},
   journal = {Linear Algebra Appl.},
   year = {1994},
   volume = {199},
   pages = {381--389},
  }</pre> 
</div>
</div>
<a id="a99b59a1ee1b0881a25fe09af9c935d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b59a1ee1b0881a25fe09af9c935d42">&#9670;&nbsp;</a></span>eigenvectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.eigenvectors </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a 2-tuple of Laplacian eigenvalues and eigenvectors
for the threshold network with creation_sequence.
The first value is a list of eigenvalues.
The second value is a list of eigenvectors.
The lists are in the same order so corresponding eigenvectors
and eigenvalues are in the same position in the two lists.

Notice that the order of the eigenvalues returned by eigenvalues(cs)
may not correspond to the order of these eigenvectors.
</pre> 
</div>
</div>
<a id="a5a24579c8037720c0b9d0c88e9663e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a24579c8037720c0b9d0c88e9663e9c">&#9670;&nbsp;</a></span>find_alternating_4_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.find_alternating_4_cycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns False if there aren't any alternating 4 cycles.
Otherwise returns the cycle as [a,b,c,d] where (a,b)
and (c,d) are edges and (a,c) and (b,d) are not.
</pre> 
</div>
</div>
<a id="a6237b5b78122e1ffafc1a79588602939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6237b5b78122e1ffafc1a79588602939">&#9670;&nbsp;</a></span>find_creation_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.find_creation_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find a threshold subgraph that is close to largest in G.
Returns the labeled creation sequence of that threshold graph.
</pre> 
</div>
</div>
<a id="a442c5310f0de219f71300e356723bb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a442c5310f0de219f71300e356723bb74">&#9670;&nbsp;</a></span>find_threshold_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.find_threshold_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a threshold subgraph that is close to largest in `G`.

The threshold graph will contain the largest degree node in G.

Parameters
----------
G : NetworkX graph instance
    An instance of `Graph`, or `MultiDiGraph`
create_using : NetworkX graph class or `None` (default), optional
    Type of graph to use when constructing the threshold graph.
    If `None`, infer the appropriate graph type from the input.

Returns
-------
graph :
    A graph instance representing the threshold graph

Examples
--------
&gt;&gt;&gt; from networkx.algorithms.threshold import find_threshold_graph
&gt;&gt;&gt; G = nx.barbell_graph(3, 3)
&gt;&gt;&gt; T = find_threshold_graph(G)
&gt;&gt;&gt; T.nodes # may vary
NodeView((7, 8, 5, 6))

References
----------
.. [1] Threshold graphs: https://en.wikipedia.org/wiki/Threshold_graph
</pre> 
</div>
</div>
<a id="a473d58bddd35b77a537dcd6f8007d6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473d58bddd35b77a537dcd6f8007d6d6">&#9670;&nbsp;</a></span>is_threshold_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.is_threshold_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns `True` if `G` is a threshold graph.

Parameters
----------
G : NetworkX graph instance
    An instance of `Graph`, `DiGraph`, `MultiGraph` or `MultiDiGraph`

Returns
-------
bool
    `True` if `G` is a threshold graph, `False` otherwise.

Examples
--------
&gt;&gt;&gt; from networkx.algorithms.threshold import is_threshold_graph
&gt;&gt;&gt; G = nx.path_graph(3)
&gt;&gt;&gt; is_threshold_graph(G)
True
&gt;&gt;&gt; G = nx.barbell_graph(3, 3)
&gt;&gt;&gt; is_threshold_graph(G)
False

References
----------
.. [1] Threshold graphs: https://en.wikipedia.org/wiki/Threshold_graph
</pre> 
</div>
</div>
<a id="a3941fdbefea9aefa8625b4b642156145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3941fdbefea9aefa8625b4b642156145">&#9670;&nbsp;</a></span>is_threshold_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.is_threshold_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>degree_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the sequence is a threshold degree seqeunce.

Uses the property that a threshold graph must be constructed by
adding either dominating or isolated nodes. Thus, it can be
deconstructed iteratively by removing a node of degree zero or a
node that connects to the remaining nodes.  If this deconstruction
failes then the sequence is not a threshold sequence.
</pre> 
</div>
</div>
<a id="adf0e6232450ae760683623c67036f513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0e6232450ae760683623c67036f513">&#9670;&nbsp;</a></span>left_d_threshold_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.left_d_threshold_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a skewed threshold graph with a given number
of vertices (n) and a given number of edges (m).

The routine returns an unlabeled creation sequence
for the threshold graph.

FIXME: describe algorithm</pre> 
</div>
</div>
<a id="aa16e6d28e3f28bffb1ffcb5c81068c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa16e6d28e3f28bffb1ffcb5c81068c9d">&#9670;&nbsp;</a></span>make_compact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.make_compact </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the creation sequence in a compact form
that is the number of 'i's and 'd's alternating.

Examples
--------
&gt;&gt;&gt; from networkx.algorithms.threshold import make_compact
&gt;&gt;&gt; make_compact(["d", "i", "i", "d", "d", "i", "i", "i"])
[1, 2, 2, 3]
&gt;&gt;&gt; make_compact(["d", "d", "d", "i", "d", "d"])
[3, 1, 2]

Notice that the first number is the first vertex
to be used for construction and so is always 'd'.

Labeled creation sequences lose their labels in the
compact representation.

&gt;&gt;&gt; make_compact([3, 1, 2])
[3, 1, 2]
</pre> 
</div>
</div>
<a id="ae40d1e006d0930b9ecaeaa6619336d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40d1e006d0930b9ecaeaa6619336d89">&#9670;&nbsp;</a></span>random_threshold_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.random_threshold_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a random threshold sequence of size n.
A creation sequence is built by randomly choosing d's with
probabiliy p and i's with probability 1-p.

s=nx.random_threshold_sequence(10,0.5)

returns a threshold sequence of length 10 with equal
probably of an i or a d at each position.

A "random" threshold graph can be built with

G=nx.threshold_graph(s)

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.
</pre> 
</div>
</div>
<a id="a680cc5ce051b5470709f290b460464e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680cc5ce051b5470709f290b460464e2">&#9670;&nbsp;</a></span>right_d_threshold_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.right_d_threshold_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a skewed threshold graph with a given number
of vertices (n) and a given number of edges (m).

The routine returns an unlabeled creation sequence
for the threshold graph.

FIXME: describe algorithm</pre> 
</div>
</div>
<a id="aa5db00fe713433e44e8ad2c0e665218a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5db00fe713433e44e8ad2c0e665218a">&#9670;&nbsp;</a></span>shortest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.shortest_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the shortest path between u and v in a
threshold graph G with the given creation_sequence.

For an unlabeled creation_sequence, the vertices
u and v must be integers in (0,len(sequence)) referring
to the position of the desired vertices in the sequence.

For a labeled creation_sequence, u and v are labels of veritices.

Use cs=creation_sequence(degree_sequence,with_labels=True)
to convert a degree sequence to a creation sequence.

Returns a list of vertices from u to v.
Example: if they are neighbors, it returns [u,v]
</pre> 
</div>
</div>
<a id="aa2cb236bd0510a01652eee2affafa733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cb236bd0510a01652eee2affafa733">&#9670;&nbsp;</a></span>shortest_path_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.shortest_path_length </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the shortest path length from indicated node to
every other node for the threshold graph with the given
creation sequence.
Node is indicated by index i in creation_sequence unless
creation_sequence is labeled in which case, i is taken to
be the label of the node.

Paths lengths in threshold graphs are at most 2.
Length to unreachable nodes is set to -1.
</pre> 
</div>
</div>
<a id="a19415f0520a02f2ca7b565aba31355d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19415f0520a02f2ca7b565aba31355d9">&#9670;&nbsp;</a></span>spectral_projection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.spectral_projection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eigenpairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the coefficients of each eigenvector
in a projection of the vector u onto the normalized
eigenvectors which are contained in eigenpairs.

eigenpairs should be a list of two objects.  The
first is a list of eigenvalues and the second a list
of eigenvectors.  The eigenvectors should be lists.

There's not a lot of error checking on lengths of
arrays, etc. so be careful.
</pre> 
</div>
</div>
<a id="a0048b193ccb63bedfa1565170bdf6283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0048b193ccb63bedfa1565170bdf6283">&#9670;&nbsp;</a></span>swap_d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.swap_d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_split</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>p_combine</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Perform a "swap" operation on a threshold sequence.

The swap preserves the number of nodes and edges
in the graph for the given sequence.
The resulting sequence is still a threshold sequence.

Perform one split and one combine operation on the
'd's of a creation sequence for a threshold graph.
This operation maintains the number of nodes and edges
in the graph, but shifts the edges from node to node
maintaining the threshold quality of the graph.

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.
</pre> 
</div>
</div>
<a id="a3bd194f5a5c9317341cb7ef3bbe7568d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd194f5a5c9317341cb7ef3bbe7568d">&#9670;&nbsp;</a></span>threshold_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.threshold_graph </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a threshold graph from the creation sequence or compact
creation_sequence.

The input sequence can be a

creation sequence (e.g. ['d','i','d','d','d','i'])
labeled creation sequence (e.g. [(0,'d'),(2,'d'),(1,'i')])
compact creation sequence (e.g. [2,1,1,2,0])

Use cs=creation_sequence(degree_sequence,labeled=True)
to convert a degree sequence to a creation sequence.

Returns None if the sequence is not valid
</pre> 
</div>
</div>
<a id="a1975d0019a04b726395579fa70d3e6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1975d0019a04b726395579fa70d3e6e8">&#9670;&nbsp;</a></span>triangle_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.triangle_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return triangle sequence for the given threshold graph creation sequence.</pre> 
</div>
</div>
<a id="a68f1353fc6cafd327fe4ff537357c5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f1353fc6cafd327fe4ff537357c5cf">&#9670;&nbsp;</a></span>triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.triangles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute number of triangles in the threshold graph with the
given creation sequence.
</pre> 
</div>
</div>
<a id="a853782d9473275a93bcdc3c39d5ae2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853782d9473275a93bcdc3c39d5ae2b4">&#9670;&nbsp;</a></span>uncompact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.uncompact </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>creation_sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Converts a compact creation sequence for a threshold
graph to a standard creation sequence (unlabeled).
If the creation_sequence is already standard, return it.
See creation_sequence.
</pre> 
</div>
</div>
<a id="af967d42f89e8b2692a23fee2e85edb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af967d42f89e8b2692a23fee2e85edb07">&#9670;&nbsp;</a></span>weights_to_creation_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.threshold.weights_to_creation_sequence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>with_labels</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compact</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a creation sequence for a threshold graph
determined by the weights and threshold given as input.
If the sum of two node weights is greater than the
threshold value, an edge is created between these nodes.

The creation sequence is a list of single characters 'd'
or 'i': 'd' for dominating or 'i' for isolated vertices.
Dominating vertices are connected to all vertices present
when it is added.  The first node added is by convention 'd'.

If with_labels==True:
Returns a list of 2-tuples containing the vertex number
and a character 'd' or 'i' which describes the type of vertex.

If compact==True:
Returns the creation sequence in a compact form that is the number
of 'i's and 'd's alternating.
Examples:
[1,2,2,3] represents d,i,i,d,d,i,i,i
[3,1,2] represents d,d,d,i,d,d

Notice that the first number is the first vertex to be used for
construction and so is always 'd'.

with_labels and compact cannot both be True.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
