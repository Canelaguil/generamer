<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.classes.graphviews Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1classes.html">classes</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1classes_1_1graphviews.html">graphviews</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.classes.graphviews Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a874b4e1287fcca8fa8eeda3d1926c10c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1graphviews.html#a874b4e1287fcca8fa8eeda3d1926c10c">generic_graph_view</a> (G, create_using=None)</td></tr>
<tr class="separator:a874b4e1287fcca8fa8eeda3d1926c10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33dcd3d967dd7ca14ad2bb823e4e831b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1graphviews.html#a33dcd3d967dd7ca14ad2bb823e4e831b">subgraph_view</a> (G, filter_node=no_filter, filter_edge=no_filter)</td></tr>
<tr class="separator:a33dcd3d967dd7ca14ad2bb823e4e831b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88278e8cd74c849cf5208ea8b14ad499"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1classes_1_1graphviews.html#a88278e8cd74c849cf5208ea8b14ad499">reverse_view</a> (G)</td></tr>
<tr class="separator:a88278e8cd74c849cf5208ea8b14ad499"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">View of Graphs as SubGraph, Reverse, Directed, Undirected.

In some algorithms it is convenient to temporarily morph
a graph to exclude some nodes or edges. It should be better
to do that via a view than to remove and then re-add.
In other algorithms it is convenient to temporarily morph
a graph to reverse directed edges, or treat a directed graph
as undirected, etc. This module provides those graph views.

The resulting views are essentially read-only graphs that
report data from the orignal graph object. We provide an
attribute G._graph which points to the underlying graph object.

Note: Since graphviews look like graphs, one can end up with
view-of-view-of-view chains. Be careful with chains because
they become very slow with about 15 nested views.
For the common simple case of node induced subgraphs created
from the graph class, we short-cut the chain by returning a
subgraph of the original graph directly rather than a subgraph
of a subgraph. We are careful not to disrupt any edge filter in
the middle subgraph. In general, determining how to short-cut
the chain is tricky and much harder with restricted_views than
with induced subgraphs.
Often it is easiest to use .copy() to avoid chains.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a874b4e1287fcca8fa8eeda3d1926c10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a874b4e1287fcca8fa8eeda3d1926c10c">&#9670;&nbsp;</a></span>generic_graph_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.graphviews.generic_graph_view </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>create_using</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88278e8cd74c849cf5208ea8b14ad499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88278e8cd74c849cf5208ea8b14ad499">&#9670;&nbsp;</a></span>reverse_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.graphviews.reverse_view </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">View of `G` with edge directions reversed

`reverse_view` returns a read-only view of the input graph where
edge directions are reversed.

Identical to digraph.reverse(copy=False)

Parameters
----------
G : networkx.DiGraph

Returns
-------
graph : networkx.DiGraph

Examples
--------
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_edge(1, 2)
&gt;&gt;&gt; G.add_edge(2, 3)
&gt;&gt;&gt; G.edges()
OutEdgeView([(1, 2), (2, 3)])

&gt;&gt;&gt; view = nx.reverse_view(G)
&gt;&gt;&gt; view.edges()
OutEdgeView([(2, 1), (3, 2)])
</pre> 
</div>
</div>
<a id="a33dcd3d967dd7ca14ad2bb823e4e831b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33dcd3d967dd7ca14ad2bb823e4e831b">&#9670;&nbsp;</a></span>subgraph_view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.classes.graphviews.subgraph_view </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter_node</em> = <code>no_filter</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter_edge</em> = <code>no_filter</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">View of `G` applying a filter on nodes and edges.

`subgraph_view` provides a read-only view of the input graph that excludes
nodes and edges based on the outcome of two filter functions `filter_node`
and `filter_edge`.

The `filter_node` function takes one argument --- the node --- and returns
`True` if the node should be included in the subgraph, and `False` if it
should not be included.

The `filter_edge` function takes two (or three arguments if `G` is a
multi-graph) --- the nodes describing an edge, plus the edge-key if
parallel edges are possible --- and returns `True` if the edge should be
included in the subgraph, and `False` if it should not be included.

Both node and edge filter functions are called on graph elements as they
are queried, meaning there is no up-front cost to creating the view.

Parameters
----------
G : networkx.Graph
    A directed/undirected graph/multigraph

filter_node : callable, optional
    A function taking a node as input, which returns `True` if the node
    should appear in the view.

filter_edge : callable, optional
    A function taking as input the two nodes describing an edge (plus the
    edge-key if `G` is a multi-graph), which returns `True` if the edge
    should appear in the view.

Returns
-------
graph : networkx.Graph
    A read-only graph view of the input graph.

Examples
--------
&gt;&gt;&gt; G = nx.path_graph(6)

Filter functions operate on the node, and return `True` if the node should
appear in the view:

&gt;&gt;&gt; def filter_node(n1):
...     return n1 != 5
...
&gt;&gt;&gt; view = nx.subgraph_view(G, filter_node=filter_node)
&gt;&gt;&gt; view.nodes()
NodeView((0, 1, 2, 3, 4))

We can use a closure pattern to filter graph elements based on additional
data --- for example, filtering on edge data attached to the graph:

&gt;&gt;&gt; G[3][4]["cross_me"] = False
&gt;&gt;&gt; def filter_edge(n1, n2):
...     return G[n1][n2].get("cross_me", True)
...
&gt;&gt;&gt; view = nx.subgraph_view(G, filter_edge=filter_edge)
&gt;&gt;&gt; view.edges()
EdgeView([(0, 1), (1, 2), (2, 3), (4, 5)])

&gt;&gt;&gt; view = nx.subgraph_view(G, filter_node=filter_node, filter_edge=filter_edge,)
&gt;&gt;&gt; view.nodes()
NodeView((0, 1, 2, 3, 4))
&gt;&gt;&gt; view.edges()
EdgeView([(0, 1), (1, 2), (2, 3)])
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
