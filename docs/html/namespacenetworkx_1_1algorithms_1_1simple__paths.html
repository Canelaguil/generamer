<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.simple_paths Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1simple__paths.html">simple_paths</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.simple_paths Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1simple__paths_1_1PathBuffer.html">PathBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2ed07ef1ce2ec6ff72dc537d79a436ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1simple__paths.html#a2ed07ef1ce2ec6ff72dc537d79a436ed">is_simple_path</a> (G, nodes)</td></tr>
<tr class="separator:a2ed07ef1ce2ec6ff72dc537d79a436ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6810350d1b73083aeeb311ff0ec45e4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1simple__paths.html#ae6810350d1b73083aeeb311ff0ec45e4">all_simple_paths</a> (G, source, target, cutoff=None)</td></tr>
<tr class="separator:ae6810350d1b73083aeeb311ff0ec45e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4fb436f9e23ad7bc6eef2dd4c95699"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1simple__paths.html#a9d4fb436f9e23ad7bc6eef2dd4c95699">all_simple_edge_paths</a> (G, source, target, cutoff=None)</td></tr>
<tr class="separator:a9d4fb436f9e23ad7bc6eef2dd4c95699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0efdc3cd497758f3090898c351d9221"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1simple__paths.html#ac0efdc3cd497758f3090898c351d9221">shortest_simple_paths</a> (G, source, target, weight=None)</td></tr>
<tr class="separator:ac0efdc3cd497758f3090898c351d9221"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9d4fb436f9e23ad7bc6eef2dd4c95699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4fb436f9e23ad7bc6eef2dd4c95699">&#9670;&nbsp;</a></span>all_simple_edge_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.simple_paths.all_simple_edge_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate lists of edges for all simple paths in G from source to target.

A simple path is a path with no repeated nodes.

Parameters
----------
G : NetworkX graph

source : node
   Starting node for path

target : nodes
   Single node or iterable of nodes at which to end path

cutoff : integer, optional
    Depth to stop the search. Only paths of length &lt;= cutoff are returned.

Returns
-------
path_generator: generator
   A generator that produces lists of simple paths.  If there are no paths
   between the source and target within the given cutoff the generator
   produces no output.
   For multigraphs, the list of edges have elements of the form `(u,v,k)`.
   Where `k` corresponds to the edge key.

Examples
--------

Print the simple path edges of a Graph::

    &gt;&gt;&gt; g = nx.Graph([(1, 2), (2, 4), (1, 3), (3, 4)])
    &gt;&gt;&gt; for path in sorted(nx.all_simple_edge_paths(g, 1, 4)):
    ...     print(path)
    [(1, 2), (2, 4)]
    [(1, 3), (3, 4)]

Print the simple path edges of a MultiGraph. Returned edges come with
their associated keys::

    &gt;&gt;&gt; mg = nx.MultiGraph()
    &gt;&gt;&gt; mg.add_edge(1, 2, key="k0")
    'k0'
    &gt;&gt;&gt; mg.add_edge(1, 2, key="k1")
    'k1'
    &gt;&gt;&gt; mg.add_edge(2, 3, key="k0")
    'k0'
    &gt;&gt;&gt; for path in sorted(nx.all_simple_edge_paths(mg, 1, 3)):
    ...     print(path)
    [(1, 2, 'k0'), (2, 3, 'k0')]
    [(1, 2, 'k1'), (2, 3, 'k0')]


Notes
-----
This algorithm uses a modified depth-first search to generate the
paths [1]_.  A single path can be found in $O(V+E)$ time but the
number of simple paths in a graph can be very large, e.g. $O(n!)$ in
the complete graph of order $n$.

References
----------
.. [1] R. Sedgewick, "Algorithms in C, Part 5: Graph Algorithms",
   Addison Wesley Professional, 3rd ed., 2001.

See Also
--------
all_shortest_paths, shortest_path, all_simple_paths</pre> 
</div>
</div>
<a id="ae6810350d1b73083aeeb311ff0ec45e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6810350d1b73083aeeb311ff0ec45e4">&#9670;&nbsp;</a></span>all_simple_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.simple_paths.all_simple_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate all simple paths in the graph G from source to target.

A simple path is a path with no repeated nodes.

Parameters
----------
G : NetworkX graph

source : node
   Starting node for path

target : nodes
   Single node or iterable of nodes at which to end path

cutoff : integer, optional
    Depth to stop the search. Only paths of length &lt;= cutoff are returned.

Returns
-------
path_generator: generator
   A generator that produces lists of simple paths.  If there are no paths
   between the source and target within the given cutoff the generator
   produces no output.

Examples
--------
This iterator generates lists of nodes::

    &gt;&gt;&gt; G = nx.complete_graph(4)
    &gt;&gt;&gt; for path in nx.all_simple_paths(G, source=0, target=3):
    ...     print(path)
    ...
    [0, 1, 2, 3]
    [0, 1, 3]
    [0, 2, 1, 3]
    [0, 2, 3]
    [0, 3]

You can generate only those paths that are shorter than a certain
length by using the `cutoff` keyword argument::

    &gt;&gt;&gt; paths = nx.all_simple_paths(G, source=0, target=3, cutoff=2)
    &gt;&gt;&gt; print(list(paths))
    [[0, 1, 3], [0, 2, 3], [0, 3]]

To get each path as the corresponding list of edges, you can use the
:func:`networkx.utils.pairwise` helper function::

    &gt;&gt;&gt; paths = nx.all_simple_paths(G, source=0, target=3)
    &gt;&gt;&gt; for path in map(nx.utils.pairwise, paths):
    ...     print(list(path))
    [(0, 1), (1, 2), (2, 3)]
    [(0, 1), (1, 3)]
    [(0, 2), (2, 1), (1, 3)]
    [(0, 2), (2, 3)]
    [(0, 3)]

Pass an iterable of nodes as target to generate all paths ending in any of several nodes::

    &gt;&gt;&gt; G = nx.complete_graph(4)
    &gt;&gt;&gt; for path in nx.all_simple_paths(G, source=0, target=[3, 2]):
    ...     print(path)
    ...
    [0, 1, 2]
    [0, 1, 2, 3]
    [0, 1, 3]
    [0, 1, 3, 2]
    [0, 2]
    [0, 2, 1, 3]
    [0, 2, 3]
    [0, 3]
    [0, 3, 1, 2]
    [0, 3, 2]

Iterate over each path from the root nodes to the leaf nodes in a
directed acyclic graph using a functional programming approach::

    &gt;&gt;&gt; from itertools import chain
    &gt;&gt;&gt; from itertools import product
    &gt;&gt;&gt; from itertools import starmap
    &gt;&gt;&gt; from functools import partial
    &gt;&gt;&gt;
    &gt;&gt;&gt; chaini = chain.from_iterable
    &gt;&gt;&gt;
    &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])
    &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)
    &gt;&gt;&gt; leaves = (v for v, d in G.out_degree() if d == 0)
    &gt;&gt;&gt; all_paths = partial(nx.all_simple_paths, G)
    &gt;&gt;&gt; list(chaini(starmap(all_paths, product(roots, leaves))))
    [[0, 1, 2], [0, 3, 2]]

The same list computed using an iterative approach::

    &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (1, 2), (0, 3), (3, 2)])
    &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)
    &gt;&gt;&gt; leaves = (v for v, d in G.out_degree() if d == 0)
    &gt;&gt;&gt; all_paths = []
    &gt;&gt;&gt; for root in roots:
    ...     for leaf in leaves:
    ...         paths = nx.all_simple_paths(G, root, leaf)
    ...         all_paths.extend(paths)
    &gt;&gt;&gt; all_paths
    [[0, 1, 2], [0, 3, 2]]

Iterate over each path from the root nodes to the leaf nodes in a
directed acyclic graph passing all leaves together to avoid unnecessary
compute::

    &gt;&gt;&gt; G = nx.DiGraph([(0, 1), (2, 1), (1, 3), (1, 4)])
    &gt;&gt;&gt; roots = (v for v, d in G.in_degree() if d == 0)
    &gt;&gt;&gt; leaves = [v for v, d in G.out_degree() if d == 0]
    &gt;&gt;&gt; all_paths = []
    &gt;&gt;&gt; for root in roots:
    ...     paths = nx.all_simple_paths(G, root, leaves)
    ...     all_paths.extend(paths)
    &gt;&gt;&gt; all_paths
    [[0, 1, 3], [0, 1, 4], [2, 1, 3], [2, 1, 4]]

Notes
-----
This algorithm uses a modified depth-first search to generate the
paths [1]_.  A single path can be found in $O(V+E)$ time but the
number of simple paths in a graph can be very large, e.g. $O(n!)$ in
the complete graph of order $n$.

References
----------
.. [1] R. Sedgewick, "Algorithms in C, Part 5: Graph Algorithms",
   Addison Wesley Professional, 3rd ed., 2001.

See Also
--------
all_shortest_paths, shortest_path</pre> 
</div>
</div>
<a id="a2ed07ef1ce2ec6ff72dc537d79a436ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed07ef1ce2ec6ff72dc537d79a436ed">&#9670;&nbsp;</a></span>is_simple_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.simple_paths.is_simple_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if and only if `nodes` form a simple path in `G`.

A *simple path* in a graph is a nonempty sequence of nodes in which
no node appears more than once in the sequence, and each adjacent
pair of nodes in the sequence is adjacent in the graph.

Parameters
----------
G : graph
    A NetworkX graph.
nodes : list
    A list of one or more nodes in the graph `G`.

Returns
-------
bool
    Whether the given list of nodes represents a simple path in `G`.

Notes
-----
An empty list of nodes is not a path but a list of one node is a
path. Here's an explanation why.

This function operates on *node paths*. One could also consider
*edge paths*. There is a bijection between node paths and edge
paths.

The *length of a path* is the number of edges in the path, so a list
of nodes of length *n* corresponds to a path of length *n* - 1.
Thus the smallest edge path would be a list of zero edges, the empty
path. This corresponds to a list of one node.

To convert between a node path and an edge path, you can use code
like the following::

    &gt;&gt;&gt; from networkx.utils import pairwise
    &gt;&gt;&gt; nodes = [0, 1, 2, 3]
    &gt;&gt;&gt; edges = list(pairwise(nodes))
    &gt;&gt;&gt; edges
    [(0, 1), (1, 2), (2, 3)]
    &gt;&gt;&gt; nodes = [edges[0][0]] + [v for u, v in edges]
    &gt;&gt;&gt; nodes
    [0, 1, 2, 3]

Examples
--------
&gt;&gt;&gt; G = nx.cycle_graph(4)
&gt;&gt;&gt; nx.is_simple_path(G, [2, 3, 0])
True
&gt;&gt;&gt; nx.is_simple_path(G, [0, 2])
False</pre> 
</div>
</div>
<a id="ac0efdc3cd497758f3090898c351d9221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0efdc3cd497758f3090898c351d9221">&#9670;&nbsp;</a></span>shortest_simple_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.simple_paths.shortest_simple_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate all simple paths in the graph G from source to target,
   starting from shortest ones.

A simple path is a path with no repeated nodes.

If a weighted shortest path search is to be used, no negative weights
are allowed.

Parameters
----------
G : NetworkX graph

source : node
   Starting node for path

target : node
   Ending node for path

weight : string or function
    If it is a string, it is the name of the edge attribute to be
    used as a weight.

    If it is a function, the weight of an edge is the value returned
    by the function. The function must accept exactly three positional
    arguments: the two endpoints of an edge and the dictionary of edge
    attributes for that edge. The function must return a number.

    If None all edges are considered to have unit weight. Default
    value None.

Returns
-------
path_generator: generator
   A generator that produces lists of simple paths, in order from
   shortest to longest.

Raises
------
NetworkXNoPath
   If no path exists between source and target.

NetworkXError
   If source or target nodes are not in the input graph.

NetworkXNotImplemented
   If the input graph is a Multi[Di]Graph.

Examples
--------

&gt;&gt;&gt; G = nx.cycle_graph(7)
&gt;&gt;&gt; paths = list(nx.shortest_simple_paths(G, 0, 3))
&gt;&gt;&gt; print(paths)
[[0, 1, 2, 3], [0, 6, 5, 4, 3]]

You can use this function to efficiently compute the k shortest/best
paths between two nodes.

&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; def k_shortest_paths(G, source, target, k, weight=None):
...     return list(
...         islice(nx.shortest_simple_paths(G, source, target, weight=weight), k)
...     )
&gt;&gt;&gt; for path in k_shortest_paths(G, 0, 3, 2):
...     print(path)
[0, 1, 2, 3]
[0, 6, 5, 4, 3]

Notes
-----
This procedure is based on algorithm by Jin Y. Yen [1]_.  Finding
the first $K$ paths requires $O(KN^3)$ operations.

See Also
--------
all_shortest_paths
shortest_path
all_simple_paths

References
----------
.. [1] Jin Y. Yen, "Finding the K Shortest Loopless Paths in a
   Network", Management Science, Vol. 17, No. 11, Theory Series
   (Jul., 1971), pp. 712-716.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
