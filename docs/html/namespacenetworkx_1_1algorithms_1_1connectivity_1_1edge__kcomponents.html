<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.connectivity.edge_kcomponents Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity.html">connectivity</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1edge__kcomponents.html">edge_kcomponents</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.connectivity.edge_kcomponents Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnetworkx_1_1algorithms_1_1connectivity_1_1edge__kcomponents_1_1EdgeComponentAuxGraph.html">EdgeComponentAuxGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af6249ee7fb8d09fe3f506cdf57b5e8e3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1edge__kcomponents.html#af6249ee7fb8d09fe3f506cdf57b5e8e3">k_edge_components</a> (G, k)</td></tr>
<tr class="separator:af6249ee7fb8d09fe3f506cdf57b5e8e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac157f85d3e68bf00257d29488f8c795e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1edge__kcomponents.html#ac157f85d3e68bf00257d29488f8c795e">k_edge_subgraphs</a> (G, k)</td></tr>
<tr class="separator:ac157f85d3e68bf00257d29488f8c795e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f92268daf27cb5c79593656e3c5958"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1edge__kcomponents.html#a37f92268daf27cb5c79593656e3c5958">bridge_components</a> (G)</td></tr>
<tr class="separator:a37f92268daf27cb5c79593656e3c5958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37593586a0ba623692e0b34dae6a6cb8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1connectivity_1_1edge__kcomponents.html#a37593586a0ba623692e0b34dae6a6cb8">general_k_edge_subgraphs</a> (G, k)</td></tr>
<tr class="separator:a37593586a0ba623692e0b34dae6a6cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Algorithms for finding k-edge-connected components and subgraphs.

A k-edge-connected component (k-edge-cc) is a maximal set of nodes in G, such
that all pairs of node have an edge-connectivity of at least k.

A k-edge-connected subgraph (k-edge-subgraph) is a maximal set of nodes in G,
such that the subgraph of G defined by the nodes has an edge-connectivity at
least k.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a37f92268daf27cb5c79593656e3c5958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f92268daf27cb5c79593656e3c5958">&#9670;&nbsp;</a></span>bridge_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.edge_kcomponents.bridge_components </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Finds all bridge-connected components G.

Parameters
----------
G : NetworkX undirected graph

Returns
-------
bridge_components : a generator of 2-edge-connected components


See Also
--------
:func:`k_edge_subgraphs` : this function is a special case for an
    undirected graph where k=2.
:func:`biconnected_components` : similar to this function, but is defined
    using 2-node-connectivity instead of 2-edge-connectivity.

Raises
------
NetworkXNotImplemented
    If the input graph is directed or a multigraph.

Notes
-----
Bridge-connected components are also known as 2-edge-connected components.

Examples
--------
&gt;&gt;&gt; # The barbell graph with parameter zero has a single bridge
&gt;&gt;&gt; G = nx.barbell_graph(5, 0)
&gt;&gt;&gt; from networkx.algorithms.connectivity.edge_kcomponents import bridge_components
&gt;&gt;&gt; sorted(map(sorted, bridge_components(G)))
[[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]
</pre> 
</div>
</div>
<a id="a37593586a0ba623692e0b34dae6a6cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37593586a0ba623692e0b34dae6a6cb8">&#9670;&nbsp;</a></span>general_k_edge_subgraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.edge_kcomponents.general_k_edge_subgraphs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">General algorithm to find all maximal k-edge-connected subgraphs in G.

Returns
-------
k_edge_subgraphs : a generator of nx.Graphs that are k-edge-subgraphs
    Each k-edge-subgraph is a maximal set of nodes that defines a subgraph
    of G that is k-edge-connected.

Notes
-----
Implementation of the basic algorithm from _[1].  The basic idea is to find
a global minimum cut of the graph. If the cut value is at least k, then the
graph is a k-edge-connected subgraph and can be added to the results.
Otherwise, the cut is used to split the graph in two and the procedure is
applied recursively. If the graph is just a single node, then it is also
added to the results. At the end, each result is either guaranteed to be
a single node or a subgraph of G that is k-edge-connected.

This implementation contains optimizations for reducing the number of calls
to max-flow, but there are other optimizations in _[1] that could be
implemented.

References
----------
.. [1] Zhou, Liu, et al. (2012) Finding maximal k-edge-connected subgraphs
    from a large graph.  ACM International Conference on Extending Database
    Technology 2012 480-â€“491.
    https://openproceedings.org/2012/conf/edbt/ZhouLYLCL12.pdf

Examples
--------
&gt;&gt;&gt; from networkx.utils import pairwise
&gt;&gt;&gt; paths = [
...     (11, 12, 13, 14, 11, 13, 14, 12),  # a 4-clique
...     (21, 22, 23, 24, 21, 23, 24, 22),  # another 4-clique
...     # connect the cliques with high degree but low connectivity
...     (50, 13),
...     (12, 50, 22),
...     (13, 102, 23),
...     (14, 101, 24),
... ]
&gt;&gt;&gt; G = nx.Graph(it.chain(*[pairwise(path) for path in paths]))
&gt;&gt;&gt; sorted(map(len, k_edge_subgraphs(G, k=3)))
[1, 1, 1, 4, 4]
</pre> 
</div>
</div>
<a id="af6249ee7fb8d09fe3f506cdf57b5e8e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6249ee7fb8d09fe3f506cdf57b5e8e3">&#9670;&nbsp;</a></span>k_edge_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.edge_kcomponents.k_edge_components </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates nodes in each maximal k-edge-connected component in G.

Parameters
----------
G : NetworkX graph

k : Integer
    Desired edge connectivity

Returns
-------
k_edge_components : a generator of k-edge-ccs. Each set of returned nodes
   will have k-edge-connectivity in the graph G.

See Also
--------
:func:`local_edge_connectivity`
:func:`k_edge_subgraphs` : similar to this function, but the subgraph
    defined by the nodes must also have k-edge-connectivity.
:func:`k_components` : similar to this function, but uses node-connectivity
    instead of edge-connectivity

Raises
------
NetworkXNotImplemented
    If the input graph is a multigraph.

ValueError:
    If k is less than 1

Notes
-----
Attempts to use the most efficient implementation available based on k.
If k=1, this is simply connected components for directed graphs and
connected components for undirected graphs.
If k=2 on an efficient bridge connected component algorithm from _[1] is
run based on the chain decomposition.
Otherwise, the algorithm from _[2] is used.

Examples
--------
&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; from networkx.utils import pairwise
&gt;&gt;&gt; paths = [
...     (1, 2, 4, 3, 1, 4),
...     (5, 6, 7, 8, 5, 7, 8, 6),
... ]
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; G.add_nodes_from(it.chain(*paths))
&gt;&gt;&gt; G.add_edges_from(it.chain(*[pairwise(path) for path in paths]))
&gt;&gt;&gt; # note this returns {1, 4} unlike k_edge_subgraphs
&gt;&gt;&gt; sorted(map(sorted, nx.k_edge_components(G, k=3)))
[[1, 4], [2], [3], [5, 6, 7, 8]]

References
----------
.. [1] https://en.wikipedia.org/wiki/Bridge_%28graph_theory%29
.. [2] Wang, Tianhao, et al. (2015) A simple algorithm for finding all
    k-edge-connected components.
    http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0136264
</pre> 
</div>
</div>
<a id="ac157f85d3e68bf00257d29488f8c795e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac157f85d3e68bf00257d29488f8c795e">&#9670;&nbsp;</a></span>k_edge_subgraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.connectivity.edge_kcomponents.k_edge_subgraphs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generates nodes in each maximal k-edge-connected subgraph in G.

Parameters
----------
G : NetworkX graph

k : Integer
    Desired edge connectivity

Returns
-------
k_edge_subgraphs : a generator of k-edge-subgraphs
    Each k-edge-subgraph is a maximal set of nodes that defines a subgraph
    of G that is k-edge-connected.

See Also
--------
:func:`edge_connectivity`
:func:`k_edge_components` : similar to this function, but nodes only
    need to have k-edge-connctivity within the graph G and the subgraphs
    might not be k-edge-connected.

Raises
------
NetworkXNotImplemented
    If the input graph is a multigraph.

ValueError:
    If k is less than 1

Notes
-----
Attempts to use the most efficient implementation available based on k.
If k=1, or k=2 and the graph is undirected, then this simply calls
`k_edge_components`.  Otherwise the algorithm from _[1] is used.

Examples
--------
&gt;&gt;&gt; import itertools as it
&gt;&gt;&gt; from networkx.utils import pairwise
&gt;&gt;&gt; paths = [
...     (1, 2, 4, 3, 1, 4),
...     (5, 6, 7, 8, 5, 7, 8, 6),
... ]
&gt;&gt;&gt; G = nx.Graph()
&gt;&gt;&gt; G.add_nodes_from(it.chain(*paths))
&gt;&gt;&gt; G.add_edges_from(it.chain(*[pairwise(path) for path in paths]))
&gt;&gt;&gt; # note this does not return {1, 4} unlike k_edge_components
&gt;&gt;&gt; sorted(map(sorted, nx.k_edge_subgraphs(G, k=3)))
[[1], [2], [3], [4], [5, 6, 7, 8]]

References
----------
.. [1] Zhou, Liu, et al. (2012) Finding maximal k-edge-connected subgraphs
    from a large graph.  ACM International Conference on Extending Database
    Technology 2012 480-â€“491.
    https://openproceedings.org/2012/conf/edbt/ZhouLYLCL12.pdf
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
