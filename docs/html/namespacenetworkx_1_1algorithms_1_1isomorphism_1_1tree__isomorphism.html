<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.isomorphism.tree_isomorphism Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism.html">isomorphism</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1tree__isomorphism.html">tree_isomorphism</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.isomorphism.tree_isomorphism Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a77029094aa772129dd7d77bd232fb577"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1tree__isomorphism.html#a77029094aa772129dd7d77bd232fb577">root_trees</a> (t1, root1, t2, root2)</td></tr>
<tr class="separator:a77029094aa772129dd7d77bd232fb577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50c69d1ddd49d853681c8db00cf05da"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1tree__isomorphism.html#ab50c69d1ddd49d853681c8db00cf05da">assign_levels</a> (G, root)</td></tr>
<tr class="separator:ab50c69d1ddd49d853681c8db00cf05da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c11ea1f0a596a6b819f810cf04b107f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1tree__isomorphism.html#a0c11ea1f0a596a6b819f810cf04b107f">group_by_levels</a> (levels)</td></tr>
<tr class="separator:a0c11ea1f0a596a6b819f810cf04b107f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fa4e0e6f13d215fb862243e2138fc4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1tree__isomorphism.html#a28fa4e0e6f13d215fb862243e2138fc4">generate_isomorphism</a> (v, w, M, ordered_children)</td></tr>
<tr class="separator:a28fa4e0e6f13d215fb862243e2138fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77311446523f91a7c1fa30d21ce78e05"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1tree__isomorphism.html#a77311446523f91a7c1fa30d21ce78e05">rooted_tree_isomorphism</a> (t1, root1, t2, root2)</td></tr>
<tr class="separator:a77311446523f91a7c1fa30d21ce78e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a92453309ab6be345c022472c2200d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1isomorphism_1_1tree__isomorphism.html#a5a92453309ab6be345c022472c2200d2">tree_isomorphism</a> (t1, t2)</td></tr>
<tr class="separator:a5a92453309ab6be345c022472c2200d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">An algorithm for finding if two undirected trees are isomorphic,
and if so returns an isomorphism between the two sets of nodes.

This algorithm uses a routine to tell if two rooted trees (trees with a
specified root node) are isomorphic, which may be independently useful.

This implements an algorithm from:
The Design and Analysis of Computer Algorithms
by Aho, Hopcroft, and Ullman
Addison-Wesley Publishing 1974
Example 3.2 pp. 84-86.

A more understandable version of this algorithm is described in:
Homework Assignment 5
McGill University SOCS 308-250B, Winter 2002
by Matthew Suderman
http://crypto.cs.mcgill.ca/~crepeau/CS250/2004/HW5+.pdf
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ab50c69d1ddd49d853681c8db00cf05da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50c69d1ddd49d853681c8db00cf05da">&#9670;&nbsp;</a></span>assign_levels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.tree_isomorphism.assign_levels </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28fa4e0e6f13d215fb862243e2138fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fa4e0e6f13d215fb862243e2138fc4">&#9670;&nbsp;</a></span>generate_isomorphism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.tree_isomorphism.generate_isomorphism </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordered_children</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c11ea1f0a596a6b819f810cf04b107f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c11ea1f0a596a6b819f810cf04b107f">&#9670;&nbsp;</a></span>group_by_levels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.tree_isomorphism.group_by_levels </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>levels</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77029094aa772129dd7d77bd232fb577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77029094aa772129dd7d77bd232fb577">&#9670;&nbsp;</a></span>root_trees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.tree_isomorphism.root_trees </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>root2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a single digraph dT of free trees t1 and t2
#   with roots root1 and root2 respectively
# rename the nodes with consecutive integers
# so that all nodes get a unique name between both trees

# our new "fake" root node is 0
# t1 is numbers from 1 ... n
# t2 is numbered from n+1 to 2n
</pre> 
</div>
</div>
<a id="a77311446523f91a7c1fa30d21ce78e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77311446523f91a7c1fa30d21ce78e05">&#9670;&nbsp;</a></span>rooted_tree_isomorphism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.tree_isomorphism.rooted_tree_isomorphism </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>root1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>root2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given two rooted trees `t1` and `t2`,
with roots `root1` and `root2` respectivly
this routine will determine if they are isomorphic.

These trees may be either directed or undirected,
but if they are directed, all edges should flow from the root.

It returns the isomorphism, a mapping of the nodes of `t1` onto the nodes
of `t2`, such that two trees are then identical.

Note that two trees may have more than one isomorphism, and this
routine just returns one valid mapping.

Parameters
----------
`t1` :  NetworkX graph
    One of the trees being compared

`root1` : a node of `t1` which is the root of the tree

`t2` : undirected NetworkX graph
    The other tree being compared

`root2` : a node of `t2` which is the root of the tree

This is a subroutine used to implement `tree_isomorphism`, but will
be somewhat faster if you already have rooted trees.

Returns
-------
isomorphism : list
    A list of pairs in which the left element is a node in `t1`
    and the right element is a node in `t2`.  The pairs are in
    arbitrary order.  If the nodes in one tree is mapped to the names in
    the other, then trees will be identical. Note that an isomorphism
    will not necessarily be unique.

    If `t1` and `t2` are not isomorphic, then it returns the empty list.
</pre> 
</div>
</div>
<a id="a5a92453309ab6be345c022472c2200d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a92453309ab6be345c022472c2200d2">&#9670;&nbsp;</a></span>tree_isomorphism()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.isomorphism.tree_isomorphism.tree_isomorphism </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Given two undirected (or free) trees `t1` and `t2`,
this routine will determine if they are isomorphic.
It returns the isomorphism, a mapping of the nodes of `t1` onto the nodes
of `t2`, such that two trees are then identical.

Note that two trees may have more than one isomorphism, and this
routine just returns one valid mapping.

Parameters
----------
t1 : undirected NetworkX graph
    One of the trees being compared

t2 : undirected NetworkX graph
    The other tree being compared

Returns
-------
isomorphism : list
    A list of pairs in which the left element is a node in `t1`
    and the right element is a node in `t2`.  The pairs are in
    arbitrary order.  If the nodes in one tree is mapped to the names in
    the other, then trees will be identical. Note that an isomorphism
    will not necessarily be unique.

    If `t1` and `t2` are not isomorphic, then it returns the empty list.

Notes
-----
This runs in O(n*log(n)) time for trees with n nodes.
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
