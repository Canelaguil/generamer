<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: numpy.core.numeric Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html">numeric</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">numpy.core.numeric Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1numeric_1_1ComplexWarning.html">ComplexWarning</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aff34b60351859b2e2797e226ad04ddd0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aff34b60351859b2e2797e226ad04ddd0">zeros_like</a> (a, dtype=None, order='K', subok=True, shape=None)</td></tr>
<tr class="separator:aff34b60351859b2e2797e226ad04ddd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdbcb3ea5a55908e290dee2c72c0079"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a6bdbcb3ea5a55908e290dee2c72c0079">ones</a> (shape, dtype=None, order='C', like=None)</td></tr>
<tr class="separator:a6bdbcb3ea5a55908e290dee2c72c0079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788d1bc80059cdd4214e4f76fd142cc0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a788d1bc80059cdd4214e4f76fd142cc0">ones_like</a> (a, dtype=None, order='K', subok=True, shape=None)</td></tr>
<tr class="separator:a788d1bc80059cdd4214e4f76fd142cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dcece77169e453f2094ad8a884ced8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aa5dcece77169e453f2094ad8a884ced8">full</a> (shape, fill_value, dtype=None, order='C', like=None)</td></tr>
<tr class="separator:aa5dcece77169e453f2094ad8a884ced8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36c0d44478fd8d1cd569ab44cba5b4b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ab36c0d44478fd8d1cd569ab44cba5b4b">full_like</a> (a, fill_value, dtype=None, order='K', subok=True, shape=None)</td></tr>
<tr class="separator:ab36c0d44478fd8d1cd569ab44cba5b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c64f4a657e9277ac9196f1e5c9c8ce3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a2c64f4a657e9277ac9196f1e5c9c8ce3">count_nonzero</a> (a, axis=None, keepdims=False)</td></tr>
<tr class="separator:a2c64f4a657e9277ac9196f1e5c9c8ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2519ee360f263c4f3410065dd08692"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aca2519ee360f263c4f3410065dd08692">isfortran</a> (a)</td></tr>
<tr class="separator:aca2519ee360f263c4f3410065dd08692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1ea621ebdf27d454d7d9887c68f67a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a1b1ea621ebdf27d454d7d9887c68f67a">argwhere</a> (a)</td></tr>
<tr class="separator:a1b1ea621ebdf27d454d7d9887c68f67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b23f45060462d59df4609deb36da30"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ac8b23f45060462d59df4609deb36da30">flatnonzero</a> (a)</td></tr>
<tr class="separator:ac8b23f45060462d59df4609deb36da30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcf1c35df9b086c7f3dec19cc6c9579"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aadcf1c35df9b086c7f3dec19cc6c9579">correlate</a> (a, v, mode='valid')</td></tr>
<tr class="separator:aadcf1c35df9b086c7f3dec19cc6c9579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d206f80ecc160a47c672986d063595"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#af1d206f80ecc160a47c672986d063595">convolve</a> (a, v, mode='<a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aa5dcece77169e453f2094ad8a884ced8">full</a>')</td></tr>
<tr class="separator:af1d206f80ecc160a47c672986d063595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb46476790d894e402755264dfc69ffb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#acb46476790d894e402755264dfc69ffb">outer</a> (a, b, out=None)</td></tr>
<tr class="separator:acb46476790d894e402755264dfc69ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f92680111292b4be69b722b3732991"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ad0f92680111292b4be69b722b3732991">tensordot</a> (a, b, axes=2)</td></tr>
<tr class="separator:ad0f92680111292b4be69b722b3732991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5503974a131efadeeec73bf5eba4b43f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a5503974a131efadeeec73bf5eba4b43f">roll</a> (a, shift, axis=None)</td></tr>
<tr class="separator:a5503974a131efadeeec73bf5eba4b43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644e0d45bac850ac24fee58dc9f0d5cb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a644e0d45bac850ac24fee58dc9f0d5cb">rollaxis</a> (a, axis, start=0)</td></tr>
<tr class="separator:a644e0d45bac850ac24fee58dc9f0d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5bcc0eaa759ce1ab86f25402ae03ac"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a9d5bcc0eaa759ce1ab86f25402ae03ac">normalize_axis_tuple</a> (axis, ndim, argname=None, allow_duplicate=False)</td></tr>
<tr class="separator:a9d5bcc0eaa759ce1ab86f25402ae03ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ac41a75a5af16516241f4a6fb96e6b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ac7ac41a75a5af16516241f4a6fb96e6b">moveaxis</a> (a, source, destination)</td></tr>
<tr class="separator:ac7ac41a75a5af16516241f4a6fb96e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2002e78dc75a2cc31a1b29af6feee132"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a2002e78dc75a2cc31a1b29af6feee132">cross</a> (a, b, axisa=-1, axisb=-1, axisc=-1, axis=None)</td></tr>
<tr class="separator:a2002e78dc75a2cc31a1b29af6feee132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f1041249cac51abe61aa5f3ccfc951"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ae2f1041249cac51abe61aa5f3ccfc951">indices</a> (dimensions, dtype=int, sparse=False)</td></tr>
<tr class="separator:ae2f1041249cac51abe61aa5f3ccfc951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe97d2dd9a9996cb96ca02a03ef0ae6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aabe97d2dd9a9996cb96ca02a03ef0ae6">fromfunction</a> (function, shape, dtype=float, like=None, kwargs)</td></tr>
<tr class="separator:aabe97d2dd9a9996cb96ca02a03ef0ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505e4f3fa802a70c6090e5e23124f847"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a505e4f3fa802a70c6090e5e23124f847">isscalar</a> (element)</td></tr>
<tr class="separator:a505e4f3fa802a70c6090e5e23124f847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496f8030a53d8ffbaee3639b18116428"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a496f8030a53d8ffbaee3639b18116428">binary_repr</a> (num, width=None)</td></tr>
<tr class="separator:a496f8030a53d8ffbaee3639b18116428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30faf8e5c0748ef6178c0c588756d7a9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a30faf8e5c0748ef6178c0c588756d7a9">base_repr</a> (number, base=2, padding=0)</td></tr>
<tr class="separator:a30faf8e5c0748ef6178c0c588756d7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ce08a6d993ca8e40d80e55ae83cd19"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a30ce08a6d993ca8e40d80e55ae83cd19">identity</a> (<a class="el" href="namespacenumpy.html#a352663c52853d2754274407d5cae2832">n</a>, dtype=None, like=None)</td></tr>
<tr class="separator:a30ce08a6d993ca8e40d80e55ae83cd19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad595579ad95d35c8e9b43080cbbe2d19"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ad595579ad95d35c8e9b43080cbbe2d19">allclose</a> (a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False)</td></tr>
<tr class="separator:ad595579ad95d35c8e9b43080cbbe2d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6874bed1b6f01fc26401509337d83ea4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a6874bed1b6f01fc26401509337d83ea4">isclose</a> (a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False)</td></tr>
<tr class="separator:a6874bed1b6f01fc26401509337d83ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db68b636ed03415538dd11c25adbc6a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a2db68b636ed03415538dd11c25adbc6a">array_equal</a> (a1, a2, equal_nan=False)</td></tr>
<tr class="separator:a2db68b636ed03415538dd11c25adbc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b2410c270f1e92358efff765a130fb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a79b2410c270f1e92358efff765a130fb">array_equiv</a> (a1, a2)</td></tr>
<tr class="separator:a79b2410c270f1e92358efff765a130fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3287732f6c508bbfb36d38dd66c81a78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a3287732f6c508bbfb36d38dd66c81a78">extend_all</a> (<a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ac75d59d42115842ec94bddfcea9eb55e">module</a>)</td></tr>
<tr class="separator:a3287732f6c508bbfb36d38dd66c81a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae37e6ffc5c512f8f779f5f80e0b5b125"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ae37e6ffc5c512f8f779f5f80e0b5b125">bitwise_not</a></td></tr>
<tr class="separator:ae37e6ffc5c512f8f779f5f80e0b5b125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6849667f3ff1fc8e6744d78ddb9bb255"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a6849667f3ff1fc8e6744d78ddb9bb255">ufunc</a></td></tr>
<tr class="separator:a6849667f3ff1fc8e6744d78ddb9bb255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12131451d407734cb2ada6ed24a5cb37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a12131451d407734cb2ada6ed24a5cb37">newaxis</a></td></tr>
<tr class="separator:a12131451d407734cb2ada6ed24a5cb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1698b6cbb64f3efa755817bb901bd671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a1698b6cbb64f3efa755817bb901bd671">array_function_dispatch</a></td></tr>
<tr class="separator:a1698b6cbb64f3efa755817bb901bd671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75d59d42115842ec94bddfcea9eb55e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ac75d59d42115842ec94bddfcea9eb55e">module</a></td></tr>
<tr class="separator:ac75d59d42115842ec94bddfcea9eb55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adade5a81e5fd356066c0a15efab7e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a9adade5a81e5fd356066c0a15efab7e1">little_endian</a></td></tr>
<tr class="separator:a9adade5a81e5fd356066c0a15efab7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ceaed7c0d5510027ba55035b6fa22d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#af6ceaed7c0d5510027ba55035b6fa22d">Inf</a></td></tr>
<tr class="separator:af6ceaed7c0d5510027ba55035b6fa22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66178886e0a5addcb6bdc1c40a86093d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a66178886e0a5addcb6bdc1c40a86093d">inf</a></td></tr>
<tr class="separator:a66178886e0a5addcb6bdc1c40a86093d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32a6f5640d70cf737e66258373686ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#ab32a6f5640d70cf737e66258373686ff">infty</a></td></tr>
<tr class="separator:ab32a6f5640d70cf737e66258373686ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf0e999614f2c21f60df98b46dfe3bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aaaf0e999614f2c21f60df98b46dfe3bb">Infinity</a></td></tr>
<tr class="separator:aaaf0e999614f2c21f60df98b46dfe3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b68747d149cd435f8a72a27a3064423"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a4b68747d149cd435f8a72a27a3064423">nan</a></td></tr>
<tr class="separator:a4b68747d149cd435f8a72a27a3064423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88f5603f133be779d23143fa29a34ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aa88f5603f133be779d23143fa29a34ac">NaN</a></td></tr>
<tr class="separator:aa88f5603f133be779d23143fa29a34ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8551e415af62ce8b4ef665319c6f1b9a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a8551e415af62ce8b4ef665319c6f1b9a">False_</a></td></tr>
<tr class="separator:a8551e415af62ce8b4ef665319c6f1b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00a75e1a5aaf8d6ffbd085dbe0c848e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aa00a75e1a5aaf8d6ffbd085dbe0c848e">True_</a></td></tr>
<tr class="separator:aa00a75e1a5aaf8d6ffbd085dbe0c848e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad595579ad95d35c8e9b43080cbbe2d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad595579ad95d35c8e9b43080cbbe2d19">&#9670;&nbsp;</a></span>allclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.allclose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>1.e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>atol</em> = <code>1.e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equal_nan</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if two arrays are element-wise equal within a tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

NaNs are treated as equal if they are in the same place and if
``equal_nan=True``.  Infs are treated as equal if they are in the same
place and of the same sign in both arrays.

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : float
    The relative tolerance parameter (see Notes).
atol : float
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

    .. versionadded:: 1.10.0

Returns
-------
allclose : bool
    Returns True if the two arrays are equal within the given
    tolerance; False otherwise.

See Also
--------
isclose, all, any, equal

Notes
-----
If the following equation is element-wise True, then allclose returns
True.

 absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))

The above equation is not symmetric in `a` and `b`, so that
``allclose(a, b)`` might be different from ``allclose(b, a)`` in
some rare cases.

The comparison of `a` and `b` uses standard broadcasting, which
means that `a` and `b` need not have the same shape in order for
``allclose(a, b)`` to evaluate to True.  The same is true for
`equal` but not `array_equal`.

`allclose` is not defined for non-numeric data types.

Examples
--------
&gt;&gt;&gt; np.allclose([1e10,1e-7], [1.00001e10,1e-8])
False
&gt;&gt;&gt; np.allclose([1e10,1e-8], [1.00001e10,1e-9])
True
&gt;&gt;&gt; np.allclose([1e10,1e-8], [1.0001e10,1e-9])
False
&gt;&gt;&gt; np.allclose([1.0, np.nan], [1.0, np.nan])
False
&gt;&gt;&gt; np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
True</pre> 
</div>
</div>
<a id="a1b1ea621ebdf27d454d7d9887c68f67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1ea621ebdf27d454d7d9887c68f67a">&#9670;&nbsp;</a></span>argwhere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.argwhere </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the indices of array elements that are non-zero, grouped by element.

Parameters
----------
a : array_like
    Input data.

Returns
-------
index_array : (N, a.ndim) ndarray
    Indices of elements that are non-zero. Indices are grouped by element.
    This array will have shape ``(N, a.ndim)`` where ``N`` is the number of
    non-zero items.

See Also
--------
where, nonzero

Notes
-----
``np.argwhere(a)`` is almost the same as ``np.transpose(np.nonzero(a))``,
but produces a result of the correct shape for a 0D array.

The output of ``argwhere`` is not suitable for indexing arrays.
For this purpose use ``nonzero(a)`` instead.

Examples
--------
&gt;&gt;&gt; x = np.arange(6).reshape(2,3)
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.argwhere(x&gt;1)
array([[0, 2],
       [1, 0],
       [1, 1],
       [1, 2]])</pre> 
</div>
</div>
<a id="a2db68b636ed03415538dd11c25adbc6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db68b636ed03415538dd11c25adbc6a">&#9670;&nbsp;</a></span>array_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.array_equal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equal_nan</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">True if two arrays have the same shape and elements, False otherwise.

Parameters
----------
a1, a2 : array_like
    Input arrays.
equal_nan : bool
    Whether to compare NaN's as equal. If the dtype of a1 and a2 is
    complex, values will be considered equal if either the real or the
    imaginary component of a given value is ``nan``.

    .. versionadded:: 1.19.0

Returns
-------
b : bool
    Returns True if the arrays are equal.

See Also
--------
allclose: Returns True if two arrays are element-wise equal within a
          tolerance.
array_equiv: Returns True if input arrays are shape consistent and all
             elements equal.

Examples
--------
&gt;&gt;&gt; np.array_equal([1, 2], [1, 2])
True
&gt;&gt;&gt; np.array_equal(np.array([1, 2]), np.array([1, 2]))
True
&gt;&gt;&gt; np.array_equal([1, 2], [1, 2, 3])
False
&gt;&gt;&gt; np.array_equal([1, 2], [1, 4])
False
&gt;&gt;&gt; a = np.array([1, np.nan])
&gt;&gt;&gt; np.array_equal(a, a)
False
&gt;&gt;&gt; np.array_equal(a, a, equal_nan=True)
True

When ``equal_nan`` is True, complex values with nan components are
considered equal if either the real *or* the imaginary components are nan.

&gt;&gt;&gt; a = np.array([1 + 1j])
&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; a.real = np.nan
&gt;&gt;&gt; b.imag = np.nan
&gt;&gt;&gt; np.array_equal(a, b, equal_nan=True)
True
</pre> 
</div>
</div>
<a id="a79b2410c270f1e92358efff765a130fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b2410c270f1e92358efff765a130fb">&#9670;&nbsp;</a></span>array_equiv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.array_equiv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if input arrays are shape consistent and all elements equal.

Shape consistent means they are either the same shape, or one input array
can be broadcasted to create the same shape as the other one.

Parameters
----------
a1, a2 : array_like
    Input arrays.

Returns
-------
out : bool
    True if equivalent, False otherwise.

Examples
--------
&gt;&gt;&gt; np.array_equiv([1, 2], [1, 2])
True
&gt;&gt;&gt; np.array_equiv([1, 2], [1, 3])
False

Showing the shape equivalence:

&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 2]])
True
&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
False

&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 3]])
False</pre> 
</div>
</div>
<a id="a30faf8e5c0748ef6178c0c588756d7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30faf8e5c0748ef6178c0c588756d7a9">&#9670;&nbsp;</a></span>base_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.base_repr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a string representation of a number in the given base system.

Parameters
----------
number : int
    The value to convert. Positive and negative values are handled.
base : int, optional
    Convert `number` to the `base` number system. The valid range is 2-36,
    the default value is 2.
padding : int, optional
    Number of zeros padded on the left. Default is 0 (no padding).

Returns
-------
out : str
    String representation of `number` in `base` system.

See Also
--------
binary_repr : Faster version of `base_repr` for base 2.

Examples
--------
&gt;&gt;&gt; np.base_repr(5)
'101'
&gt;&gt;&gt; np.base_repr(6, 5)
'11'
&gt;&gt;&gt; np.base_repr(7, base=5, padding=3)
'00012'

&gt;&gt;&gt; np.base_repr(10, base=16)
'A'
&gt;&gt;&gt; np.base_repr(32, base=16)
'20'</pre> 
</div>
</div>
<a id="a496f8030a53d8ffbaee3639b18116428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496f8030a53d8ffbaee3639b18116428">&#9670;&nbsp;</a></span>binary_repr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.binary_repr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the binary representation of the input number as a string.

For negative numbers, if width is not given, a minus sign is added to the
front. If width is given, the two's complement of the number is
returned, with respect to that width.

In a two's-complement system negative numbers are represented by the two's
complement of the absolute value. This is the most common method of
representing signed integers on computers [1]_. A N-bit two's-complement
system can represent every integer in the range
:math:`-2^{N-1}` to :math:`+2^{N-1}-1`.

Parameters
----------
num : int
    Only an integer decimal number can be used.
width : int, optional
    The length of the returned string if `num` is positive, or the length
    of the two's complement if `num` is negative, provided that `width` is
    at least a sufficient number of bits for `num` to be represented in the
    designated form.

    If the `width` value is insufficient, it will be ignored, and `num` will
    be returned in binary (`num` &gt; 0) or two's complement (`num` &lt; 0) form
    with its width equal to the minimum number of bits needed to represent
    the number in the designated form. This behavior is deprecated and will
    later raise an error.

    .. deprecated:: 1.12.0

Returns
-------
bin : str
    Binary representation of `num` or two's complement of `num`.

See Also
--------
base_repr: Return a string representation of a number in the given base
           system.
bin: Python's built-in binary representation generator of an integer.

Notes
-----
`binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
faster.

References
----------
.. [1] Wikipedia, "Two's complement",
    https://en.wikipedia.org/wiki/Two's_complement

Examples
--------
&gt;&gt;&gt; np.binary_repr(3)
'11'
&gt;&gt;&gt; np.binary_repr(-3)
'-11'
&gt;&gt;&gt; np.binary_repr(3, width=4)
'0011'

The two's complement is returned when the input number is negative and
width is specified:

&gt;&gt;&gt; np.binary_repr(-3, width=3)
'101'
&gt;&gt;&gt; np.binary_repr(-3, width=5)
'11101'</pre> 
</div>
</div>
<a id="af1d206f80ecc160a47c672986d063595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d206f80ecc160a47c672986d063595">&#9670;&nbsp;</a></span>convolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.convolve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'<a class="el" href="namespacenumpy_1_1core_1_1numeric.html#aa5dcece77169e453f2094ad8a884ced8">full</a>'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the discrete, linear convolution of two one-dimensional sequences.

The convolution operator is often seen in signal processing, where it
models the effect of a linear time-invariant system on a signal [1]_.  In
probability theory, the sum of two independent random variables is
distributed according to the convolution of their individual
distributions.

If `v` is longer than `a`, the arrays are swapped before computation.

Parameters
----------
a : (N,) array_like
    First one-dimensional input array.
v : (M,) array_like
    Second one-dimensional input array.
mode : {'full', 'valid', 'same'}, optional
    'full':
      By default, mode is 'full'.  This returns the convolution
      at each point of overlap, with an output shape of (N+M-1,). At
      the end-points of the convolution, the signals do not overlap
      completely, and boundary effects may be seen.

    'same':
      Mode 'same' returns output of length ``max(M, N)``.  Boundary
      effects are still visible.

    'valid':
      Mode 'valid' returns output of length
      ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
      for points where the signals overlap completely.  Values outside
      the signal boundary have no effect.

Returns
-------
out : ndarray
    Discrete, linear convolution of `a` and `v`.

See Also
--------
scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
                           Transform.
scipy.linalg.toeplitz : Used to construct the convolution operator.
polymul : Polynomial multiplication. Same output as convolve, but also
          accepts poly1d objects as input.

Notes
-----
The discrete convolution operation is defined as

.. math:: (a * v)[n] = \\sum_{m = -\\infty}^{\\infty} a[m] v[n - m]

It can be shown that a convolution :math:`x(t) * y(t)` in time/space
is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
domain, after appropriate padding (padding is necessary to prevent
circular convolution).  Since multiplication is more efficient (faster)
than convolution, the function `scipy.signal.fftconvolve` exploits the
FFT to calculate the convolution of large data-sets.

References
----------
.. [1] Wikipedia, "Convolution",
    https://en.wikipedia.org/wiki/Convolution

Examples
--------
Note how the convolution operator flips the second array
before "sliding" the two across one another:

&gt;&gt;&gt; np.convolve([1, 2, 3], [0, 1, 0.5])
array([0. , 1. , 2.5, 4. , 1.5])

Only return the middle values of the convolution.
Contains boundary effects, where zeros are taken
into account:

&gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], 'same')
array([1. ,  2.5,  4. ])

The two arrays are of the same length, so there
is only one position where they completely overlap:

&gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], 'valid')
array([2.5])</pre> 
</div>
</div>
<a id="aadcf1c35df9b086c7f3dec19cc6c9579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcf1c35df9b086c7f3dec19cc6c9579">&#9670;&nbsp;</a></span>correlate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.correlate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'valid'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cross-correlation of two 1-dimensional sequences.

This function computes the correlation as generally defined in signal
processing texts::

    c_{av}[k] = sum_n a[n+k] * conj(v[n])

with a and v sequences being zero-padded where necessary and conj being
the conjugate.

Parameters
----------
a, v : array_like
    Input sequences.
mode : {'valid', 'same', 'full'}, optional
    Refer to the `convolve` docstring.  Note that the default
    is 'valid', unlike `convolve`, which uses 'full'.
old_behavior : bool
    `old_behavior` was removed in NumPy 1.10. If you need the old
    behavior, use `multiarray.correlate`.

Returns
-------
out : ndarray
    Discrete cross-correlation of `a` and `v`.

See Also
--------
convolve : Discrete, linear convolution of two one-dimensional sequences.
multiarray.correlate : Old, no conjugate, version of correlate.
scipy.signal.correlate : uses FFT which has superior performance on large arrays. 

Notes
-----
The definition of correlation above is not unique and sometimes correlation
may be defined differently. Another common definition is::

    c'_{av}[k] = sum_n a[n] conj(v[n+k])

which is related to ``c_{av}[k]`` by ``c'_{av}[k] = c_{av}[-k]``.

`numpy.correlate` may perform slowly in large arrays (i.e. n = 1e5) because it does
not use the FFT to compute the convolution; in that case, `scipy.signal.correlate` might
be preferable.


Examples
--------
&gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5])
array([3.5])
&gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5], "same")
array([2. ,  3.5,  3. ])
&gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5], "full")
array([0.5,  2. ,  3.5,  3. ,  0. ])

Using complex sequences:

&gt;&gt;&gt; np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])

Note that you get the time reversed, complex conjugated result
when the two input sequences change places, i.e.,
``c_{va}[k] = c^{*}_{av}[-k]``:

&gt;&gt;&gt; np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])</pre> 
</div>
</div>
<a id="a2c64f4a657e9277ac9196f1e5c9c8ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c64f4a657e9277ac9196f1e5c9c8ce3">&#9670;&nbsp;</a></span>count_nonzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.count_nonzero </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keepdims</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Counts the number of non-zero values in the array ``a``.

The word "non-zero" is in reference to the Python 2.x
built-in method ``__nonzero__()`` (renamed ``__bool__()``
in Python 3.x) of Python objects that tests an object's
"truthfulness". For example, any number is considered
truthful if it is nonzero, whereas any string is considered
truthful if it is not the empty string. Thus, this function
(recursively) counts how many elements in ``a`` (and in
sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``
method evaluated to ``True``.

Parameters
----------
a : array_like
    The array for which to count non-zeros.
axis : int or tuple, optional
    Axis or tuple of axes along which to count non-zeros.
    Default is None, meaning that non-zeros will be counted
    along a flattened version of ``a``.

    .. versionadded:: 1.12.0

keepdims : bool, optional
    If this is set to True, the axes that are counted are left
    in the result as dimensions with size one. With this option,
    the result will broadcast correctly against the input array.

    .. versionadded:: 1.19.0

Returns
-------
count : int or array of int
    Number of non-zero values in the array along a given axis.
    Otherwise, the total number of non-zero values in the array
    is returned.

See Also
--------
nonzero : Return the coordinates of all the non-zero values.

Examples
--------
&gt;&gt;&gt; np.count_nonzero(np.eye(4))
4
&gt;&gt;&gt; a = np.array([[0, 1, 7, 0],
...               [3, 0, 2, 19]])
&gt;&gt;&gt; np.count_nonzero(a)
5
&gt;&gt;&gt; np.count_nonzero(a, axis=0)
array([1, 1, 2, 1])
&gt;&gt;&gt; np.count_nonzero(a, axis=1)
array([2, 3])
&gt;&gt;&gt; np.count_nonzero(a, axis=1, keepdims=True)
array([[2],
       [3]])
</pre> 
</div>
</div>
<a id="a2002e78dc75a2cc31a1b29af6feee132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2002e78dc75a2cc31a1b29af6feee132">&#9670;&nbsp;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.cross </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axisa</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axisb</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axisc</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the cross product of two (arrays of) vectors.

The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
are defined by the last axis of `a` and `b` by default, and these axes
can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
2, the third component of the input vector is assumed to be zero and the
cross product calculated accordingly.  In cases where both input vectors
have dimension 2, the z-component of the cross product is returned.

Parameters
----------
a : array_like
    Components of the first vector(s).
b : array_like
    Components of the second vector(s).
axisa : int, optional
    Axis of `a` that defines the vector(s).  By default, the last axis.
axisb : int, optional
    Axis of `b` that defines the vector(s).  By default, the last axis.
axisc : int, optional
    Axis of `c` containing the cross product vector(s).  Ignored if
    both input vectors have dimension 2, as the return is scalar.
    By default, the last axis.
axis : int, optional
    If defined, the axis of `a`, `b` and `c` that defines the vector(s)
    and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.

Returns
-------
c : ndarray
    Vector cross product(s).

Raises
------
ValueError
    When the dimension of the vector(s) in `a` and/or `b` does not
    equal 2 or 3.

See Also
--------
inner : Inner product
outer : Outer product.
ix_ : Construct index arrays.

Notes
-----
.. versionadded:: 1.9.0

Supports full broadcasting of the inputs.

Examples
--------
Vector cross-product.

&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; y = [4, 5, 6]
&gt;&gt;&gt; np.cross(x, y)
array([-3,  6, -3])

One vector with dimension 2.

&gt;&gt;&gt; x = [1, 2]
&gt;&gt;&gt; y = [4, 5, 6]
&gt;&gt;&gt; np.cross(x, y)
array([12, -6, -3])

Equivalently:

&gt;&gt;&gt; x = [1, 2, 0]
&gt;&gt;&gt; y = [4, 5, 6]
&gt;&gt;&gt; np.cross(x, y)
array([12, -6, -3])

Both vectors with dimension 2.

&gt;&gt;&gt; x = [1,2]
&gt;&gt;&gt; y = [4,5]
&gt;&gt;&gt; np.cross(x, y)
array(-3)

Multiple vector cross-products. Note that the direction of the cross
product vector is defined by the `right-hand rule`.

&gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6]])
&gt;&gt;&gt; y = np.array([[4,5,6], [1,2,3]])
&gt;&gt;&gt; np.cross(x, y)
array([[-3,  6, -3],
       [ 3, -6,  3]])

The orientation of `c` can be changed using the `axisc` keyword.

&gt;&gt;&gt; np.cross(x, y, axisc=0)
array([[-3,  3],
       [ 6, -6],
       [-3,  3]])

Change the vector definition of `x` and `y` using `axisa` and `axisb`.

&gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
&gt;&gt;&gt; y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
&gt;&gt;&gt; np.cross(x, y)
array([[ -6,  12,  -6],
       [  0,   0,   0],
       [  6, -12,   6]])
&gt;&gt;&gt; np.cross(x, y, axisa=0, axisb=0)
array([[-24,  48, -24],
       [-30,  60, -30],
       [-36,  72, -36]])</pre> 
</div>
</div>
<a id="a3287732f6c508bbfb36d38dd66c81a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3287732f6c508bbfb36d38dd66c81a78">&#9670;&nbsp;</a></span>extend_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.extend_all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8b23f45060462d59df4609deb36da30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b23f45060462d59df4609deb36da30">&#9670;&nbsp;</a></span>flatnonzero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.flatnonzero </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return indices that are non-zero in the flattened version of a.

This is equivalent to np.nonzero(np.ravel(a))[0].

Parameters
----------
a : array_like
    Input data.

Returns
-------
res : ndarray
    Output array, containing the indices of the elements of `a.ravel()`
    that are non-zero.

See Also
--------
nonzero : Return the indices of the non-zero elements of the input array.
ravel : Return a 1-D array containing the elements of the input array.

Examples
--------
&gt;&gt;&gt; x = np.arange(-2, 3)
&gt;&gt;&gt; x
array([-2, -1,  0,  1,  2])
&gt;&gt;&gt; np.flatnonzero(x)
array([0, 1, 3, 4])

Use the indices of the non-zero elements as an index array to extract
these elements:

&gt;&gt;&gt; x.ravel()[np.flatnonzero(x)]
array([-2, -1,  1,  2])</pre> 
</div>
</div>
<a id="aabe97d2dd9a9996cb96ca02a03ef0ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe97d2dd9a9996cb96ca02a03ef0ae6">&#9670;&nbsp;</a></span>fromfunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.fromfunction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>float</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Construct an array by executing a function over each coordinate.

The resulting array therefore has a value ``fn(x, y, z)`` at
coordinate ``(x, y, z)``.

Parameters
----------
function : callable
    The function is called with N parameters, where N is the rank of
    `shape`.  Each parameter represents the coordinates of the array
    varying along a specific axis.  For example, if `shape`
    were ``(2, 2)``, then the parameters would be
    ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
shape : (N,) tuple of ints
    Shape of the output array, which also determines the shape of
    the coordinate arrays passed to `function`.
dtype : data-type, optional
    Data-type of the coordinate arrays passed to `function`.
    By default, `dtype` is float.
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
fromfunction : any
    The result of the call to `function` is passed back directly.
    Therefore the shape of `fromfunction` is completely determined by
    `function`.  If `function` returns a scalar value, the shape of
    `fromfunction` would not match the `shape` parameter.

See Also
--------
indices, meshgrid

Notes
-----
Keywords other than `dtype` are passed to `function`.

Examples
--------
&gt;&gt;&gt; np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
array([[ True, False, False],
       [False,  True, False],
       [False, False,  True]])

&gt;&gt;&gt; np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
array([[0, 1, 2],
       [1, 2, 3],
       [2, 3, 4]])</pre> 
</div>
</div>
<a id="aa5dcece77169e453f2094ad8a884ced8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5dcece77169e453f2094ad8a884ced8">&#9670;&nbsp;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.full </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'C'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new array of given shape and type, filled with `fill_value`.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
fill_value : scalar or array_like
    Fill value.
dtype : data-type, optional
    The desired data-type for the array  The default, None, means
     ``np.array(fill_value).dtype``.
order : {'C', 'F'}, optional
    Whether to store multidimensional data in C- or Fortran-contiguous
    (row- or column-wise) order in memory.
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
out : ndarray
    Array of `fill_value` with the given shape, dtype, and order.

See Also
--------
full_like : Return a new array with shape of input filled with value.
empty : Return a new uninitialized array.
ones : Return a new array setting values to one.
zeros : Return a new array setting values to zero.

Examples
--------
&gt;&gt;&gt; np.full((2, 2), np.inf)
array([[inf, inf],
       [inf, inf]])
&gt;&gt;&gt; np.full((2, 2), 10)
array([[10, 10],
       [10, 10]])

&gt;&gt;&gt; np.full((2, 2), [1, 2])
array([[1, 2],
       [1, 2]])</pre> 
</div>
</div>
<a id="ab36c0d44478fd8d1cd569ab44cba5b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36c0d44478fd8d1cd569ab44cba5b4b">&#9670;&nbsp;</a></span>full_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.full_like </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'K'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subok</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a full array with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
fill_value : scalar
    Fill value.
dtype : data-type, optional
    Overrides the data type of the result.
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of `a`, otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of `fill_value` with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full : Return a new array of given shape filled with value.

Examples
--------
&gt;&gt;&gt; x = np.arange(6, dtype=int)
&gt;&gt;&gt; np.full_like(x, 1)
array([1, 1, 1, 1, 1, 1])
&gt;&gt;&gt; np.full_like(x, 0.1)
array([0, 0, 0, 0, 0, 0])
&gt;&gt;&gt; np.full_like(x, 0.1, dtype=np.double)
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
&gt;&gt;&gt; np.full_like(x, np.nan, dtype=np.double)
array([nan, nan, nan, nan, nan, nan])

&gt;&gt;&gt; y = np.arange(6, dtype=np.double)
&gt;&gt;&gt; np.full_like(y, 0.1)
array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])</pre> 
</div>
</div>
<a id="a30ce08a6d993ca8e40d80e55ae83cd19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ce08a6d993ca8e40d80e55ae83cd19">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.identity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the identity array.

The identity array is a square array with ones on
the main diagonal.

Parameters
----------
n : int
    Number of rows (and columns) in `n` x `n` output.
dtype : data-type, optional
    Data-type of the output.  Defaults to ``float``.
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
out : ndarray
    `n` x `n` array with its main diagonal set to one,
    and all other elements 0.

Examples
--------
&gt;&gt;&gt; np.identity(3)
array([[1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.]])</pre> 
</div>
</div>
<a id="ae2f1041249cac51abe61aa5f3ccfc951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f1041249cac51abe61aa5f3ccfc951">&#9670;&nbsp;</a></span>indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.indices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dimensions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>int</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sparse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array representing the indices of a grid.

Compute an array where the subarrays contain index values 0, 1, ...
varying only along the corresponding axis.

Parameters
----------
dimensions : sequence of ints
    The shape of the grid.
dtype : dtype, optional
    Data type of the result.
sparse : boolean, optional
    Return a sparse representation of the grid instead of a dense
    representation. Default is False.

    .. versionadded:: 1.17

Returns
-------
grid : one ndarray or tuple of ndarrays
    If sparse is False:
        Returns one array of grid indices,
        ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
    If sparse is True:
        Returns a tuple of arrays, with
        ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with
        dimensions[i] in the ith place

See Also
--------
mgrid, ogrid, meshgrid

Notes
-----
The output shape in the dense case is obtained by prepending the number
of dimensions in front of the tuple of dimensions, i.e. if `dimensions`
is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is
``(N, r0, ..., rN-1)``.

The subarrays ``grid[k]`` contains the N-D array of indices along the
``k-th`` axis. Explicitly::

    grid[k, i0, i1, ..., iN-1] = ik

Examples
--------
&gt;&gt;&gt; grid = np.indices((2, 3))
&gt;&gt;&gt; grid.shape
(2, 2, 3)
&gt;&gt;&gt; grid[0]        # row indices
array([[0, 0, 0],
       [1, 1, 1]])
&gt;&gt;&gt; grid[1]        # column indices
array([[0, 1, 2],
       [0, 1, 2]])

The indices can be used as an index into an array.

&gt;&gt;&gt; x = np.arange(20).reshape(5, 4)
&gt;&gt;&gt; row, col = np.indices((2, 3))
&gt;&gt;&gt; x[row, col]
array([[0, 1, 2],
       [4, 5, 6]])

Note that it would be more straightforward in the above example to
extract the required elements directly with ``x[:2, :3]``.

If sparse is set to true, the grid will be returned in a sparse
representation.

&gt;&gt;&gt; i, j = np.indices((2, 3), sparse=True)
&gt;&gt;&gt; i.shape
(2, 1)
&gt;&gt;&gt; j.shape
(1, 3)
&gt;&gt;&gt; i        # row indices
array([[0],
       [1]])
&gt;&gt;&gt; j        # column indices
array([[0, 1, 2]])</pre> 
</div>
</div>
<a id="a6874bed1b6f01fc26401509337d83ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6874bed1b6f01fc26401509337d83ea4">&#9670;&nbsp;</a></span>isclose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.isclose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>1.e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>atol</em> = <code>1.e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>equal_nan</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a boolean array where two arrays are element-wise equal within a
tolerance.

The tolerance values are positive, typically very small numbers.  The
relative difference (`rtol` * abs(`b`)) and the absolute difference
`atol` are added together to compare against the absolute difference
between `a` and `b`.

.. warning:: The default `atol` is not appropriate for comparing numbers
             that are much smaller than one (see Notes).

Parameters
----------
a, b : array_like
    Input arrays to compare.
rtol : float
    The relative tolerance parameter (see Notes).
atol : float
    The absolute tolerance parameter (see Notes).
equal_nan : bool
    Whether to compare NaN's as equal.  If True, NaN's in `a` will be
    considered equal to NaN's in `b` in the output array.

Returns
-------
y : array_like
    Returns a boolean array of where `a` and `b` are equal within the
    given tolerance. If both `a` and `b` are scalars, returns a single
    boolean value.

See Also
--------
allclose
math.isclose

Notes
-----
.. versionadded:: 1.7.0

For finite values, isclose uses the following equation to test whether
two floating point values are equivalent.

 absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))

Unlike the built-in `math.isclose`, the above equation is not symmetric
in `a` and `b` -- it assumes `b` is the reference value -- so that
`isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,
the default value of atol is not zero, and is used to determine what
small values should be considered close to zero. The default value is
appropriate for expected values of order unity: if the expected values
are significantly smaller than one, it can result in false positives.
`atol` should be carefully selected for the use case at hand. A zero value
for `atol` will result in `False` if either `a` or `b` is zero.

`isclose` is not defined for non-numeric data types.

Examples
--------
&gt;&gt;&gt; np.isclose([1e10,1e-7], [1.00001e10,1e-8])
array([ True, False])
&gt;&gt;&gt; np.isclose([1e10,1e-8], [1.00001e10,1e-9])
array([ True, True])
&gt;&gt;&gt; np.isclose([1e10,1e-8], [1.0001e10,1e-9])
array([False,  True])
&gt;&gt;&gt; np.isclose([1.0, np.nan], [1.0, np.nan])
array([ True, False])
&gt;&gt;&gt; np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
array([ True, True])
&gt;&gt;&gt; np.isclose([1e-8, 1e-7], [0.0, 0.0])
array([ True, False])
&gt;&gt;&gt; np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
array([False, False])
&gt;&gt;&gt; np.isclose([1e-10, 1e-10], [1e-20, 0.0])
array([ True,  True])
&gt;&gt;&gt; np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
array([False,  True])
</pre> 
</div>
</div>
<a id="aca2519ee360f263c4f3410065dd08692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2519ee360f263c4f3410065dd08692">&#9670;&nbsp;</a></span>isfortran()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.isfortran </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the array is Fortran contiguous but *not* C contiguous.

This function is obsolete and, because of changes due to relaxed stride
checking, its return value for the same array may differ for versions
of NumPy &gt;= 1.10.0 and previous versions. If you only want to check if an
array is Fortran contiguous use ``a.flags.f_contiguous`` instead.

Parameters
----------
a : ndarray
    Input array.

Returns
-------
isfortran : bool
    Returns True if the array is Fortran contiguous but *not* C contiguous.


Examples
--------

np.array allows to specify whether the array is written in C-contiguous
order (last index varies the fastest), or FORTRAN-contiguous order in
memory (first index varies the fastest).

&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.isfortran(a)
False

&gt;&gt;&gt; b = np.array([[1, 2, 3], [4, 5, 6]], order='F')
&gt;&gt;&gt; b
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.isfortran(b)
True


The transpose of a C-ordered array is a FORTRAN-ordered array.

&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
&gt;&gt;&gt; a
array([[1, 2, 3],
       [4, 5, 6]])
&gt;&gt;&gt; np.isfortran(a)
False
&gt;&gt;&gt; b = a.T
&gt;&gt;&gt; b
array([[1, 4],
       [2, 5],
       [3, 6]])
&gt;&gt;&gt; np.isfortran(b)
True

C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.

&gt;&gt;&gt; np.isfortran(np.array([1, 2], order='F'))
False</pre> 
</div>
</div>
<a id="a505e4f3fa802a70c6090e5e23124f847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505e4f3fa802a70c6090e5e23124f847">&#9670;&nbsp;</a></span>isscalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.isscalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns True if the type of `element` is a scalar type.

Parameters
----------
element : any
    Input argument, can be of any type and shape.

Returns
-------
val : bool
    True if `element` is a scalar type, False if it is not.

See Also
--------
ndim : Get the number of dimensions of an array

Notes
-----
If you need a stricter way to identify a *numerical* scalar, use
``isinstance(x, numbers.Number)``, as that returns ``False`` for most
non-numerical elements such as strings.

In most cases ``np.ndim(x) == 0`` should be used instead of this function,
as that will also return true for 0d arrays. This is how numpy overloads
functions in the style of the ``dx`` arguments to `gradient` and the ``bins``
argument to `histogram`. Some key differences:

+--------------------------------------+---------------+-------------------+
| x                                    |``isscalar(x)``|``np.ndim(x) == 0``|
+======================================+===============+===================+
| PEP 3141 numeric objects (including  | ``True``      | ``True``          |
| builtins)                            |               |                   |
+--------------------------------------+---------------+-------------------+
| builtin string and buffer objects    | ``True``      | ``True``          |
+--------------------------------------+---------------+-------------------+
| other builtin objects, like          | ``False``     | ``True``          |
| `pathlib.Path`, `Exception`,         |               |                   |
| the result of `re.compile`           |               |                   |
+--------------------------------------+---------------+-------------------+
| third-party objects like             | ``False``     | ``True``          |
| `matplotlib.figure.Figure`           |               |                   |
+--------------------------------------+---------------+-------------------+
| zero-dimensional numpy arrays        | ``False``     | ``True``          |
+--------------------------------------+---------------+-------------------+
| other numpy arrays                   | ``False``     | ``False``         |
+--------------------------------------+---------------+-------------------+
| `list`, `tuple`, and other sequence  | ``False``     | ``False``         |
| objects                              |               |                   |
+--------------------------------------+---------------+-------------------+

Examples
--------
&gt;&gt;&gt; np.isscalar(3.1)
True
&gt;&gt;&gt; np.isscalar(np.array(3.1))
False
&gt;&gt;&gt; np.isscalar([3.1])
False
&gt;&gt;&gt; np.isscalar(False)
True
&gt;&gt;&gt; np.isscalar('numpy')
True

NumPy supports PEP 3141 numbers:

&gt;&gt;&gt; from fractions import Fraction
&gt;&gt;&gt; np.isscalar(Fraction(5, 17))
True
&gt;&gt;&gt; from numbers import Number
&gt;&gt;&gt; np.isscalar(Number())
True</pre> 
</div>
</div>
<a id="ac7ac41a75a5af16516241f4a6fb96e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7ac41a75a5af16516241f4a6fb96e6b">&#9670;&nbsp;</a></span>moveaxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.moveaxis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Move axes of an array to new positions.

Other axes remain in their original order.

.. versionadded:: 1.11.0

Parameters
----------
a : np.ndarray
    The array whose axes should be reordered.
source : int or sequence of int
    Original positions of the axes to move. These must be unique.
destination : int or sequence of int
    Destination positions for each of the original axes. These must also be
    unique.

Returns
-------
result : np.ndarray
    Array with moved axes. This array is a view of the input array.

See Also
--------
transpose : Permute the dimensions of an array.
swapaxes : Interchange two axes of an array.

Examples
--------
&gt;&gt;&gt; x = np.zeros((3, 4, 5))
&gt;&gt;&gt; np.moveaxis(x, 0, -1).shape
(4, 5, 3)
&gt;&gt;&gt; np.moveaxis(x, -1, 0).shape
(5, 3, 4)

These all achieve the same result:

&gt;&gt;&gt; np.transpose(x).shape
(5, 4, 3)
&gt;&gt;&gt; np.swapaxes(x, 0, -1).shape
(5, 4, 3)
&gt;&gt;&gt; np.moveaxis(x, [0, 1], [-1, -2]).shape
(5, 4, 3)
&gt;&gt;&gt; np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
(5, 4, 3)</pre> 
</div>
</div>
<a id="a9d5bcc0eaa759ce1ab86f25402ae03ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5bcc0eaa759ce1ab86f25402ae03ac">&#9670;&nbsp;</a></span>normalize_axis_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.normalize_axis_tuple </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ndim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>argname</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_duplicate</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Normalizes an axis argument into a tuple of non-negative integer axes.

This handles shorthands such as ``1`` and converts them to ``(1,)``,
as well as performing the handling of negative indices covered by
`normalize_axis_index`.

By default, this forbids axes from being specified multiple times.

Used internally by multi-axis-checking logic.

.. versionadded:: 1.13.0

Parameters
----------
axis : int, iterable of int
    The un-normalized index or indices of the axis.
ndim : int
    The number of dimensions of the array that `axis` should be normalized
    against.
argname : str, optional
    A prefix to put before the error message, typically the name of the
    argument.
allow_duplicate : bool, optional
    If False, the default, disallow an axis from being specified twice.

Returns
-------
normalized_axes : tuple of int
    The normalized axis index, such that `0 &lt;= normalized_axis &lt; ndim`

Raises
------
AxisError
    If any axis provided is out of range
ValueError
    If an axis is repeated

See also
--------
normalize_axis_index : normalizing a single scalar axis
</pre> 
</div>
</div>
<a id="a6bdbcb3ea5a55908e290dee2c72c0079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdbcb3ea5a55908e290dee2c72c0079">&#9670;&nbsp;</a></span>ones()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.ones </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'C'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>like</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new array of given shape and type, filled with ones.

Parameters
----------
shape : int or sequence of ints
    Shape of the new array, e.g., ``(2, 3)`` or ``2``.
dtype : data-type, optional
    The desired data-type for the array, e.g., `numpy.int8`.  Default is
    `numpy.float64`.
order : {'C', 'F'}, optional, default: C
    Whether to store multi-dimensional data in row-major
    (C-style) or column-major (Fortran-style) order in
    memory.
${ARRAY_FUNCTION_LIKE}

    .. versionadded:: 1.20.0

Returns
-------
out : ndarray
    Array of ones with the given shape, dtype, and order.

See Also
--------
ones_like : Return an array of ones with shape and type of input.
empty : Return a new uninitialized array.
zeros : Return a new array setting values to zero.
full : Return a new array of given shape filled with value.


Examples
--------
&gt;&gt;&gt; np.ones(5)
array([1., 1., 1., 1., 1.])

&gt;&gt;&gt; np.ones((5,), dtype=int)
array([1, 1, 1, 1, 1])

&gt;&gt;&gt; np.ones((2, 1))
array([[1.],
       [1.]])

&gt;&gt;&gt; s = (2,2)
&gt;&gt;&gt; np.ones(s)
array([[1.,  1.],
       [1.,  1.]])</pre> 
</div>
</div>
<a id="a788d1bc80059cdd4214e4f76fd142cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788d1bc80059cdd4214e4f76fd142cc0">&#9670;&nbsp;</a></span>ones_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.ones_like </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'K'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subok</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array of ones with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of `a`, otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of ones with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
zeros_like : Return an array of zeros with shape and type of input.
full_like : Return a new array with shape of input filled with value.
ones : Return a new array setting values to one.

Examples
--------
&gt;&gt;&gt; x = np.arange(6)
&gt;&gt;&gt; x = x.reshape((2, 3))
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.ones_like(x)
array([[1, 1, 1],
       [1, 1, 1]])

&gt;&gt;&gt; y = np.arange(3, dtype=float)
&gt;&gt;&gt; y
array([0., 1., 2.])
&gt;&gt;&gt; np.ones_like(y)
array([1.,  1.,  1.])</pre> 
</div>
</div>
<a id="acb46476790d894e402755264dfc69ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb46476790d894e402755264dfc69ffb">&#9670;&nbsp;</a></span>outer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.outer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the outer product of two vectors.

Given two vectors, ``a = [a0, a1, ..., aM]`` and
``b = [b0, b1, ..., bN]``,
the outer product [1]_ is::

  [[a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN ]]

Parameters
----------
a : (M,) array_like
    First input vector.  Input is flattened if
    not already 1-dimensional.
b : (N,) array_like
    Second input vector.  Input is flattened if
    not already 1-dimensional.
out : (M, N) ndarray, optional
    A location where the result is stored

    .. versionadded:: 1.9.0

Returns
-------
out : (M, N) ndarray
    ``out[i, j] = a[i] * b[j]``

See also
--------
inner
einsum : ``einsum('i,j-&gt;ij', a.ravel(), b.ravel())`` is the equivalent.
ufunc.outer : A generalization to dimensions other than 1D and other
              operations. ``np.multiply.outer(a.ravel(), b.ravel())``
              is the equivalent.
tensordot : ``np.tensordot(a.ravel(), b.ravel(), axes=((), ()))``
            is the equivalent.

References
----------
.. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
         ed., Baltimore, MD, Johns Hopkins University Press, 1996,
         pg. 8.

Examples
--------
Make a (*very* coarse) grid for computing a Mandelbrot set:

&gt;&gt;&gt; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
&gt;&gt;&gt; rl
array([[-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.]])
&gt;&gt;&gt; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
&gt;&gt;&gt; im
array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
&gt;&gt;&gt; grid = rl + im
&gt;&gt;&gt; grid
array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])

An example using a "vector" of letters:

&gt;&gt;&gt; x = np.array(['a', 'b', 'c'], dtype=object)
&gt;&gt;&gt; np.outer(x, [1, 2, 3])
array([['a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc']], dtype=object)</pre> 
</div>
</div>
<a id="a5503974a131efadeeec73bf5eba4b43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5503974a131efadeeec73bf5eba4b43f">&#9670;&nbsp;</a></span>roll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.roll </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Roll array elements along a given axis.

Elements that roll beyond the last position are re-introduced at
the first.

Parameters
----------
a : array_like
    Input array.
shift : int or tuple of ints
    The number of places by which elements are shifted.  If a tuple,
    then `axis` must be a tuple of the same size, and each of the
    given axes is shifted by the corresponding number.  If an int
    while `axis` is a tuple of ints, then the same value is used for
    all given axes.
axis : int or tuple of ints, optional
    Axis or axes along which elements are shifted.  By default, the
    array is flattened before shifting, after which the original
    shape is restored.

Returns
-------
res : ndarray
    Output array, with the same shape as `a`.

See Also
--------
rollaxis : Roll the specified axis backwards, until it lies in a
           given position.

Notes
-----
.. versionadded:: 1.12.0

Supports rolling over multiple dimensions simultaneously.

Examples
--------
&gt;&gt;&gt; x = np.arange(10)
&gt;&gt;&gt; np.roll(x, 2)
array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
&gt;&gt;&gt; np.roll(x, -2)
array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])

&gt;&gt;&gt; x2 = np.reshape(x, (2,5))
&gt;&gt;&gt; x2
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
&gt;&gt;&gt; np.roll(x2, 1)
array([[9, 0, 1, 2, 3],
       [4, 5, 6, 7, 8]])
&gt;&gt;&gt; np.roll(x2, -1)
array([[1, 2, 3, 4, 5],
       [6, 7, 8, 9, 0]])
&gt;&gt;&gt; np.roll(x2, 1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
&gt;&gt;&gt; np.roll(x2, -1, axis=0)
array([[5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4]])
&gt;&gt;&gt; np.roll(x2, 1, axis=1)
array([[4, 0, 1, 2, 3],
       [9, 5, 6, 7, 8]])
&gt;&gt;&gt; np.roll(x2, -1, axis=1)
array([[1, 2, 3, 4, 0],
       [6, 7, 8, 9, 5]])</pre> 
</div>
</div>
<a id="a644e0d45bac850ac24fee58dc9f0d5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644e0d45bac850ac24fee58dc9f0d5cb">&#9670;&nbsp;</a></span>rollaxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.rollaxis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Roll the specified axis backwards, until it lies in a given position.

This function continues to be supported for backward compatibility, but you
should prefer `moveaxis`. The `moveaxis` function was added in NumPy
1.11.

Parameters
----------
a : ndarray
    Input array.
axis : int
    The axis to be rolled. The positions of the other axes do not
    change relative to one another.
start : int, optional
    When ``start &lt;= axis``, the axis is rolled back until it lies in
    this position. When ``start &gt; axis``, the axis is rolled until it
    lies before this position. The default, 0, results in a "complete"
    roll. The following table describes how negative values of ``start``
    are interpreted:

    .. table::
       :align: left

       +-------------------+----------------------+
       |     ``start``     | Normalized ``start`` |
       +===================+======================+
       | ``-(arr.ndim+1)`` | raise ``AxisError``  |
       +-------------------+----------------------+
       | ``-arr.ndim``     | 0                    |
       +-------------------+----------------------+
       | |vdots|           | |vdots|              |
       +-------------------+----------------------+
       | ``-1``            | ``arr.ndim-1``       |
       +-------------------+----------------------+
       | ``0``             | ``0``                |
       +-------------------+----------------------+
       | |vdots|           | |vdots|              |
       +-------------------+----------------------+
       | ``arr.ndim``      | ``arr.ndim``         |
       +-------------------+----------------------+
       | ``arr.ndim + 1``  | raise ``AxisError``  |
       +-------------------+----------------------+
       
    .. |vdots|   unicode:: U+22EE .. Vertical Ellipsis

Returns
-------
res : ndarray
    For NumPy &gt;= 1.10.0 a view of `a` is always returned. For earlier
    NumPy versions a view of `a` is returned only if the order of the
    axes is changed, otherwise the input array is returned.

See Also
--------
moveaxis : Move array axes to new positions.
roll : Roll the elements of an array by a number of positions along a
    given axis.

Examples
--------
&gt;&gt;&gt; a = np.ones((3,4,5,6))
&gt;&gt;&gt; np.rollaxis(a, 3, 1).shape
(3, 6, 4, 5)
&gt;&gt;&gt; np.rollaxis(a, 2).shape
(5, 3, 4, 6)
&gt;&gt;&gt; np.rollaxis(a, 1, 4).shape
(3, 5, 6, 4)</pre> 
</div>
</div>
<a id="ad0f92680111292b4be69b722b3732991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f92680111292b4be69b722b3732991">&#9670;&nbsp;</a></span>tensordot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.tensordot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axes</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute tensor dot product along specified axes.

Given two tensors, `a` and `b`, and an array_like object containing
two array_like objects, ``(a_axes, b_axes)``, sum the products of
`a`'s and `b`'s elements (components) over the axes specified by
``a_axes`` and ``b_axes``. The third argument can be a single non-negative
integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions
of `a` and the first ``N`` dimensions of `b` are summed over.

Parameters
----------
a, b : array_like
    Tensors to "dot".

axes : int or (2,) array_like
    * integer_like
      If an int N, sum over the last N axes of `a` and the first N axes
      of `b` in order. The sizes of the corresponding axes must match.
    * (2,) array_like
      Or, a list of axes to be summed over, first sequence applying to `a`,
      second to `b`. Both elements array_like must be of the same length.

Returns
-------
output : ndarray
    The tensor dot product of the input.

See Also
--------
dot, einsum

Notes
-----
Three common use cases are:
    * ``axes = 0`` : tensor product :math:`a\\otimes b`
    * ``axes = 1`` : tensor dot product :math:`a\\cdot b`
    * ``axes = 2`` : (default) tensor double contraction :math:`a:b`

When `axes` is integer_like, the sequence for evaluation will be: first
the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and
Nth axis in `b` last.

When there is more than one axis to sum over - and they are not the last
(first) axes of `a` (`b`) - the argument `axes` should consist of
two sequences of the same length, with the first axis to sum over given
first in both sequences, the second axis second, and so forth.

The shape of the result consists of the non-contracted axes of the
first tensor, followed by the non-contracted axes of the second.

Examples
--------
A "traditional" example:

&gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5)
&gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)
&gt;&gt;&gt; c = np.tensordot(a,b, axes=([1,0],[0,1]))
&gt;&gt;&gt; c.shape
(5, 2)
&gt;&gt;&gt; c
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
&gt;&gt;&gt; # A slower but equivalent way of computing the same...
&gt;&gt;&gt; d = np.zeros((5,2))
&gt;&gt;&gt; for i in range(5):
...   for j in range(2):
...     for k in range(3):
...       for n in range(4):
...         d[i,j] += a[k,n,i] * b[n,k,j]
&gt;&gt;&gt; c == d
array([[ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True]])

An extended example taking advantage of the overloading of + and \\*:

&gt;&gt;&gt; a = np.array(range(1, 9))
&gt;&gt;&gt; a.shape = (2, 2, 2)
&gt;&gt;&gt; A = np.array(('a', 'b', 'c', 'd'), dtype=object)
&gt;&gt;&gt; A.shape = (2, 2)
&gt;&gt;&gt; a; A
array([[[1, 2],
        [3, 4]],
       [[5, 6],
        [7, 8]]])
array([['a', 'b'],
       ['c', 'd']], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A) # third argument default is 2 for double-contraction
array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, 1)
array([[['acc', 'bdd'],
        ['aaacccc', 'bbbdddd']],
       [['aaaaacccccc', 'bbbbbdddddd'],
        ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, 0) # tensor product (result too long to incl.)
array([[[[['a', 'b'],
          ['c', 'd']],
          ...

&gt;&gt;&gt; np.tensordot(a, A, (0, 1))
array([[['abbbbb', 'cddddd'],
        ['aabbbbbb', 'ccdddddd']],
       [['aaabbbbbbb', 'cccddddddd'],
        ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, (2, 1))
array([[['abb', 'cdd'],
        ['aaabbbb', 'cccdddd']],
       [['aaaaabbbbbb', 'cccccdddddd'],
        ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, ((0, 1), (0, 1)))
array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)

&gt;&gt;&gt; np.tensordot(a, A, ((2, 1), (1, 0)))
array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)</pre> 
</div>
</div>
<a id="aff34b60351859b2e2797e226ad04ddd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff34b60351859b2e2797e226ad04ddd0">&#9670;&nbsp;</a></span>zeros_like()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def numpy.core.numeric.zeros_like </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>'K'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>subok</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>shape</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array of zeros with the same shape and type as a given array.

Parameters
----------
a : array_like
    The shape and data-type of `a` define these same attributes of
    the returned array.
dtype : data-type, optional
    Overrides the data type of the result.

    .. versionadded:: 1.6.0
order : {'C', 'F', 'A', or 'K'}, optional
    Overrides the memory layout of the result. 'C' means C-order,
    'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
    'C' otherwise. 'K' means match the layout of `a` as closely
    as possible.

    .. versionadded:: 1.6.0
subok : bool, optional.
    If True, then the newly created array will use the sub-class
    type of `a`, otherwise it will be a base-class array. Defaults
    to True.
shape : int or sequence of ints, optional.
    Overrides the shape of the result. If order='K' and the number of
    dimensions is unchanged, will try to keep order, otherwise,
    order='C' is implied.

    .. versionadded:: 1.17.0

Returns
-------
out : ndarray
    Array of zeros with the same shape and type as `a`.

See Also
--------
empty_like : Return an empty array with shape and type of input.
ones_like : Return an array of ones with shape and type of input.
full_like : Return a new array with shape of input filled with value.
zeros : Return a new array setting values to zero.

Examples
--------
&gt;&gt;&gt; x = np.arange(6)
&gt;&gt;&gt; x = x.reshape((2, 3))
&gt;&gt;&gt; x
array([[0, 1, 2],
       [3, 4, 5]])
&gt;&gt;&gt; np.zeros_like(x)
array([[0, 0, 0],
       [0, 0, 0]])

&gt;&gt;&gt; y = np.arange(3, dtype=float)
&gt;&gt;&gt; y
array([0., 1., 2.])
&gt;&gt;&gt; np.zeros_like(y)
array([0.,  0.,  0.])</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a1698b6cbb64f3efa755817bb901bd671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1698b6cbb64f3efa755817bb901bd671">&#9670;&nbsp;</a></span>array_function_dispatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.array_function_dispatch</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae37e6ffc5c512f8f779f5f80e0b5b125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37e6ffc5c512f8f779f5f80e0b5b125">&#9670;&nbsp;</a></span>bitwise_not</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.bitwise_not</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8551e415af62ce8b4ef665319c6f1b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8551e415af62ce8b4ef665319c6f1b9a">&#9670;&nbsp;</a></span>False_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.False_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6ceaed7c0d5510027ba55035b6fa22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ceaed7c0d5510027ba55035b6fa22d">&#9670;&nbsp;</a></span>Inf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.Inf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66178886e0a5addcb6bdc1c40a86093d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66178886e0a5addcb6bdc1c40a86093d">&#9670;&nbsp;</a></span>inf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.inf</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaaf0e999614f2c21f60df98b46dfe3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf0e999614f2c21f60df98b46dfe3bb">&#9670;&nbsp;</a></span>Infinity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.Infinity</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab32a6f5640d70cf737e66258373686ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32a6f5640d70cf737e66258373686ff">&#9670;&nbsp;</a></span>infty</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.infty</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9adade5a81e5fd356066c0a15efab7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adade5a81e5fd356066c0a15efab7e1">&#9670;&nbsp;</a></span>little_endian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.little_endian</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac75d59d42115842ec94bddfcea9eb55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac75d59d42115842ec94bddfcea9eb55e">&#9670;&nbsp;</a></span>module</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.module</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b68747d149cd435f8a72a27a3064423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b68747d149cd435f8a72a27a3064423">&#9670;&nbsp;</a></span>nan</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.nan</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa88f5603f133be779d23143fa29a34ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa88f5603f133be779d23143fa29a34ac">&#9670;&nbsp;</a></span>NaN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.NaN</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12131451d407734cb2ada6ed24a5cb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12131451d407734cb2ada6ed24a5cb37">&#9670;&nbsp;</a></span>newaxis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.newaxis</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa00a75e1a5aaf8d6ffbd085dbe0c848e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00a75e1a5aaf8d6ffbd085dbe0c848e">&#9670;&nbsp;</a></span>True_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.True_</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6849667f3ff1fc8e6744d78ddb9bb255"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6849667f3ff1fc8e6744d78ddb9bb255">&#9670;&nbsp;</a></span>ufunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.numeric.ufunc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
