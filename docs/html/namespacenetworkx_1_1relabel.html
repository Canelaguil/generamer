<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.relabel Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1relabel.html">relabel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.relabel Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb2e932876a58ed2a6eea531eb4f64f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1relabel.html#acb2e932876a58ed2a6eea531eb4f64f7">relabel_nodes</a> (G, mapping, copy=True)</td></tr>
<tr class="separator:acb2e932876a58ed2a6eea531eb4f64f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bef030d4c309b275324f4578af84f76"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1relabel.html#a5bef030d4c309b275324f4578af84f76">convert_node_labels_to_integers</a> (G, first_label=0, ordering=&quot;default&quot;, label_attribute=None)</td></tr>
<tr class="separator:a5bef030d4c309b275324f4578af84f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5bef030d4c309b275324f4578af84f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bef030d4c309b275324f4578af84f76">&#9670;&nbsp;</a></span>convert_node_labels_to_integers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.relabel.convert_node_labels_to_integers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>first_label</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordering</em> = <code>&quot;default&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>label_attribute</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a copy of the graph G with the nodes relabeled using
consecutive integers.

Parameters
----------
G : graph
   A NetworkX graph

first_label : int, optional (default=0)
   An integer specifying the starting offset in numbering nodes.
   The new integer labels are numbered first_label, ..., n-1+first_label.

ordering : string
   "default" : inherit node ordering from G.nodes()
   "sorted"  : inherit node ordering from sorted(G.nodes())
   "increasing degree" : nodes are sorted by increasing degree
   "decreasing degree" : nodes are sorted by decreasing degree

label_attribute : string, optional (default=None)
   Name of node attribute to store old label.  If None no attribute
   is created.

Notes
-----
Node and edge attribute data are copied to the new (relabeled) graph.

There is no guarantee that the relabeling of nodes to integers will
give the same two integers for two (even identical graphs).
Use the `ordering` argument to try to preserve the order.

See Also
--------
relabel_nodes
</pre> 
</div>
</div>
<a id="acb2e932876a58ed2a6eea531eb4f64f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2e932876a58ed2a6eea531eb4f64f7">&#9670;&nbsp;</a></span>relabel_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.relabel.relabel_nodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Relabel the nodes of the graph G according to a given mapping.

Parameters
----------
G : graph
   A NetworkX graph

mapping : dictionary
   A dictionary with the old labels as keys and new labels as values.
   A partial mapping is allowed. Mapping 2 nodes to a single node is allowed.
   Any non-node keys in the mapping are ignored.

copy : bool (optional, default=True)
   If True return a copy, or if False relabel the nodes in place.

Examples
--------
To create a new graph with nodes relabeled according to a given
dictionary:

&gt;&gt;&gt; G = nx.path_graph(3)
&gt;&gt;&gt; sorted(G)
[0, 1, 2]
&gt;&gt;&gt; mapping = {0: "a", 1: "b", 2: "c"}
&gt;&gt;&gt; H = nx.relabel_nodes(G, mapping)
&gt;&gt;&gt; sorted(H)
['a', 'b', 'c']

Nodes can be relabeled with any hashable object, including numbers
and strings:

&gt;&gt;&gt; import string
&gt;&gt;&gt; G = nx.path_graph(26)  # nodes are integers 0 through 25
&gt;&gt;&gt; sorted(G)[:3]
[0, 1, 2]
&gt;&gt;&gt; mapping = dict(zip(G, string.ascii_lowercase))
&gt;&gt;&gt; G = nx.relabel_nodes(G, mapping)  # nodes are characters a through z
&gt;&gt;&gt; sorted(G)[:3]
['a', 'b', 'c']
&gt;&gt;&gt; mapping = dict(zip(G, range(1, 27)))
&gt;&gt;&gt; G = nx.relabel_nodes(G, mapping)  # nodes are integers 1 through 26
&gt;&gt;&gt; sorted(G)[:3]
[1, 2, 3]

To perform a partial in-place relabeling, provide a dictionary
mapping only a subset of the nodes, and set the `copy` keyword
argument to False:

&gt;&gt;&gt; G = nx.path_graph(3)  # nodes 0-1-2
&gt;&gt;&gt; mapping = {0: "a", 1: "b"}  # 0-&gt;'a' and 1-&gt;'b'
&gt;&gt;&gt; G = nx.relabel_nodes(G, mapping, copy=False)
&gt;&gt;&gt; sorted(G, key=str)
[2, 'a', 'b']

A mapping can also be given as a function:

&gt;&gt;&gt; G = nx.path_graph(3)
&gt;&gt;&gt; H = nx.relabel_nodes(G, lambda x: x ** 2)
&gt;&gt;&gt; list(H)
[0, 1, 4]

In a multigraph, relabeling two or more nodes to the same new node
will retain all edges, but may change the edge keys in the process:

&gt;&gt;&gt; G = nx.MultiGraph()
&gt;&gt;&gt; G.add_edge(0, 1, value="a")  # returns the key for this edge
0
&gt;&gt;&gt; G.add_edge(0, 2, value="b")
0
&gt;&gt;&gt; G.add_edge(0, 3, value="c")
0
&gt;&gt;&gt; mapping = {1: 4, 2: 4, 3: 4}
&gt;&gt;&gt; H = nx.relabel_nodes(G, mapping, copy=True)
&gt;&gt;&gt; print(H[0])
{4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}

This works for in-place relabeling too:

&gt;&gt;&gt; G = nx.relabel_nodes(G, mapping, copy=False)
&gt;&gt;&gt; print(G[0])
{4: {0: {'value': 'a'}, 1: {'value': 'b'}, 2: {'value': 'c'}}}

Notes
-----
Only the nodes specified in the mapping will be relabeled.
Any non-node keys in the mapping are ignored.

The keyword setting copy=False modifies the graph in place.
Relabel_nodes avoids naming collisions by building a
directed graph from ``mapping`` which specifies the order of
relabelings. Naming collisions, such as a-&gt;b, b-&gt;c, are ordered
such that "b" gets renamed to "c" before "a" gets renamed "b".
In cases of circular mappings (e.g. a-&gt;b, b-&gt;a), modifying the
graph is not possible in-place and an exception is raised.
In that case, use copy=True.

If a relabel operation on a multigraph would cause two or more
edges to have the same source, target and key, the second edge must
be assigned a new key to retain all edges. The new key is set
to the lowest non-negative integer not already used as a key
for edges between these two nodes. Note that this means non-numeric
keys may be replaced by numeric keys.

See Also
--------
convert_node_labels_to_integers
</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
