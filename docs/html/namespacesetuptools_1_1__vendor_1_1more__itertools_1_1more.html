<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: setuptools._vendor.more_itertools.more Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesetuptools.html">setuptools</a></li><li class="navelem"><a class="el" href="namespacesetuptools_1_1__vendor.html">_vendor</a></li><li class="navelem"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools.html">more_itertools</a></li><li class="navelem"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html">more</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">setuptools._vendor.more_itertools.more Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1AbortThread.html">AbortThread</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1bucket.html">bucket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1callback__iter.html">callback_iter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1countable.html">countable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1islice__extended.html">islice_extended</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1numeric__range.html">numeric_range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1peekable.html">peekable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1run__length.html">run_length</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1seekable.html">seekable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1SequenceView.html">SequenceView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1time__limited.html">time_limited</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsetuptools_1_1__vendor_1_1more__itertools_1_1more_1_1UnequalIterablesError.html">UnequalIterablesError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4e54f042cb33c767fc916b14cc8f1a29"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a4e54f042cb33c767fc916b14cc8f1a29">chunked</a> (iterable, n, strict=False)</td></tr>
<tr class="separator:a4e54f042cb33c767fc916b14cc8f1a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74224dd623db9ad4e472e637a282d5d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a74224dd623db9ad4e472e637a282d5d4">first</a> (iterable, default=_marker)</td></tr>
<tr class="separator:a74224dd623db9ad4e472e637a282d5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86971974b505201c4419bd8aad9d1866"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a86971974b505201c4419bd8aad9d1866">last</a> (iterable, default=_marker)</td></tr>
<tr class="separator:a86971974b505201c4419bd8aad9d1866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9ade86fac5ccaff3d9591dd143575a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a6d9ade86fac5ccaff3d9591dd143575a">nth_or_last</a> (iterable, n, default=_marker)</td></tr>
<tr class="separator:a6d9ade86fac5ccaff3d9591dd143575a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7704c89f2e7f53903f060c465dbae459"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a7704c89f2e7f53903f060c465dbae459">collate</a> (iterables, kwargs)</td></tr>
<tr class="separator:a7704c89f2e7f53903f060c465dbae459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2bfd3e5689d1d8c07b735f8e3c1f3d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aba2bfd3e5689d1d8c07b735f8e3c1f3d">consumer</a> (func)</td></tr>
<tr class="separator:aba2bfd3e5689d1d8c07b735f8e3c1f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee771b986b4c83b08e8743d5402df06"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a7ee771b986b4c83b08e8743d5402df06">ilen</a> (iterable)</td></tr>
<tr class="separator:a7ee771b986b4c83b08e8743d5402df06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e89578244dcd6cc1bdb6e2399ad6f6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a03e89578244dcd6cc1bdb6e2399ad6f6">iterate</a> (func, start)</td></tr>
<tr class="separator:a03e89578244dcd6cc1bdb6e2399ad6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd15440600ce48655fcc376a543f17ab"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#afd15440600ce48655fcc376a543f17ab">with_iter</a> (context_manager)</td></tr>
<tr class="separator:afd15440600ce48655fcc376a543f17ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86598b2a838b7562a0cc40e362020a28"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a86598b2a838b7562a0cc40e362020a28">one</a> (iterable, too_short=None, too_long=None)</td></tr>
<tr class="separator:a86598b2a838b7562a0cc40e362020a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133d88653cbeea402678991e251a01ef"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a133d88653cbeea402678991e251a01ef">distinct_permutations</a> (iterable, r=None)</td></tr>
<tr class="separator:a133d88653cbeea402678991e251a01ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2449b22e6f45c7532810cf3bda514ac5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a2449b22e6f45c7532810cf3bda514ac5">intersperse</a> (e, iterable, n=1)</td></tr>
<tr class="separator:a2449b22e6f45c7532810cf3bda514ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376635631242926b94a755c4fa316b14"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a376635631242926b94a755c4fa316b14">unique_to_each</a> (iterables)</td></tr>
<tr class="separator:a376635631242926b94a755c4fa316b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c882dcbc34e6f2b1ea1c4397b4216a7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a5c882dcbc34e6f2b1ea1c4397b4216a7">windowed</a> (seq, n, fillvalue=None, step=1)</td></tr>
<tr class="separator:a5c882dcbc34e6f2b1ea1c4397b4216a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac8b3d5da622b2e8e4511742c29d7cf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a0ac8b3d5da622b2e8e4511742c29d7cf">substrings</a> (iterable)</td></tr>
<tr class="separator:a0ac8b3d5da622b2e8e4511742c29d7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782003c7b272487483afea0d79b61642"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a782003c7b272487483afea0d79b61642">substrings_indexes</a> (seq, reverse=False)</td></tr>
<tr class="separator:a782003c7b272487483afea0d79b61642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5af9ad47daaf34183f6d97f357854e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aeb5af9ad47daaf34183f6d97f357854e">spy</a> (iterable, n=1)</td></tr>
<tr class="separator:aeb5af9ad47daaf34183f6d97f357854e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fabcc02f91e91e6d29119251b3d627a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a8fabcc02f91e91e6d29119251b3d627a">interleave</a> (iterables)</td></tr>
<tr class="separator:a8fabcc02f91e91e6d29119251b3d627a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0f308dbc9021aa791615be9106fcf8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a3f0f308dbc9021aa791615be9106fcf8">interleave_longest</a> (iterables)</td></tr>
<tr class="separator:a3f0f308dbc9021aa791615be9106fcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9b9d669e72d8284ed1d55eb3d6c730"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a1f9b9d669e72d8284ed1d55eb3d6c730">collapse</a> (iterable, base_type=None, levels=None)</td></tr>
<tr class="separator:a1f9b9d669e72d8284ed1d55eb3d6c730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e7e1181b4034e1287ca835880ab196"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ad8e7e1181b4034e1287ca835880ab196">side_effect</a> (func, iterable, chunk_size=None, before=None, after=None)</td></tr>
<tr class="separator:ad8e7e1181b4034e1287ca835880ab196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef60074fb9074b75fdee79f9c5f330a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aef60074fb9074b75fdee79f9c5f330a5">sliced</a> (seq, n, strict=False)</td></tr>
<tr class="separator:aef60074fb9074b75fdee79f9c5f330a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48991f9b47c87b9b92f472299ce47f99"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a48991f9b47c87b9b92f472299ce47f99">split_at</a> (iterable, pred, maxsplit=-1, keep_separator=False)</td></tr>
<tr class="separator:a48991f9b47c87b9b92f472299ce47f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b0179aebd5eebdea8737146e6c0d8d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a53b0179aebd5eebdea8737146e6c0d8d">split_before</a> (iterable, pred, maxsplit=-1)</td></tr>
<tr class="separator:a53b0179aebd5eebdea8737146e6c0d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63f1dd5ede0301ffade1f2b8f808845"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ab63f1dd5ede0301ffade1f2b8f808845">split_after</a> (iterable, pred, maxsplit=-1)</td></tr>
<tr class="separator:ab63f1dd5ede0301ffade1f2b8f808845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26b0d8a7973334ba9a01860d90dc031"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ae26b0d8a7973334ba9a01860d90dc031">split_when</a> (iterable, pred, maxsplit=-1)</td></tr>
<tr class="separator:ae26b0d8a7973334ba9a01860d90dc031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed35ee953b8004cf902dcd7b31714f3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a5ed35ee953b8004cf902dcd7b31714f3">split_into</a> (iterable, sizes)</td></tr>
<tr class="separator:a5ed35ee953b8004cf902dcd7b31714f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d774718336d9c7ce26b793293948ad"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a47d774718336d9c7ce26b793293948ad">padded</a> (iterable, fillvalue=None, n=None, next_multiple=False)</td></tr>
<tr class="separator:a47d774718336d9c7ce26b793293948ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb278421baa6650376378b987f55c932"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#adb278421baa6650376378b987f55c932">repeat_last</a> (iterable, default=None)</td></tr>
<tr class="separator:adb278421baa6650376378b987f55c932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263804d0fc0b058f793cc590eca76edd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a263804d0fc0b058f793cc590eca76edd">distribute</a> (n, iterable)</td></tr>
<tr class="separator:a263804d0fc0b058f793cc590eca76edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0e2708002360a3ab878c2e2e56e0af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a4e0e2708002360a3ab878c2e2e56e0af">stagger</a> (iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None)</td></tr>
<tr class="separator:a4e0e2708002360a3ab878c2e2e56e0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0064ebbb74dbab5162e2411a17b9a32"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aa0064ebbb74dbab5162e2411a17b9a32">zip_equal</a> (iterables)</td></tr>
<tr class="separator:aa0064ebbb74dbab5162e2411a17b9a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b18ea084d883c1c86c2a3d018fa93f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a1b18ea084d883c1c86c2a3d018fa93f8">zip_offset</a> (iterables, offsets, longest=False, fillvalue=None)</td></tr>
<tr class="separator:a1b18ea084d883c1c86c2a3d018fa93f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1ec28544ee515336f9adb89ddd1652"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#afc1ec28544ee515336f9adb89ddd1652">sort_together</a> (iterables, key_list=(0,), key=None, reverse=False)</td></tr>
<tr class="separator:afc1ec28544ee515336f9adb89ddd1652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fdb959c73b5d1418b18a789dd0e138"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a21fdb959c73b5d1418b18a789dd0e138">unzip</a> (iterable)</td></tr>
<tr class="separator:a21fdb959c73b5d1418b18a789dd0e138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f0983503e4bb346c7d1e1fb9d929fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a18f0983503e4bb346c7d1e1fb9d929fc">divide</a> (n, iterable)</td></tr>
<tr class="separator:a18f0983503e4bb346c7d1e1fb9d929fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c94aeea028d3c3c84c578919dc9e0b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a83c94aeea028d3c3c84c578919dc9e0b">always_iterable</a> (obj, base_type=(str, bytes))</td></tr>
<tr class="separator:a83c94aeea028d3c3c84c578919dc9e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ed10a67aaf4c8c26a8b906d111a904"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a90ed10a67aaf4c8c26a8b906d111a904">adjacent</a> (predicate, iterable, distance=1)</td></tr>
<tr class="separator:a90ed10a67aaf4c8c26a8b906d111a904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3de1e0322f346b3b2c7f6cf6858603"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a9f3de1e0322f346b3b2c7f6cf6858603">groupby_transform</a> (iterable, keyfunc=None, valuefunc=None, reducefunc=None)</td></tr>
<tr class="separator:a9f3de1e0322f346b3b2c7f6cf6858603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc0fb25048f2e5d9c13afa0b425a3a6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a7bc0fb25048f2e5d9c13afa0b425a3a6">count_cycle</a> (iterable, n=None)</td></tr>
<tr class="separator:a7bc0fb25048f2e5d9c13afa0b425a3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5acb740dfb97a2580b1c9c55d287503"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ac5acb740dfb97a2580b1c9c55d287503">mark_ends</a> (iterable)</td></tr>
<tr class="separator:ac5acb740dfb97a2580b1c9c55d287503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35444700693b3657e4b259463067ce02"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a35444700693b3657e4b259463067ce02">locate</a> (iterable, pred=bool, window_size=None)</td></tr>
<tr class="separator:a35444700693b3657e4b259463067ce02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f3fff7a2235b5cbabd885f755aac46"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a20f3fff7a2235b5cbabd885f755aac46">lstrip</a> (iterable, pred)</td></tr>
<tr class="separator:a20f3fff7a2235b5cbabd885f755aac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075d2f23dd00cf2043eac197cc11039a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a075d2f23dd00cf2043eac197cc11039a">rstrip</a> (iterable, pred)</td></tr>
<tr class="separator:a075d2f23dd00cf2043eac197cc11039a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438cea9758b7e375446ebefb5991b578"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a438cea9758b7e375446ebefb5991b578">strip</a> (iterable, pred)</td></tr>
<tr class="separator:a438cea9758b7e375446ebefb5991b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4fa17fcd6b2a3bac60640b73da5434"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aea4fa17fcd6b2a3bac60640b73da5434">always_reversible</a> (iterable)</td></tr>
<tr class="separator:aea4fa17fcd6b2a3bac60640b73da5434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9ab8bac8a71702ca7bda7826edf112"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#abd9ab8bac8a71702ca7bda7826edf112">consecutive_groups</a> (iterable, ordering=lambda x:x)</td></tr>
<tr class="separator:abd9ab8bac8a71702ca7bda7826edf112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e419785b6735ee5495c21142feaf8e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a29e419785b6735ee5495c21142feaf8e">difference</a> (iterable, func=sub, initial=None)</td></tr>
<tr class="separator:a29e419785b6735ee5495c21142feaf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e0e6affdf32d1da9ed7f03bd821338"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a70e0e6affdf32d1da9ed7f03bd821338">exactly_n</a> (iterable, n, predicate=bool)</td></tr>
<tr class="separator:a70e0e6affdf32d1da9ed7f03bd821338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649ba5fe06cf09fd37714753885ba36a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a649ba5fe06cf09fd37714753885ba36a">circular_shifts</a> (iterable)</td></tr>
<tr class="separator:a649ba5fe06cf09fd37714753885ba36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58531b8a5db48cae80f6ef2af30de908"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a58531b8a5db48cae80f6ef2af30de908">make_decorator</a> (wrapping_func, result_index=0)</td></tr>
<tr class="separator:a58531b8a5db48cae80f6ef2af30de908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb75e076a0e72311a8a333fa52b1c4c8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aeb75e076a0e72311a8a333fa52b1c4c8">map_reduce</a> (iterable, keyfunc, valuefunc=None, reducefunc=None)</td></tr>
<tr class="separator:aeb75e076a0e72311a8a333fa52b1c4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e085bda06138f196912d6300bf70753"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a7e085bda06138f196912d6300bf70753">rlocate</a> (iterable, pred=bool, window_size=None)</td></tr>
<tr class="separator:a7e085bda06138f196912d6300bf70753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b819d5b236ecfc8d5ef96808e0f6ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a11b819d5b236ecfc8d5ef96808e0f6ff">replace</a> (iterable, pred, substitutes, count=None, window_size=1)</td></tr>
<tr class="separator:a11b819d5b236ecfc8d5ef96808e0f6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff68c3cfb337e2d85ce1f65b4a7ac344"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#aff68c3cfb337e2d85ce1f65b4a7ac344">partitions</a> (iterable)</td></tr>
<tr class="separator:aff68c3cfb337e2d85ce1f65b4a7ac344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfbf02981a97829237b11c914dad981"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a3dfbf02981a97829237b11c914dad981">set_partitions</a> (iterable, k=None)</td></tr>
<tr class="separator:a3dfbf02981a97829237b11c914dad981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d62053e712ee970aacc4abfcf953bd6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a1d62053e712ee970aacc4abfcf953bd6">only</a> (iterable, default=None, too_long=None)</td></tr>
<tr class="separator:a1d62053e712ee970aacc4abfcf953bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf1536200cc78d82b5aa239e89f8770"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a1bf1536200cc78d82b5aa239e89f8770">ichunked</a> (iterable, n)</td></tr>
<tr class="separator:a1bf1536200cc78d82b5aa239e89f8770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3825558c5c1fde62db5c724bcbb3de04"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a3825558c5c1fde62db5c724bcbb3de04">distinct_combinations</a> (iterable, r)</td></tr>
<tr class="separator:a3825558c5c1fde62db5c724bcbb3de04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802b5d5b5f40739f916923c05e859072"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a802b5d5b5f40739f916923c05e859072">filter_except</a> (validator, iterable, exceptions)</td></tr>
<tr class="separator:a802b5d5b5f40739f916923c05e859072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad478e8a78a411590fd37e19d6ba21861"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ad478e8a78a411590fd37e19d6ba21861">map_except</a> (function, iterable, exceptions)</td></tr>
<tr class="separator:ad478e8a78a411590fd37e19d6ba21861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91548632a1b9f5d55b2a9b6a7783fd5e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a91548632a1b9f5d55b2a9b6a7783fd5e">sample</a> (iterable, k, weights=None)</td></tr>
<tr class="separator:a91548632a1b9f5d55b2a9b6a7783fd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8484d2cdc91ee314431550f3abc9a3bc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a8484d2cdc91ee314431550f3abc9a3bc">is_sorted</a> (iterable, key=None, reverse=False)</td></tr>
<tr class="separator:a8484d2cdc91ee314431550f3abc9a3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9494bd8a93efcf205854f97da47518"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a0a9494bd8a93efcf205854f97da47518">windowed_complete</a> (iterable, n)</td></tr>
<tr class="separator:a0a9494bd8a93efcf205854f97da47518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d89d566c65810a4d60b21e990af600"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a10d89d566c65810a4d60b21e990af600">all_unique</a> (iterable, key=None)</td></tr>
<tr class="separator:a10d89d566c65810a4d60b21e990af600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a91cfb58c002e37dcd4efb0c035030"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ab5a91cfb58c002e37dcd4efb0c035030">nth_product</a> (index, args)</td></tr>
<tr class="separator:ab5a91cfb58c002e37dcd4efb0c035030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d843197e60d5372dec98fceace0ee49"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a0d843197e60d5372dec98fceace0ee49">nth_permutation</a> (iterable, r, index)</td></tr>
<tr class="separator:a0d843197e60d5372dec98fceace0ee49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de589597bd2e65a55e6981a2c779200"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a9de589597bd2e65a55e6981a2c779200">value_chain</a> (args)</td></tr>
<tr class="separator:a9de589597bd2e65a55e6981a2c779200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4728a47a8a1ed85cf0312f1b1e05ea52"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#a4728a47a8a1ed85cf0312f1b1e05ea52">product_index</a> (element, args)</td></tr>
<tr class="separator:a4728a47a8a1ed85cf0312f1b1e05ea52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee4a99a5bd0ab33a46c0d2d1574aca3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#afee4a99a5bd0ab33a46c0d2d1574aca3">combination_index</a> (element, iterable)</td></tr>
<tr class="separator:afee4a99a5bd0ab33a46c0d2d1574aca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad851a337658e88d4c7aa6b2bd1378a87"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesetuptools_1_1__vendor_1_1more__itertools_1_1more.html#ad851a337658e88d4c7aa6b2bd1378a87">permutation_index</a> (element, iterable)</td></tr>
<tr class="separator:ad851a337658e88d4c7aa6b2bd1378a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a90ed10a67aaf4c8c26a8b906d111a904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ed10a67aaf4c8c26a8b906d111a904">&#9670;&nbsp;</a></span>adjacent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.adjacent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an iterable over `(bool, item)` tuples where the `item` is
drawn from *iterable* and the `bool` indicates whether
that item satisfies the *predicate* or is adjacent to an item that does.

For example, to find whether items are adjacent to a ``3``::

    &gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6)))
    [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]

Set *distance* to change what counts as adjacent. For example, to find
whether items are two places away from a ``3``:

    &gt;&gt;&gt; list(adjacent(lambda x: x == 3, range(6), distance=2))
    [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]

This is useful for contextualizing the results of a search function.
For example, a code comparison tool might want to identify lines that
have changed, but also surrounding lines to give the viewer of the diff
context.

The predicate function will only be called once for each item in the
iterable.

See also :func:`groupby_transform`, which can be used with this function
to group ranges of items with the same `bool` value.</pre> 
</div>
</div>
<a id="a10d89d566c65810a4d60b21e990af600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d89d566c65810a4d60b21e990af600">&#9670;&nbsp;</a></span>all_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.all_unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns ``True`` if all the elements of *iterable* are unique (no two
elements are equal).

    &gt;&gt;&gt; all_unique('ABCB')
    False

If a *key* function is specified, it will be used to make comparisons.

    &gt;&gt;&gt; all_unique('ABCb')
    True
    &gt;&gt;&gt; all_unique('ABCb', str.lower)
    False

The function returns as soon as the first non-unique element is
encountered. Iterables with a mix of hashable and unhashable items can
be used, but the function will be slower for unhashable items.
</pre> 
</div>
</div>
<a id="a83c94aeea028d3c3c84c578919dc9e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c94aeea028d3c3c84c578919dc9e0b">&#9670;&nbsp;</a></span>always_iterable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.always_iterable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_type</em> = <code>(str,&#160;bytes)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If *obj* is iterable, return an iterator over its items::

    &gt;&gt;&gt; obj = (1, 2, 3)
    &gt;&gt;&gt; list(always_iterable(obj))
    [1, 2, 3]

If *obj* is not iterable, return a one-item iterable containing *obj*::

    &gt;&gt;&gt; obj = 1
    &gt;&gt;&gt; list(always_iterable(obj))
    [1]

If *obj* is ``None``, return an empty iterable:

    &gt;&gt;&gt; obj = None
    &gt;&gt;&gt; list(always_iterable(None))
    []

By default, binary and text strings are not considered iterable::

    &gt;&gt;&gt; obj = 'foo'
    &gt;&gt;&gt; list(always_iterable(obj))
    ['foo']

If *base_type* is set, objects for which ``isinstance(obj, base_type)``
returns ``True`` won't be considered iterable.

    &gt;&gt;&gt; obj = {'a': 1}
    &gt;&gt;&gt; list(always_iterable(obj))  # Iterate over the dict's keys
    ['a']
    &gt;&gt;&gt; list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit
    [{'a': 1}]

Set *base_type* to ``None`` to avoid any special handling and treat objects
Python considers iterable as iterable:

    &gt;&gt;&gt; obj = 'foo'
    &gt;&gt;&gt; list(always_iterable(obj, base_type=None))
    ['f', 'o', 'o']
</pre> 
</div>
</div>
<a id="aea4fa17fcd6b2a3bac60640b73da5434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea4fa17fcd6b2a3bac60640b73da5434">&#9670;&nbsp;</a></span>always_reversible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.always_reversible </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An extension of :func:`reversed` that supports all iterables, not
just those which implement the ``Reversible`` or ``Sequence`` protocols.

    &gt;&gt;&gt; print(*always_reversible(x for x in range(3)))
    2 1 0

If the iterable is already reversible, this function returns the
result of :func:`reversed()`. If the iterable is not reversible,
this function will cache the remaining items in the iterable and
yield them in reverse order, which may require significant storage.
</pre> 
</div>
</div>
<a id="a4e54f042cb33c767fc916b14cc8f1a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e54f042cb33c767fc916b14cc8f1a29">&#9670;&nbsp;</a></span>chunked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.chunked </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Break *iterable* into lists of length *n*:

    &gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6], 3))
    [[1, 2, 3], [4, 5, 6]]

By the default, the last yielded list will have fewer than *n* elements
if the length of *iterable* is not divisible by *n*:

    &gt;&gt;&gt; list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))
    [[1, 2, 3], [4, 5, 6], [7, 8]]

To use a fill-in value instead, see the :func:`grouper` recipe.

If the length of *iterable* is not divisible by *n* and *strict* is
``True``, then ``ValueError`` will be raised before the last
list is yielded.</pre> 
</div>
</div>
<a id="a649ba5fe06cf09fd37714753885ba36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649ba5fe06cf09fd37714753885ba36a">&#9670;&nbsp;</a></span>circular_shifts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.circular_shifts </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a list of circular shifts of *iterable*.

&gt;&gt;&gt; circular_shifts(range(4))
[(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]
</pre> 
</div>
</div>
<a id="a1f9b9d669e72d8284ed1d55eb3d6c730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9b9d669e72d8284ed1d55eb3d6c730">&#9670;&nbsp;</a></span>collapse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.collapse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_type</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>levels</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Flatten an iterable with multiple levels of nesting (e.g., a list of
lists of tuples) into non-iterable types.

    &gt;&gt;&gt; iterable = [(1, 2), ([3, 4], [[5], [6]])]
    &gt;&gt;&gt; list(collapse(iterable))
    [1, 2, 3, 4, 5, 6]

Binary and text strings are not considered iterable and
will not be collapsed.

To avoid collapsing other types, specify *base_type*:

    &gt;&gt;&gt; iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]
    &gt;&gt;&gt; list(collapse(iterable, base_type=tuple))
    ['ab', ('cd', 'ef'), 'gh', 'ij']

Specify *levels* to stop flattening after a certain level:

&gt;&gt;&gt; iterable = [('a', ['b']), ('c', ['d'])]
&gt;&gt;&gt; list(collapse(iterable))  # Fully flattened
['a', 'b', 'c', 'd']
&gt;&gt;&gt; list(collapse(iterable, levels=1))  # Only one level flattened
['a', ['b'], 'c', ['d']]</pre> 
</div>
</div>
<a id="a7704c89f2e7f53903f060c465dbae459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7704c89f2e7f53903f060c465dbae459">&#9670;&nbsp;</a></span>collate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.collate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sorted merge of the items from each of several already-sorted
*iterables*.

    &gt;&gt;&gt; list(collate('ACDZ', 'AZ', 'JKL'))
    ['A', 'A', 'C', 'D', 'J', 'K', 'L', 'Z', 'Z']

Works lazily, keeping only the next value from each iterable in memory. Use
:func:`collate` to, for example, perform a n-way mergesort of items that
don't fit in memory.

If a *key* function is specified, the iterables will be sorted according
to its result:

    &gt;&gt;&gt; key = lambda s: int(s)  # Sort by numeric value, not by string
    &gt;&gt;&gt; list(collate(['1', '10'], ['2', '11'], key=key))
    ['1', '2', '10', '11']


If the *iterables* are sorted in descending order, set *reverse* to
``True``:

    &gt;&gt;&gt; list(collate([5, 3, 1], [4, 2, 0], reverse=True))
    [5, 4, 3, 2, 1, 0]

If the elements of the passed-in iterables are out of order, you might get
unexpected results.

On Python 3.5+, this function is an alias for :func:`heapq.merge`.</pre> 
</div>
</div>
<a id="afee4a99a5bd0ab33a46c0d2d1574aca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee4a99a5bd0ab33a46c0d2d1574aca3">&#9670;&nbsp;</a></span>combination_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.combination_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(combinations(iterable, r)).index(element)``

The subsequences of *iterable* that are of length *r* can be ordered
lexicographically. :func:`combination_index` computes the index of the
first *element*, without computing the previous combinations.

    &gt;&gt;&gt; combination_index('adf', 'abcdefg')
    10

``ValueError`` will be raised if the given *element* isn't one of the
combinations of *iterable*.
</pre> 
</div>
</div>
<a id="abd9ab8bac8a71702ca7bda7826edf112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9ab8bac8a71702ca7bda7826edf112">&#9670;&nbsp;</a></span>consecutive_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.consecutive_groups </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ordering</em> = <code>lambda&#160;x:&#160;x</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield groups of consecutive items using :func:`itertools.groupby`.
The *ordering* function determines whether two items are adjacent by
returning their position.

By default, the ordering function is the identity function. This is
suitable for finding runs of numbers:

    &gt;&gt;&gt; iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]
    &gt;&gt;&gt; for group in consecutive_groups(iterable):
    ...     print(list(group))
    [1]
    [10, 11, 12]
    [20]
    [30, 31, 32, 33]
    [40]

For finding runs of adjacent letters, try using the :meth:`index` method
of a string of letters:

    &gt;&gt;&gt; from string import ascii_lowercase
    &gt;&gt;&gt; iterable = 'abcdfgilmnop'
    &gt;&gt;&gt; ordering = ascii_lowercase.index
    &gt;&gt;&gt; for group in consecutive_groups(iterable, ordering):
    ...     print(list(group))
    ['a', 'b', 'c', 'd']
    ['f', 'g']
    ['i']
    ['l', 'm', 'n', 'o', 'p']

Each group of consecutive items is an iterator that shares it source with
*iterable*. When an an output group is advanced, the previous group is
no longer available unless its elements are copied (e.g., into a ``list``).

    &gt;&gt;&gt; iterable = [1, 2, 11, 12, 21, 22]
    &gt;&gt;&gt; saved_groups = []
    &gt;&gt;&gt; for group in consecutive_groups(iterable):
    ...     saved_groups.append(list(group))  # Copy group elements
    &gt;&gt;&gt; saved_groups
    [[1, 2], [11, 12], [21, 22]]</pre> 
</div>
</div>
<a id="aba2bfd3e5689d1d8c07b735f8e3c1f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2bfd3e5689d1d8c07b735f8e3c1f3d">&#9670;&nbsp;</a></span>consumer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.consumer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decorator that automatically advances a PEP-342-style "reverse iterator"
to its first yield point so you don't have to call ``next()`` on it
manually.

    &gt;&gt;&gt; @consumer
    ... def tally():
    ...     i = 0
    ...     while True:
    ...         print('Thing number %s is %s.' % (i, (yield)))
    ...         i += 1
    ...
    &gt;&gt;&gt; t = tally()
    &gt;&gt;&gt; t.send('red')
    Thing number 0 is red.
    &gt;&gt;&gt; t.send('fish')
    Thing number 1 is fish.

Without the decorator, you would have to call ``next(t)`` before
``t.send()`` could be used.</pre> 
</div>
</div>
<a id="a7bc0fb25048f2e5d9c13afa0b425a3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc0fb25048f2e5d9c13afa0b425a3a6">&#9670;&nbsp;</a></span>count_cycle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.count_cycle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Cycle through the items from *iterable* up to *n* times, yielding
the number of completed cycles along with each item. If *n* is omitted the
process repeats indefinitely.

&gt;&gt;&gt; list(count_cycle('AB', 3))
[(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]</pre> 
</div>
</div>
<a id="a29e419785b6735ee5495c21142feaf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29e419785b6735ee5495c21142feaf8e">&#9670;&nbsp;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.difference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>sub</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">This function is the inverse of :func:`itertools.accumulate`. By default
it will compute the first difference of *iterable* using
:func:`operator.sub`:

    &gt;&gt;&gt; from itertools import accumulate
    &gt;&gt;&gt; iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10
    &gt;&gt;&gt; list(difference(iterable))
    [0, 1, 2, 3, 4]

*func* defaults to :func:`operator.sub`, but other functions can be
specified. They will be applied as follows::

    A, B, C, D, ... --&gt; A, func(B, A), func(C, B), func(D, C), ...

For example, to do progressive division:

    &gt;&gt;&gt; iterable = [1, 2, 6, 24, 120]
    &gt;&gt;&gt; func = lambda x, y: x // y
    &gt;&gt;&gt; list(difference(iterable, func))
    [1, 2, 3, 4, 5]

If the *initial* keyword is set, the first element will be skipped when
computing successive differences.

    &gt;&gt;&gt; it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)
    &gt;&gt;&gt; list(difference(it, initial=10))
    [1, 2, 3]</pre> 
</div>
</div>
<a id="a3825558c5c1fde62db5c724bcbb3de04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3825558c5c1fde62db5c724bcbb3de04">&#9670;&nbsp;</a></span>distinct_combinations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.distinct_combinations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the distinct combinations of *r* items taken from *iterable*.

    &gt;&gt;&gt; list(distinct_combinations([0, 0, 1], 2))
    [(0, 0), (0, 1)]

Equivalent to ``set(combinations(iterable))``, except duplicates are not
generated and thrown away. For larger input sequences this is much more
efficient.</pre> 
</div>
</div>
<a id="a133d88653cbeea402678991e251a01ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133d88653cbeea402678991e251a01ef">&#9670;&nbsp;</a></span>distinct_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.distinct_permutations </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield successive distinct permutations of the elements in *iterable*.

    &gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1]))
    [(0, 1, 1), (1, 0, 1), (1, 1, 0)]

Equivalent to ``set(permutations(iterable))``, except duplicates are not
generated and thrown away. For larger input sequences this is much more
efficient.

Duplicate permutations arise when there are duplicated elements in the
input iterable. The number of items returned is
`n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of
items input, and each `x_i` is the count of a distinct item in the input
sequence.

If *r* is given, only the *r*-length permutations are yielded.

    &gt;&gt;&gt; sorted(distinct_permutations([1, 0, 1], r=2))
    [(0, 1), (1, 0), (1, 1)]
    &gt;&gt;&gt; sorted(distinct_permutations(range(3), r=2))
    [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]</pre> 
</div>
</div>
<a id="a263804d0fc0b058f793cc590eca76edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263804d0fc0b058f793cc590eca76edd">&#9670;&nbsp;</a></span>distribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.distribute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Distribute the items from *iterable* among *n* smaller iterables.

    &gt;&gt;&gt; group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])
    &gt;&gt;&gt; list(group_1)
    [1, 3, 5]
    &gt;&gt;&gt; list(group_2)
    [2, 4, 6]

If the length of *iterable* is not evenly divisible by *n*, then the
length of the returned iterables will not be identical:

    &gt;&gt;&gt; children = distribute(3, [1, 2, 3, 4, 5, 6, 7])
    &gt;&gt;&gt; [list(c) for c in children]
    [[1, 4, 7], [2, 5], [3, 6]]

If the length of *iterable* is smaller than *n*, then the last returned
iterables will be empty:

    &gt;&gt;&gt; children = distribute(5, [1, 2, 3])
    &gt;&gt;&gt; [list(c) for c in children]
    [[1], [2], [3], [], []]

This function uses :func:`itertools.tee` and may require significant
storage. If you need the order items in the smaller iterables to match the
original iterable, see :func:`divide`.</pre> 
</div>
</div>
<a id="a18f0983503e4bb346c7d1e1fb9d929fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f0983503e4bb346c7d1e1fb9d929fc">&#9670;&nbsp;</a></span>divide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.divide </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Divide the elements from *iterable* into *n* parts, maintaining
order.

    &gt;&gt;&gt; group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])
    &gt;&gt;&gt; list(group_1)
    [1, 2, 3]
    &gt;&gt;&gt; list(group_2)
    [4, 5, 6]

If the length of *iterable* is not evenly divisible by *n*, then the
length of the returned iterables will not be identical:

    &gt;&gt;&gt; children = divide(3, [1, 2, 3, 4, 5, 6, 7])
    &gt;&gt;&gt; [list(c) for c in children]
    [[1, 2, 3], [4, 5], [6, 7]]

If the length of the iterable is smaller than n, then the last returned
iterables will be empty:

    &gt;&gt;&gt; children = divide(5, [1, 2, 3])
    &gt;&gt;&gt; [list(c) for c in children]
    [[1], [2], [3], [], []]

This function will exhaust the iterable before returning and may require
significant storage. If order is not important, see :func:`distribute`,
which does not first pull the iterable into memory.</pre> 
</div>
</div>
<a id="a70e0e6affdf32d1da9ed7f03bd821338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e0e6affdf32d1da9ed7f03bd821338">&#9670;&nbsp;</a></span>exactly_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.exactly_n </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>predicate</em> = <code>bool</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``True`` if exactly ``n`` items in the iterable are ``True``
according to the *predicate* function.

    &gt;&gt;&gt; exactly_n([True, True, False], 2)
    True
    &gt;&gt;&gt; exactly_n([True, True, False], 1)
    False
    &gt;&gt;&gt; exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x &lt; 3)
    True

The iterable will be advanced until ``n + 1`` truthy items are encountered,
so avoid calling it on infinite iterables.</pre> 
</div>
</div>
<a id="a802b5d5b5f40739f916923c05e859072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802b5d5b5f40739f916923c05e859072">&#9670;&nbsp;</a></span>filter_except()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.filter_except </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>validator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exceptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable* for which the *validator* function does
not raise one of the specified *exceptions*.

*validator* is called for each item in *iterable*.
It should be a function that accepts one argument and raises an exception
if that item is not valid.

&gt;&gt;&gt; iterable = ['1', '2', 'three', '4', None]
&gt;&gt;&gt; list(filter_except(int, iterable, ValueError, TypeError))
['1', '2', '4']

If an exception other than one given by *exceptions* is raised by
*validator*, it is raised like normal.
</pre> 
</div>
</div>
<a id="a74224dd623db9ad4e472e637a282d5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74224dd623db9ad4e472e637a282d5d4">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.first </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>_marker</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the first item of *iterable*, or *default* if *iterable* is
empty.

    &gt;&gt;&gt; first([0, 1, 2, 3])
    0
    &gt;&gt;&gt; first([], 'some default')
    'some default'

If *default* is not provided and there are no items in the iterable,
raise ``ValueError``.

:func:`first` is useful when you have a generator of expensive-to-retrieve
values and want any arbitrary one. It is marginally shorter than
``next(iter(iterable), default)``.</pre> 
</div>
</div>
<a id="a9f3de1e0322f346b3b2c7f6cf6858603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3de1e0322f346b3b2c7f6cf6858603">&#9670;&nbsp;</a></span>groupby_transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.groupby_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keyfunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valuefunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reducefunc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">An extension of :func:`itertools.groupby` that can apply transformations
to the grouped data.

* *keyfunc* is a function computing a key value for each item in *iterable*
* *valuefunc* is a function that transforms the individual items from
  *iterable* after grouping
* *reducefunc* is a function that transforms each group of items

&gt;&gt;&gt; iterable = 'aAAbBBcCC'
&gt;&gt;&gt; keyfunc = lambda k: k.upper()
&gt;&gt;&gt; valuefunc = lambda v: v.lower()
&gt;&gt;&gt; reducefunc = lambda g: ''.join(g)
&gt;&gt;&gt; list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))
[('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]

Each optional argument defaults to an identity function if not specified.

:func:`groupby_transform` is useful when grouping elements of an iterable
using a separate iterable as the key. To do this, :func:`zip` the iterables
and pass a *keyfunc* that extracts the first element and a *valuefunc*
that extracts the second element::

    &gt;&gt;&gt; from operator import itemgetter
    &gt;&gt;&gt; keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]
    &gt;&gt;&gt; values = 'abcdefghi'
    &gt;&gt;&gt; iterable = zip(keys, values)
    &gt;&gt;&gt; grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))
    &gt;&gt;&gt; [(k, ''.join(g)) for k, g in grouper]
    [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]

Note that the order of items in the iterable is significant.
Only adjacent items are grouped together, so if you don't want any
duplicate groups, you should sort the iterable by the key function.</pre> 
</div>
</div>
<a id="a1bf1536200cc78d82b5aa239e89f8770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf1536200cc78d82b5aa239e89f8770">&#9670;&nbsp;</a></span>ichunked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.ichunked </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Break *iterable* into sub-iterables with *n* elements each.
:func:`ichunked` is like :func:`chunked`, but it yields iterables
instead of lists.

If the sub-iterables are read in order, the elements of *iterable*
won't be stored in memory.
If they are read out of order, :func:`itertools.tee` is used to cache
elements as necessary.

&gt;&gt;&gt; from itertools import count
&gt;&gt;&gt; all_chunks = ichunked(count(), 4)
&gt;&gt;&gt; c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)
&gt;&gt;&gt; list(c_2)  # c_1's elements have been cached; c_3's haven't been
[4, 5, 6, 7]
&gt;&gt;&gt; list(c_1)
[0, 1, 2, 3]
&gt;&gt;&gt; list(c_3)
[8, 9, 10, 11]</pre> 
</div>
</div>
<a id="a7ee771b986b4c83b08e8743d5402df06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee771b986b4c83b08e8743d5402df06">&#9670;&nbsp;</a></span>ilen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.ilen </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the number of items in *iterable*.

    &gt;&gt;&gt; ilen(x for x in range(1000000) if x % 3 == 0)
    333334

This consumes the iterable, so handle with care.</pre> 
</div>
</div>
<a id="a8fabcc02f91e91e6d29119251b3d627a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fabcc02f91e91e6d29119251b3d627a">&#9670;&nbsp;</a></span>interleave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.interleave </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new iterable yielding from each iterable in turn,
until the shortest is exhausted.

    &gt;&gt;&gt; list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))
    [1, 4, 6, 2, 5, 7]

For a version that doesn't terminate after the shortest iterable is
exhausted, see :func:`interleave_longest`.</pre> 
</div>
</div>
<a id="a3f0f308dbc9021aa791615be9106fcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0f308dbc9021aa791615be9106fcf8">&#9670;&nbsp;</a></span>interleave_longest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.interleave_longest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new iterable yielding from each iterable in turn,
skipping any that are exhausted.

    &gt;&gt;&gt; list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))
    [1, 4, 6, 2, 5, 7, 3, 8]

This function produces the same output as :func:`roundrobin`, but may
perform better for some inputs (in particular when the number of iterables
is large).</pre> 
</div>
</div>
<a id="a2449b22e6f45c7532810cf3bda514ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2449b22e6f45c7532810cf3bda514ac5">&#9670;&nbsp;</a></span>intersperse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.intersperse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Intersperse filler element *e* among the items in *iterable*, leaving
*n* items between each filler element.

    &gt;&gt;&gt; list(intersperse('!', [1, 2, 3, 4, 5]))
    [1, '!', 2, '!', 3, '!', 4, '!', 5]

    &gt;&gt;&gt; list(intersperse(None, [1, 2, 3, 4, 5], n=2))
    [1, 2, None, 3, 4, None, 5]</pre> 
</div>
</div>
<a id="a8484d2cdc91ee314431550f3abc9a3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8484d2cdc91ee314431550f3abc9a3bc">&#9670;&nbsp;</a></span>is_sorted()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.is_sorted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns ``True`` if the items of iterable are in sorted order, and
``False`` otherwise. *key* and *reverse* have the same meaning that they do
in the built-in :func:`sorted` function.

&gt;&gt;&gt; is_sorted(['1', '2', '3', '4', '5'], key=int)
True
&gt;&gt;&gt; is_sorted([5, 4, 3, 1, 2], reverse=True)
False

The function returns ``False`` after encountering the first out-of-order
item. If there are no out-of-order items, the iterable is exhausted.
</pre> 
</div>
</div>
<a id="a03e89578244dcd6cc1bdb6e2399ad6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e89578244dcd6cc1bdb6e2399ad6f6">&#9670;&nbsp;</a></span>iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.iterate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return ``start``, ``func(start)``, ``func(func(start))``, ...

&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; list(islice(iterate(lambda x: 2*x, 1), 10))
[1, 2, 4, 8, 16, 32, 64, 128, 256, 512]</pre> 
</div>
</div>
<a id="a86971974b505201c4419bd8aad9d1866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86971974b505201c4419bd8aad9d1866">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.last </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>_marker</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the last item of *iterable*, or *default* if *iterable* is
empty.

    &gt;&gt;&gt; last([0, 1, 2, 3])
    3
    &gt;&gt;&gt; last([], 'some default')
    'some default'

If *default* is not provided and there are no items in the iterable,
raise ``ValueError``.
</pre> 
</div>
</div>
<a id="a35444700693b3657e4b259463067ce02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35444700693b3657e4b259463067ce02">&#9670;&nbsp;</a></span>locate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.locate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em> = <code>bool</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window_size</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the index of each item in *iterable* for which *pred* returns
``True``.

*pred* defaults to :func:`bool`, which will select truthy items:

    &gt;&gt;&gt; list(locate([0, 1, 1, 0, 1, 0, 0]))
    [1, 2, 4]

Set *pred* to a custom function to, e.g., find the indexes for a particular
item.

    &gt;&gt;&gt; list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))
    [1, 3]

If *window_size* is given, then the *pred* function will be called with
that many items. This enables searching for sub-sequences:

    &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
    &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3)
    &gt;&gt;&gt; list(locate(iterable, pred=pred, window_size=3))
    [1, 5, 9]

Use with :func:`seekable` to find indexes and then retrieve the associated
items:

    &gt;&gt;&gt; from itertools import count
    &gt;&gt;&gt; from more_itertools import seekable
    &gt;&gt;&gt; source = (3 * n + 1 if (n % 2) else n // 2 for n in count())
    &gt;&gt;&gt; it = seekable(source)
    &gt;&gt;&gt; pred = lambda x: x &gt; 100
    &gt;&gt;&gt; indexes = locate(it, pred=pred)
    &gt;&gt;&gt; i = next(indexes)
    &gt;&gt;&gt; it.seek(i)
    &gt;&gt;&gt; next(it)
    106</pre> 
</div>
</div>
<a id="a20f3fff7a2235b5cbabd885f755aac46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f3fff7a2235b5cbabd885f755aac46">&#9670;&nbsp;</a></span>lstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.lstrip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable*, but strip any from the beginning
for which *pred* returns ``True``.

For example, to remove a set of items from the start of an iterable:

    &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)
    &gt;&gt;&gt; pred = lambda x: x in {None, False, ''}
    &gt;&gt;&gt; list(lstrip(iterable, pred))
    [1, 2, None, 3, False, None]

This function is analogous to to :func:`str.lstrip`, and is essentially
an wrapper for :func:`itertools.dropwhile`.</pre> 
</div>
</div>
<a id="a58531b8a5db48cae80f6ef2af30de908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58531b8a5db48cae80f6ef2af30de908">&#9670;&nbsp;</a></span>make_decorator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.make_decorator </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wrapping_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a decorator version of *wrapping_func*, which is a function that
modifies an iterable. *result_index* is the position in that function's
signature where the iterable goes.

This lets you use itertools on the "production end," i.e. at function
definition. This can augment what the function returns without changing the
function's code.

For example, to produce a decorator version of :func:`chunked`:

    &gt;&gt;&gt; from more_itertools import chunked
    &gt;&gt;&gt; chunker = make_decorator(chunked, result_index=0)
    &gt;&gt;&gt; @chunker(3)
    ... def iter_range(n):
    ...     return iter(range(n))
    ...
    &gt;&gt;&gt; list(iter_range(9))
    [[0, 1, 2], [3, 4, 5], [6, 7, 8]]

To only allow truthy items to be returned:

    &gt;&gt;&gt; truth_serum = make_decorator(filter, result_index=1)
    &gt;&gt;&gt; @truth_serum(bool)
    ... def boolean_test():
    ...     return [0, 1, '', ' ', False, True]
    ...
    &gt;&gt;&gt; list(boolean_test())
    [1, ' ', True]

The :func:`peekable` and :func:`seekable` wrappers make for practical
decorators:

    &gt;&gt;&gt; from more_itertools import peekable
    &gt;&gt;&gt; peekable_function = make_decorator(peekable)
    &gt;&gt;&gt; @peekable_function()
    ... def str_range(*args):
    ...     return (str(x) for x in range(*args))
    ...
    &gt;&gt;&gt; it = str_range(1, 20, 2)
    &gt;&gt;&gt; next(it), next(it), next(it)
    ('1', '3', '5')
    &gt;&gt;&gt; it.peek()
    '7'
    &gt;&gt;&gt; next(it)
    '7'</pre> 
</div>
</div>
<a id="ad478e8a78a411590fd37e19d6ba21861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad478e8a78a411590fd37e19d6ba21861">&#9670;&nbsp;</a></span>map_except()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.map_except </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>exceptions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Transform each item from *iterable* with *function* and yield the
result, unless *function* raises one of the specified *exceptions*.

*function* is called to transform each item in *iterable*.
It should be a accept one argument.

&gt;&gt;&gt; iterable = ['1', '2', 'three', '4', None]
&gt;&gt;&gt; list(map_except(int, iterable, ValueError, TypeError))
[1, 2, 4]

If an exception other than one given by *exceptions* is raised by
*function*, it is raised like normal.
</pre> 
</div>
</div>
<a id="aeb75e076a0e72311a8a333fa52b1c4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb75e076a0e72311a8a333fa52b1c4c8">&#9670;&nbsp;</a></span>map_reduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.map_reduce </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keyfunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valuefunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reducefunc</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a dictionary that maps the items in *iterable* to categories
defined by *keyfunc*, transforms them with *valuefunc*, and
then summarizes them by category with *reducefunc*.

*valuefunc* defaults to the identity function if it is unspecified.
If *reducefunc* is unspecified, no summarization takes place:

    &gt;&gt;&gt; keyfunc = lambda x: x.upper()
    &gt;&gt;&gt; result = map_reduce('abbccc', keyfunc)
    &gt;&gt;&gt; sorted(result.items())
    [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]

Specifying *valuefunc* transforms the categorized items:

    &gt;&gt;&gt; keyfunc = lambda x: x.upper()
    &gt;&gt;&gt; valuefunc = lambda x: 1
    &gt;&gt;&gt; result = map_reduce('abbccc', keyfunc, valuefunc)
    &gt;&gt;&gt; sorted(result.items())
    [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]

Specifying *reducefunc* summarizes the categorized items:

    &gt;&gt;&gt; keyfunc = lambda x: x.upper()
    &gt;&gt;&gt; valuefunc = lambda x: 1
    &gt;&gt;&gt; reducefunc = sum
    &gt;&gt;&gt; result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)
    &gt;&gt;&gt; sorted(result.items())
    [('A', 1), ('B', 2), ('C', 3)]

You may want to filter the input iterable before applying the map/reduce
procedure:

    &gt;&gt;&gt; all_items = range(30)
    &gt;&gt;&gt; items = [x for x in all_items if 10 &lt;= x &lt;= 20]  # Filter
    &gt;&gt;&gt; keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1
    &gt;&gt;&gt; categories = map_reduce(items, keyfunc=keyfunc)
    &gt;&gt;&gt; sorted(categories.items())
    [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]
    &gt;&gt;&gt; summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)
    &gt;&gt;&gt; sorted(summaries.items())
    [(0, 90), (1, 75)]

Note that all items in the iterable are gathered into a list before the
summarization step, which may require significant storage.

The returned object is a :obj:`collections.defaultdict` with the
``default_factory`` set to ``None``, such that it behaves like a normal
dictionary.</pre> 
</div>
</div>
<a id="ac5acb740dfb97a2580b1c9c55d287503"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5acb740dfb97a2580b1c9c55d287503">&#9670;&nbsp;</a></span>mark_ends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.mark_ends </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield 3-tuples of the form ``(is_first, is_last, item)``.

&gt;&gt;&gt; list(mark_ends('ABC'))
[(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]

Use this when looping over an iterable to take special action on its first
and/or last items:

&gt;&gt;&gt; iterable = ['Header', 100, 200, 'Footer']
&gt;&gt;&gt; total = 0
&gt;&gt;&gt; for is_first, is_last, item in mark_ends(iterable):
...     if is_first:
...         continue  # Skip the header
...     if is_last:
...         continue  # Skip the footer
...     total += item
&gt;&gt;&gt; print(total)
300
</pre> 
</div>
</div>
<a id="a6d9ade86fac5ccaff3d9591dd143575a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d9ade86fac5ccaff3d9591dd143575a">&#9670;&nbsp;</a></span>nth_or_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.nth_or_last </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>_marker</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the nth or the last item of *iterable*,
or *default* if *iterable* is empty.

    &gt;&gt;&gt; nth_or_last([0, 1, 2, 3], 2)
    2
    &gt;&gt;&gt; nth_or_last([0, 1], 2)
    1
    &gt;&gt;&gt; nth_or_last([], 0, 'some default')
    'some default'

If *default* is not provided and there are no items in the iterable,
raise ``ValueError``.
</pre> 
</div>
</div>
<a id="a0d843197e60d5372dec98fceace0ee49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d843197e60d5372dec98fceace0ee49">&#9670;&nbsp;</a></span>nth_permutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.nth_permutation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(permutations(iterable, r))[index]```

The subsequences of *iterable* that are of length *r* where order is
important can be ordered lexicographically. :func:`nth_permutation`
computes the subsequence at sort position *index* directly, without
computing the previous subsequences.

    &gt;&gt;&gt; nth_permutation('ghijk', 2, 5)
    ('h', 'i')

``ValueError`` will be raised If *r* is negative or greater than the length
of *iterable*.
``IndexError`` will be raised if the given *index* is invalid.
</pre> 
</div>
</div>
<a id="ab5a91cfb58c002e37dcd4efb0c035030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a91cfb58c002e37dcd4efb0c035030">&#9670;&nbsp;</a></span>nth_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.nth_product </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(product(*args))[index]``.

The products of *args* can be ordered lexicographically.
:func:`nth_product` computes the product at sort position *index* without
computing the previous products.

    &gt;&gt;&gt; nth_product(8, range(2), range(2), range(2), range(2))
    (1, 0, 0, 0)

``IndexError`` will be raised if the given *index* is invalid.
</pre> 
</div>
</div>
<a id="a86598b2a838b7562a0cc40e362020a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86598b2a838b7562a0cc40e362020a28">&#9670;&nbsp;</a></span>one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.one </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>too_short</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>too_long</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the first item from *iterable*, which is expected to contain only
that item. Raise an exception if *iterable* is empty or has more than one
item.

:func:`one` is useful for ensuring that an iterable contains only one item.
For example, it can be used to retrieve the result of a database query
that is expected to return a single row.

If *iterable* is empty, ``ValueError`` will be raised. You may specify a
different exception with the *too_short* keyword:

    &gt;&gt;&gt; it = []
    &gt;&gt;&gt; one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    ValueError: too many items in iterable (expected 1)'
    &gt;&gt;&gt; too_short = IndexError('too few items')
    &gt;&gt;&gt; one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    IndexError: too few items

Similarly, if *iterable* contains more than one item, ``ValueError`` will
be raised. You may specify a different exception with the *too_long*
keyword:

    &gt;&gt;&gt; it = ['too', 'many']
    &gt;&gt;&gt; one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    ValueError: Expected exactly one item in iterable, but got 'too',
    'many', and perhaps more.
    &gt;&gt;&gt; too_long = RuntimeError
    &gt;&gt;&gt; one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    RuntimeError

Note that :func:`one` attempts to advance *iterable* twice to ensure there
is only one item. See :func:`spy` or :func:`peekable` to check iterable
contents less destructively.</pre> 
</div>
</div>
<a id="a1d62053e712ee970aacc4abfcf953bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d62053e712ee970aacc4abfcf953bd6">&#9670;&nbsp;</a></span>only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.only </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>too_long</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">If *iterable* has only one item, return it.
If it has zero items, return *default*.
If it has more than one item, raise the exception given by *too_long*,
which is ``ValueError`` by default.

&gt;&gt;&gt; only([], default='missing')
'missing'
&gt;&gt;&gt; only([1])
1
&gt;&gt;&gt; only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
...
ValueError: Expected exactly one item in iterable, but got 1, 2,
 and perhaps more.'
&gt;&gt;&gt; only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL
Traceback (most recent call last):
...
TypeError

Note that :func:`only` attempts to advance *iterable* twice to ensure there
is only one item.  See :func:`spy` or :func:`peekable` to check
iterable contents less destructively.
</pre> 
</div>
</div>
<a id="a47d774718336d9c7ce26b793293948ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d774718336d9c7ce26b793293948ad">&#9670;&nbsp;</a></span>padded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.padded </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>next_multiple</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the elements from *iterable*, followed by *fillvalue*, such that
at least *n* items are emitted.

    &gt;&gt;&gt; list(padded([1, 2, 3], '?', 5))
    [1, 2, 3, '?', '?']

If *next_multiple* is ``True``, *fillvalue* will be emitted until the
number of items emitted is a multiple of *n*::

    &gt;&gt;&gt; list(padded([1, 2, 3, 4], n=3, next_multiple=True))
    [1, 2, 3, 4, None, None]

If *n* is ``None``, *fillvalue* will be emitted indefinitely.</pre> 
</div>
</div>
<a id="aff68c3cfb337e2d85ce1f65b4a7ac344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff68c3cfb337e2d85ce1f65b4a7ac344">&#9670;&nbsp;</a></span>partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield all possible order-preserving partitions of *iterable*.

&gt;&gt;&gt; iterable = 'abc'
&gt;&gt;&gt; for part in partitions(iterable):
...     print([''.join(p) for p in part])
['abc']
['a', 'bc']
['ab', 'c']
['a', 'b', 'c']

This is unrelated to :func:`partition`.</pre> 
</div>
</div>
<a id="ad851a337658e88d4c7aa6b2bd1378a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad851a337658e88d4c7aa6b2bd1378a87">&#9670;&nbsp;</a></span>permutation_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.permutation_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(permutations(iterable, r)).index(element)```

The subsequences of *iterable* that are of length *r* where order is
important can be ordered lexicographically. :func:`permutation_index`
computes the index of the first *element* directly, without computing
the previous permutations.

    &gt;&gt;&gt; permutation_index([1, 3, 2], range(5))
    19

``ValueError`` will be raised if the given *element* isn't one of the
permutations of *iterable*.
</pre> 
</div>
</div>
<a id="a4728a47a8a1ed85cf0312f1b1e05ea52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4728a47a8a1ed85cf0312f1b1e05ea52">&#9670;&nbsp;</a></span>product_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.product_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Equivalent to ``list(product(*args)).index(element)``

The products of *args* can be ordered lexicographically.
:func:`product_index` computes the first index of *element* without
computing the previous products.

    &gt;&gt;&gt; product_index([8, 2], range(10), range(5))
    42

``ValueError`` will be raised if the given *element* isn't in the product
of *args*.
</pre> 
</div>
</div>
<a id="adb278421baa6650376378b987f55c932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb278421baa6650376378b987f55c932">&#9670;&nbsp;</a></span>repeat_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.repeat_last </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">After the *iterable* is exhausted, keep yielding its last element.

    &gt;&gt;&gt; list(islice(repeat_last(range(3)), 5))
    [0, 1, 2, 2, 2]

If the iterable is empty, yield *default* forever::

    &gt;&gt;&gt; list(islice(repeat_last(range(0), 42), 5))
    [42, 42, 42, 42, 42]</pre> 
</div>
</div>
<a id="a11b819d5b236ecfc8d5ef96808e0f6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b819d5b236ecfc8d5ef96808e0f6ff">&#9670;&nbsp;</a></span>replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.replace </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>substitutes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>count</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window_size</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable*, replacing the items for which *pred*
returns ``True`` with the items from the iterable *substitutes*.

    &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1]
    &gt;&gt;&gt; pred = lambda x: x == 0
    &gt;&gt;&gt; substitutes = (2, 3)
    &gt;&gt;&gt; list(replace(iterable, pred, substitutes))
    [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]

If *count* is given, the number of replacements will be limited:

    &gt;&gt;&gt; iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]
    &gt;&gt;&gt; pred = lambda x: x == 0
    &gt;&gt;&gt; substitutes = [None]
    &gt;&gt;&gt; list(replace(iterable, pred, substitutes, count=2))
    [1, 1, None, 1, 1, None, 1, 1, 0]

Use *window_size* to control the number of items passed as arguments to
*pred*. This allows for locating and replacing subsequences.

    &gt;&gt;&gt; iterable = [0, 1, 2, 5, 0, 1, 2, 5]
    &gt;&gt;&gt; window_size = 3
    &gt;&gt;&gt; pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred
    &gt;&gt;&gt; substitutes = [3, 4] # Splice in these items
    &gt;&gt;&gt; list(replace(iterable, pred, substitutes, window_size=window_size))
    [3, 4, 5, 3, 4, 5]</pre> 
</div>
</div>
<a id="a7e085bda06138f196912d6300bf70753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e085bda06138f196912d6300bf70753">&#9670;&nbsp;</a></span>rlocate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.rlocate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em> = <code>bool</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window_size</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the index of each item in *iterable* for which *pred* returns
``True``, starting from the right and moving left.

*pred* defaults to :func:`bool`, which will select truthy items:

    &gt;&gt;&gt; list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4
    [4, 2, 1]

Set *pred* to a custom function to, e.g., find the indexes for a particular
item:

    &gt;&gt;&gt; iterable = iter('abcb')
    &gt;&gt;&gt; pred = lambda x: x == 'b'
    &gt;&gt;&gt; list(rlocate(iterable, pred))
    [3, 1]

If *window_size* is given, then the *pred* function will be called with
that many items. This enables searching for sub-sequences:

    &gt;&gt;&gt; iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]
    &gt;&gt;&gt; pred = lambda *args: args == (1, 2, 3)
    &gt;&gt;&gt; list(rlocate(iterable, pred=pred, window_size=3))
    [9, 5, 1]

Beware, this function won't return anything for infinite iterables.
If *iterable* is reversible, ``rlocate`` will reverse it and search from
the right. Otherwise, it will search from the left and return the results
in reverse order.

See :func:`locate` to for other example applications.</pre> 
</div>
</div>
<a id="a075d2f23dd00cf2043eac197cc11039a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075d2f23dd00cf2043eac197cc11039a">&#9670;&nbsp;</a></span>rstrip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.rstrip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable*, but strip any from the end
for which *pred* returns ``True``.

For example, to remove a set of items from the end of an iterable:

    &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)
    &gt;&gt;&gt; pred = lambda x: x in {None, False, ''}
    &gt;&gt;&gt; list(rstrip(iterable, pred))
    [None, False, None, 1, 2, None, 3]

This function is analogous to :func:`str.rstrip`.</pre> 
</div>
</div>
<a id="a91548632a1b9f5d55b2a9b6a7783fd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91548632a1b9f5d55b2a9b6a7783fd5e">&#9670;&nbsp;</a></span>sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.sample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weights</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a *k*-length list of elements chosen (without replacement)
from the *iterable*. Like :func:`random.sample`, but works on iterables
of unknown length.

&gt;&gt;&gt; iterable = range(100)
&gt;&gt;&gt; sample(iterable, 5)  # doctest: +SKIP
[81, 60, 96, 16, 4]

An iterable with *weights* may also be given:

&gt;&gt;&gt; iterable = range(100)
&gt;&gt;&gt; weights = (i * i + 1 for i in range(100))
&gt;&gt;&gt; sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP
[79, 67, 74, 66, 78]

The algorithm can also be used to generate weighted random permutations.
The relative weight of each item determines the probability that it
appears late in the permutation.

&gt;&gt;&gt; data = "abcdefgh"
&gt;&gt;&gt; weights = range(1, len(data) + 1)
&gt;&gt;&gt; sample(data, k=len(data), weights=weights)  # doctest: +SKIP
['c', 'a', 'b', 'e', 'g', 'd', 'h', 'f']
</pre> 
</div>
</div>
<a id="a3dfbf02981a97829237b11c914dad981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfbf02981a97829237b11c914dad981">&#9670;&nbsp;</a></span>set_partitions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.set_partitions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the set partitions of *iterable* into *k* parts. Set partitions are
not order-preserving.

&gt;&gt;&gt; iterable = 'abc'
&gt;&gt;&gt; for part in set_partitions(iterable, 2):
...     print([''.join(p) for p in part])
['a', 'bc']
['ab', 'c']
['b', 'ac']


If *k* is not given, every set partition is generated.

&gt;&gt;&gt; iterable = 'abc'
&gt;&gt;&gt; for part in set_partitions(iterable):
...     print([''.join(p) for p in part])
['abc']
['a', 'bc']
['ab', 'c']
['b', 'ac']
['a', 'b', 'c']</pre> 
</div>
</div>
<a id="ad8e7e1181b4034e1287ca835880ab196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e7e1181b4034e1287ca835880ab196">&#9670;&nbsp;</a></span>side_effect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.side_effect </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>before</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>after</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Invoke *func* on each item in *iterable* (or on each *chunk_size* group
of items) before yielding the item.

`func` must be a function that takes a single argument. Its return value
will be discarded.

*before* and *after* are optional functions that take no arguments. They
will be executed before iteration starts and after it ends, respectively.

`side_effect` can be used for logging, updating progress bars, or anything
that is not functionally "pure."

Emitting a status message:

    &gt;&gt;&gt; from more_itertools import consume
    &gt;&gt;&gt; func = lambda item: print('Received {}'.format(item))
    &gt;&gt;&gt; consume(side_effect(func, range(2)))
    Received 0
    Received 1

Operating on chunks of items:

    &gt;&gt;&gt; pair_sums = []
    &gt;&gt;&gt; func = lambda chunk: pair_sums.append(sum(chunk))
    &gt;&gt;&gt; list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))
    [0, 1, 2, 3, 4, 5]
    &gt;&gt;&gt; list(pair_sums)
    [1, 5, 9]

Writing to a file-like object:

    &gt;&gt;&gt; from io import StringIO
    &gt;&gt;&gt; from more_itertools import consume
    &gt;&gt;&gt; f = StringIO()
    &gt;&gt;&gt; func = lambda x: print(x, file=f)
    &gt;&gt;&gt; before = lambda: print(u'HEADER', file=f)
    &gt;&gt;&gt; after = f.close
    &gt;&gt;&gt; it = [u'a', u'b', u'c']
    &gt;&gt;&gt; consume(side_effect(func, it, before=before, after=after))
    &gt;&gt;&gt; f.closed
    True</pre> 
</div>
</div>
<a id="aef60074fb9074b75fdee79f9c5f330a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef60074fb9074b75fdee79f9c5f330a5">&#9670;&nbsp;</a></span>sliced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.sliced </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield slices of length *n* from the sequence *seq*.

&gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6), 3))
[(1, 2, 3), (4, 5, 6)]

By the default, the last yielded slice will have fewer than *n* elements
if the length of *seq* is not divisible by *n*:

&gt;&gt;&gt; list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))
[(1, 2, 3), (4, 5, 6), (7, 8)]

If the length of *seq* is not divisible by *n* and *strict* is
``True``, then ``ValueError`` will be raised before the last
slice is yielded.

This function will only work for iterables that support slicing.
For non-sliceable iterables, see :func:`chunked`.</pre> 
</div>
</div>
<a id="afc1ec28544ee515336f9adb89ddd1652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1ec28544ee515336f9adb89ddd1652">&#9670;&nbsp;</a></span>sort_together()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.sort_together </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key_list</em> = <code>(0,)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the input iterables sorted together, with *key_list* as the
priority for sorting. All iterables are trimmed to the length of the
shortest one.

This can be used like the sorting function in a spreadsheet. If each
iterable represents a column of data, the key list determines which
columns are used for sorting.

By default, all iterables are sorted using the ``0``-th iterable::

    &gt;&gt;&gt; iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]
    &gt;&gt;&gt; sort_together(iterables)
    [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]

Set a different key list to sort according to another iterable.
Specifying multiple keys dictates how ties are broken::

    &gt;&gt;&gt; iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]
    &gt;&gt;&gt; sort_together(iterables, key_list=(1, 2))
    [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]

To sort by a function of the elements of the iterable, pass a *key*
function. Its arguments are the elements of the iterables corresponding to
the key list::

    &gt;&gt;&gt; names = ('a', 'b', 'c')
    &gt;&gt;&gt; lengths = (1, 2, 3)
    &gt;&gt;&gt; widths = (5, 2, 1)
    &gt;&gt;&gt; def area(length, width):
    ...     return length * width
    &gt;&gt;&gt; sort_together([names, lengths, widths], key_list=(1, 2), key=area)
    [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]

Set *reverse* to ``True`` to sort in descending order.

    &gt;&gt;&gt; sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)
    [(3, 2, 1), ('a', 'b', 'c')]</pre> 
</div>
</div>
<a id="ab63f1dd5ede0301ffade1f2b8f808845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63f1dd5ede0301ffade1f2b8f808845">&#9670;&nbsp;</a></span>split_after()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.split_after </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsplit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield lists of items from *iterable*, where each list ends with an
item where callable *pred* returns ``True``:

    &gt;&gt;&gt; list(split_after('one1two2', lambda s: s.isdigit()))
    [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]

    &gt;&gt;&gt; list(split_after(range(10), lambda n: n % 3 == 0))
    [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]

At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,
then there is no limit on the number of splits:

    &gt;&gt;&gt; list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))
    [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]</pre> 
</div>
</div>
<a id="a48991f9b47c87b9b92f472299ce47f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48991f9b47c87b9b92f472299ce47f99">&#9670;&nbsp;</a></span>split_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.split_at </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsplit</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>keep_separator</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield lists of items from *iterable*, where each list is delimited by
an item where callable *pred* returns ``True``.

    &gt;&gt;&gt; list(split_at('abcdcba', lambda x: x == 'b'))
    [['a'], ['c', 'd', 'c'], ['a']]

    &gt;&gt;&gt; list(split_at(range(10), lambda n: n % 2 == 1))
    [[0], [2], [4], [6], [8], []]

At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,
then there is no limit on the number of splits:

    &gt;&gt;&gt; list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))
    [[0], [2], [4, 5, 6, 7, 8, 9]]

By default, the delimiting items are not included in the output.
The include them, set *keep_separator* to ``True``.

    &gt;&gt;&gt; list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True))
    [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]</pre> 
</div>
</div>
<a id="a53b0179aebd5eebdea8737146e6c0d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b0179aebd5eebdea8737146e6c0d8d">&#9670;&nbsp;</a></span>split_before()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.split_before </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsplit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield lists of items from *iterable*, where each list ends just before
an item for which callable *pred* returns ``True``:

    &gt;&gt;&gt; list(split_before('OneTwo', lambda s: s.isupper()))
    [['O', 'n', 'e'], ['T', 'w', 'o']]

    &gt;&gt;&gt; list(split_before(range(10), lambda n: n % 3 == 0))
    [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]

At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,
then there is no limit on the number of splits:

    &gt;&gt;&gt; list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))
    [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]
</pre> 
</div>
</div>
<a id="a5ed35ee953b8004cf902dcd7b31714f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed35ee953b8004cf902dcd7b31714f3">&#9670;&nbsp;</a></span>split_into()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.split_into </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield a list of sequential items from *iterable* of length 'n' for each
integer 'n' in *sizes*.

    &gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [1,2,3]))
    [[1], [2, 3], [4, 5, 6]]

If the sum of *sizes* is smaller than the length of *iterable*, then the
remaining items of *iterable* will not be returned.

    &gt;&gt;&gt; list(split_into([1,2,3,4,5,6], [2,3]))
    [[1, 2], [3, 4, 5]]

If the sum of *sizes* is larger than the length of *iterable*, fewer items
will be returned in the iteration that overruns *iterable* and further
lists will be empty:

    &gt;&gt;&gt; list(split_into([1,2,3,4], [1,2,3,4]))
    [[1], [2, 3], [4], []]

When a ``None`` object is encountered in *sizes*, the returned list will
contain items up to the end of *iterable* the same way that itertools.slice
does:

    &gt;&gt;&gt; list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))
    [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]

:func:`split_into` can be useful for grouping a series of items where the
sizes of the groups are not uniform. An example would be where in a row
from a table, multiple columns represent elements of the same feature
(e.g. a point represented by x,y,z) but, the format is not the same for
all columns.
</pre> 
</div>
</div>
<a id="ae26b0d8a7973334ba9a01860d90dc031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26b0d8a7973334ba9a01860d90dc031">&#9670;&nbsp;</a></span>split_when()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.split_when </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxsplit</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Split *iterable* into pieces based on the output of *pred*.
*pred* should be a function that takes successive pairs of items and
returns ``True`` if the iterable should be split in between them.

For example, to find runs of increasing numbers, split the iterable when
element ``i`` is larger than element ``i + 1``:

    &gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x &gt; y))
    [[1, 2, 3, 3], [2, 5], [2, 4], [2]]

At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,
then there is no limit on the number of splits:

    &gt;&gt;&gt; list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],
    ...                 lambda x, y: x &gt; y, maxsplit=2))
    [[1, 2, 3, 3], [2, 5], [2, 4, 2]]</pre> 
</div>
</div>
<a id="aeb5af9ad47daaf34183f6d97f357854e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5af9ad47daaf34183f6d97f357854e">&#9670;&nbsp;</a></span>spy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.spy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a 2-tuple with a list containing the first *n* elements of
*iterable*, and an iterator with the same items as *iterable*.
This allows you to "look ahead" at the items in the iterable without
advancing it.

There is one item in the list by default:

    &gt;&gt;&gt; iterable = 'abcdefg'
    &gt;&gt;&gt; head, iterable = spy(iterable)
    &gt;&gt;&gt; head
    ['a']
    &gt;&gt;&gt; list(iterable)
    ['a', 'b', 'c', 'd', 'e', 'f', 'g']

You may use unpacking to retrieve items instead of lists:

    &gt;&gt;&gt; (head,), iterable = spy('abcdefg')
    &gt;&gt;&gt; head
    'a'
    &gt;&gt;&gt; (first, second), iterable = spy('abcdefg', 2)
    &gt;&gt;&gt; first
    'a'
    &gt;&gt;&gt; second
    'b'

The number of items requested can be larger than the number of items in
the iterable:

    &gt;&gt;&gt; iterable = [1, 2, 3, 4, 5]
    &gt;&gt;&gt; head, iterable = spy(iterable, 10)
    &gt;&gt;&gt; head
    [1, 2, 3, 4, 5]
    &gt;&gt;&gt; list(iterable)
    [1, 2, 3, 4, 5]</pre> 
</div>
</div>
<a id="a4e0e2708002360a3ab878c2e2e56e0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0e2708002360a3ab878c2e2e56e0af">&#9670;&nbsp;</a></span>stagger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.stagger </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em> = <code>(-1,&#160;0,&#160;1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>longest</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield tuples whose elements are offset from *iterable*.
The amount by which the `i`-th item in each tuple is offset is given by
the `i`-th item in *offsets*.

    &gt;&gt;&gt; list(stagger([0, 1, 2, 3]))
    [(None, 0, 1), (0, 1, 2), (1, 2, 3)]
    &gt;&gt;&gt; list(stagger(range(8), offsets=(0, 2, 4)))
    [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]

By default, the sequence will end when the final element of a tuple is the
last item in the iterable. To continue until the first element of a tuple
is the last item in the iterable, set *longest* to ``True``::

    &gt;&gt;&gt; list(stagger([0, 1, 2, 3], longest=True))
    [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]

By default, ``None`` will be used to replace offsets beyond the end of the
sequence. Specify *fillvalue* to use some other value.</pre> 
</div>
</div>
<a id="a438cea9758b7e375446ebefb5991b578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a438cea9758b7e375446ebefb5991b578">&#9670;&nbsp;</a></span>strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.strip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield the items from *iterable*, but strip any from the
beginning and end for which *pred* returns ``True``.

For example, to remove a set of items from both ends of an iterable:

    &gt;&gt;&gt; iterable = (None, False, None, 1, 2, None, 3, False, None)
    &gt;&gt;&gt; pred = lambda x: x in {None, False, ''}
    &gt;&gt;&gt; list(strip(iterable, pred))
    [1, 2, None, 3]

This function is analogous to :func:`str.strip`.</pre> 
</div>
</div>
<a id="a0ac8b3d5da622b2e8e4511742c29d7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac8b3d5da622b2e8e4511742c29d7cf">&#9670;&nbsp;</a></span>substrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.substrings </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield all of the substrings of *iterable*.

    &gt;&gt;&gt; [''.join(s) for s in substrings('more')]
    ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']

Note that non-string iterables can also be subdivided.

    &gt;&gt;&gt; list(substrings([0, 1, 2]))
    [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]</pre> 
</div>
</div>
<a id="a782003c7b272487483afea0d79b61642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782003c7b272487483afea0d79b61642">&#9670;&nbsp;</a></span>substrings_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.substrings_indexes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield all substrings and their positions in *seq*

The items yielded will be a tuple of the form ``(substr, i, j)``, where
``substr == seq[i:j]``.

This function only works for iterables that support slicing, such as
``str`` objects.

&gt;&gt;&gt; for item in substrings_indexes('more'):
...    print(item)
('m', 0, 1)
('o', 1, 2)
('r', 2, 3)
('e', 3, 4)
('mo', 0, 2)
('or', 1, 3)
('re', 2, 4)
('mor', 0, 3)
('ore', 1, 4)
('more', 0, 4)

Set *reverse* to ``True`` to yield the same items in the opposite order.</pre> 
</div>
</div>
<a id="a376635631242926b94a755c4fa316b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a376635631242926b94a755c4fa316b14">&#9670;&nbsp;</a></span>unique_to_each()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.unique_to_each </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the elements from each of the input iterables that aren't in the
other input iterables.

For example, suppose you have a set of packages, each with a set of
dependencies::

    {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}

If you remove one package, which dependencies can also be removed?

If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not
associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for
``pkg_2``, and ``D`` is only needed for ``pkg_3``::

    &gt;&gt;&gt; unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})
    [['A'], ['C'], ['D']]

If there are duplicates in one input iterable that aren't in the others
they will be duplicated in the output. Input order is preserved::

    &gt;&gt;&gt; unique_to_each("mississippi", "missouri")
    [['p', 'p'], ['o', 'u', 'r']]

It is assumed that the elements of each iterable are hashable.</pre> 
</div>
</div>
<a id="a21fdb959c73b5d1418b18a789dd0e138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fdb959c73b5d1418b18a789dd0e138">&#9670;&nbsp;</a></span>unzip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.unzip </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The inverse of :func:`zip`, this function disaggregates the elements
of the zipped *iterable*.

The ``i``-th iterable contains the ``i``-th element from each element
of the zipped iterable. The first element is used to to determine the
length of the remaining elements.

    &gt;&gt;&gt; iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]
    &gt;&gt;&gt; letters, numbers = unzip(iterable)
    &gt;&gt;&gt; list(letters)
    ['a', 'b', 'c', 'd']
    &gt;&gt;&gt; list(numbers)
    [1, 2, 3, 4]

This is similar to using ``zip(*iterable)``, but it avoids reading
*iterable* into memory. Note, however, that this function uses
:func:`itertools.tee` and thus may require significant storage.</pre> 
</div>
</div>
<a id="a9de589597bd2e65a55e6981a2c779200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de589597bd2e65a55e6981a2c779200">&#9670;&nbsp;</a></span>value_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.value_chain </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield all arguments passed to the function in the same order in which
they were passed. If an argument itself is iterable then iterate over its
values.

    &gt;&gt;&gt; list(value_chain(1, 2, 3, [4, 5, 6]))
    [1, 2, 3, 4, 5, 6]

Binary and text strings are not considered iterable and are emitted
as-is:

    &gt;&gt;&gt; list(value_chain('12', '34', ['56', '78']))
    ['12', '34', '56', '78']


Multiple levels of nesting are not flattened.</pre> 
</div>
</div>
<a id="a5c882dcbc34e6f2b1ea1c4397b4216a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c882dcbc34e6f2b1ea1c4397b4216a7">&#9670;&nbsp;</a></span>windowed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.windowed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>step</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sliding window of width *n* over the given iterable.

    &gt;&gt;&gt; all_windows = windowed([1, 2, 3, 4, 5], 3)
    &gt;&gt;&gt; list(all_windows)
    [(1, 2, 3), (2, 3, 4), (3, 4, 5)]

When the window is larger than the iterable, *fillvalue* is used in place
of missing values:

    &gt;&gt;&gt; list(windowed([1, 2, 3], 4))
    [(1, 2, 3, None)]

Each window will advance in increments of *step*:

    &gt;&gt;&gt; list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2))
    [(1, 2, 3), (3, 4, 5), (5, 6, '!')]

To slide into the iterable's items, use :func:`chain` to add filler items
to the left:

    &gt;&gt;&gt; iterable = [1, 2, 3, 4]
    &gt;&gt;&gt; n = 3
    &gt;&gt;&gt; padding = [None] * (n - 1)
    &gt;&gt;&gt; list(windowed(chain(padding, iterable), 3))
    [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]
</pre> 
</div>
</div>
<a id="a0a9494bd8a93efcf205854f97da47518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9494bd8a93efcf205854f97da47518">&#9670;&nbsp;</a></span>windowed_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.windowed_complete </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Yield ``(beginning, middle, end)`` tuples, where:

* Each ``middle`` has *n* items from *iterable*
* Each ``beginning`` has the items before the ones in ``middle``
* Each ``end`` has the items after the ones in ``middle``

&gt;&gt;&gt; iterable = range(7)
&gt;&gt;&gt; n = 3
&gt;&gt;&gt; for beginning, middle, end in windowed_complete(iterable, n):
...     print(beginning, middle, end)
() (0, 1, 2) (3, 4, 5, 6)
(0,) (1, 2, 3) (4, 5, 6)
(0, 1) (2, 3, 4) (5, 6)
(0, 1, 2) (3, 4, 5) (6,)
(0, 1, 2, 3) (4, 5, 6) ()

Note that *n* must be at least 0 and most equal to the length of
*iterable*.

This function will exhaust the iterable and may require significant
storage.
</pre> 
</div>
</div>
<a id="afd15440600ce48655fcc376a543f17ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd15440600ce48655fcc376a543f17ab">&#9670;&nbsp;</a></span>with_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.with_iter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context_manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Wrap an iterable in a ``with`` statement, so it closes once exhausted.

For example, this will close the file when the iterator is exhausted::

    upper_lines = (line.upper() for line in with_iter(open('foo')))

Any context manager which returns an iterable is a candidate for
``with_iter``.</pre> 
</div>
</div>
<a id="aa0064ebbb74dbab5162e2411a17b9a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0064ebbb74dbab5162e2411a17b9a32">&#9670;&nbsp;</a></span>zip_equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.zip_equal </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">``zip`` the input *iterables* together, but raise
``UnequalIterablesError`` if they aren't all the same length.

    &gt;&gt;&gt; it_1 = range(3)
    &gt;&gt;&gt; it_2 = iter('abc')
    &gt;&gt;&gt; list(zip_equal(it_1, it_2))
    [(0, 'a'), (1, 'b'), (2, 'c')]

    &gt;&gt;&gt; it_1 = range(3)
    &gt;&gt;&gt; it_2 = iter('abcd')
    &gt;&gt;&gt; list(zip_equal(it_1, it_2)) # doctest: +IGNORE_EXCEPTION_DETAIL
    Traceback (most recent call last):
    ...
    more_itertools.more.UnequalIterablesError: Iterables have different
    lengths</pre> 
</div>
</div>
<a id="a1b18ea084d883c1c86c2a3d018fa93f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b18ea084d883c1c86c2a3d018fa93f8">&#9670;&nbsp;</a></span>zip_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def setuptools._vendor.more_itertools.more.zip_offset </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>iterables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>longest</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fillvalue</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">``zip`` the input *iterables* together, but offset the `i`-th iterable
by the `i`-th item in *offsets*.

    &gt;&gt;&gt; list(zip_offset('0123', 'abcdef', offsets=(0, 1)))
    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]

This can be used as a lightweight alternative to SciPy or pandas to analyze
data sets in which some series have a lead or lag relationship.

By default, the sequence will end when the shortest iterable is exhausted.
To continue until the longest iterable is exhausted, set *longest* to
``True``.

    &gt;&gt;&gt; list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True))
    [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]

By default, ``None`` will be used to replace offsets beyond the end of the
sequence. Specify *fillvalue* to use some other value.</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
