<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.approximation.traveling_salesman Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation.html">approximation</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1traveling__salesman.html">traveling_salesman</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.approximation.traveling_salesman Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0fdde926c7d59c76a087e4b4ee5502e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1traveling__salesman.html#a0fdde926c7d59c76a087e4b4ee5502e1">swap_two_nodes</a> (soln, seed)</td></tr>
<tr class="separator:a0fdde926c7d59c76a087e4b4ee5502e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9505dd8c1940e16144026f1c44fbdb0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1traveling__salesman.html#af9505dd8c1940e16144026f1c44fbdb0">move_one_node</a> (soln, seed)</td></tr>
<tr class="separator:af9505dd8c1940e16144026f1c44fbdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8867e0807759613f7483fd75dbc8f05"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1traveling__salesman.html#af8867e0807759613f7483fd75dbc8f05">christofides</a> (G, weight=&quot;weight&quot;, tree=None)</td></tr>
<tr class="separator:af8867e0807759613f7483fd75dbc8f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c82677b10d52786a34aa0ea42f8b1d2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1traveling__salesman.html#a2c82677b10d52786a34aa0ea42f8b1d2">traveling_salesman_problem</a> (G, weight=&quot;weight&quot;, nodes=None, cycle=True, method=None)</td></tr>
<tr class="separator:a2c82677b10d52786a34aa0ea42f8b1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf9c28bf0139df1980bb84bc58a90d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1traveling__salesman.html#a4cf9c28bf0139df1980bb84bc58a90d7">greedy_tsp</a> (G, weight=&quot;weight&quot;, source=None)</td></tr>
<tr class="separator:a4cf9c28bf0139df1980bb84bc58a90d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaf80a5dab2307652409b12bf33ca72"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1traveling__salesman.html#afbaf80a5dab2307652409b12bf33ca72">simulated_annealing_tsp</a> (G, init_cycle, weight=&quot;weight&quot;, source=None, temp=100, move=&quot;1-1&quot;, max_iterations=10, N_inner=100, alpha=0.01, seed=None)</td></tr>
<tr class="separator:afbaf80a5dab2307652409b12bf33ca72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada31f6fee5230024ff9b5f1c27118aa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1approximation_1_1traveling__salesman.html#aada31f6fee5230024ff9b5f1c27118aa">threshold_accepting_tsp</a> (G, init_cycle, weight=&quot;weight&quot;, source=None, threshold=1, move=&quot;1-1&quot;, max_iterations=10, N_inner=100, alpha=0.1, seed=None)</td></tr>
<tr class="separator:aada31f6fee5230024ff9b5f1c27118aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">=================================
Travelling Salesman Problem (TSP)
=================================

Implementation of approximate algorithms
for solving and approximating the TSP problem.

Categories of algorithms which are implemented:

- Christofides (provides a 3/2-approximation of TSP)
- Greedy
- Simulated Annealing (SA)
- Threshold Accepting (TA)

The Travelling Salesman Problem tries to find, given the weight
(distance) between all points where a salesman has to visit, the
route so that:

- The total distance (cost) which the salesman travels is minimized.
- The salesman returns to the starting point.
- Note that for a complete graph, the salesman visits each point once.

The function `travelling_salesman_problem` allows for incomplete
graphs by finding all-pairs shortest paths, effectively converting
the problem to a complete graph problem. It calls one of the
approximate methods on that problem and then converts the result
back to the original graph using the previously found shortest paths.

TSP is an NP-hard problem in combinatorial optimization,
important in operations research and theoretical computer science.

http://en.wikipedia.org/wiki/Travelling_salesman_problem
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="af8867e0807759613f7483fd75dbc8f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8867e0807759613f7483fd75dbc8f05">&#9670;&nbsp;</a></span>christofides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.traveling_salesman.christofides </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tree</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Approximate a solution of the traveling salesman problem

Compute a 3/2-approximation of the traveling salesman problem
in a complete undirected graph using Christofides [1]_ algorithm.

Parameters
----------
G : Graph
    `G` should be a complete weighted undirected graph.
    The distance between all pairs of nodes should be included.

weight : string, optional (default="weight")
    Edge data key corresponding to the edge weight.
    If any edge does not have this attribute the weight is set to 1.

tree : NetworkX graph or None (default: None)
    A minimum spanning tree of G. Or, if None, the minimum spanning
    tree is computed using :func:`networkx.minimum_spanning_tree`

Returns
-------
list
    List of nodes in `G` along a cycle with a 3/2-approximation of
    the minimal Hamiltonian cycle.

References
----------
.. [1] Christofides, Nicos. "Worst-case analysis of a new heuristic for
   the travelling salesman problem." No. RR-388. Carnegie-Mellon Univ
   Pittsburgh Pa Management Sciences Research Group, 1976.
</pre> 
</div>
</div>
<a id="a4cf9c28bf0139df1980bb84bc58a90d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cf9c28bf0139df1980bb84bc58a90d7">&#9670;&nbsp;</a></span>greedy_tsp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.traveling_salesman.greedy_tsp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a low cost cycle starting at `source` and its cost.

This approximates a solution to the traveling salesman problem.
It finds a cycle of all the nodes that a salesman can visit in order
to visit many nodes while minimizing total distance.
It uses a simple greedy algorithm.
In essence, this function returns a large cycle given a source point
for which the total cost of the cycle is minimized.

Parameters
----------
G : Graph
    The Graph should be a complete weighted undirected graph.
    The distance between all pairs of nodes should be included.

weight : string, optional (default="weight")
    Edge data key corresponding to the edge weight.
    If any edge does not have this attribute the weight is set to 1.

source : node, optional (default: first node in list(G))
    Starting node.  If None, defaults to ``next(iter(G))``

Returns
-------
cycle : list of nodes
    Returns the cycle (list of nodes) that a salesman
    can follow to minimize total weight of the trip.

Raises
------
NetworkXError
    If `G` is not complete, the algorithm raises an exception.

Examples
--------
&gt;&gt;&gt; from networkx.algorithms import approximation as approx
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_weighted_edges_from({
...     ("A", "B", 3), ("A", "C", 17), ("A", "D", 14), ("B", "A", 3),
...     ("B", "C", 12), ("B", "D", 16), ("C", "A", 13),("C", "B", 12),
...     ("C", "D", 4), ("D", "A", 14), ("D", "B", 15), ("D", "C", 2)
... })
&gt;&gt;&gt; cycle = approx.greedy_tsp(G, source="D")
&gt;&gt;&gt; cost = sum(G[n][nbr]["weight"] for n, nbr in nx.utils.pairwise(cycle))
&gt;&gt;&gt; cycle
['D', 'C', 'B', 'A', 'D']
&gt;&gt;&gt; cost
31

Notes
-----
This implementation of a greedy algorithm is based on the following:

- The algorithm adds a node to the solution at every iteration.
- The algorithm selects a node not already in the cycle whose connection
  to the previous node adds the least cost to the cycle.

A greedy algorithm does not always give the best solution.
However, it can construct a first feasible solution which can
be passed as a parameter to an iterative improvement algorithm such
as Simulated Annealing, or Threshold Accepting.

Time complexity: It has a running time $O(|V|^2)$
</pre> 
</div>
</div>
<a id="af9505dd8c1940e16144026f1c44fbdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9505dd8c1940e16144026f1c44fbdb0">&#9670;&nbsp;</a></span>move_one_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.traveling_salesman.move_one_node </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Move one node to another position to give a neighbor solution.

The node to move and the position to move to are chosen randomly.
The first and last nodes are left untouched as soln must be a cycle
starting at that node.

Parameters
----------
soln : list of nodes
    Current cycle of nodes

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
list
    The solution after move is applied. (A neighbor solution.)

Notes
-----
    This function assumes that the incoming list `soln` is a cycle
    (that the first and last element are the same) and also that
    we don't want any move to change the first node in the list
    (and thus not the last node either).

    The input list is changed as well as returned. Make a copy if needed.

See Also
--------
    swap_two_nodes
</pre> 
</div>
</div>
<a id="afbaf80a5dab2307652409b12bf33ca72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbaf80a5dab2307652409b12bf33ca72">&#9670;&nbsp;</a></span>simulated_annealing_tsp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.traveling_salesman.simulated_annealing_tsp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>init_cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>temp</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>move</em> = <code>&quot;1-1&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N_inner</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.01</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an approximate solution to the traveling salesman problem.

This function uses simulated annealing to approximate the minimal cost
cycle through the nodes. Starting from a suboptimal solution, simulated
annealing perturbs that solution, occasionally accepting changes that make
the solution worse to escape from a locally optimal solution. The chance
of accepting such changes decreases over the iterations to encourage
an optimal result.  In summary, the function returns a cycle starting
at `source` for which the total cost is minimized. It also returns the cost.

The chance of accepting a proposed change is related to a parameter called
the temperature (annealing has a physical analogue of steel hardening
as it cools). As the temperature is reduced, the chance of moves that
increase cost goes down.

Parameters
----------
G : Graph
    `G` should be a complete weighted undirected graph.
    The distance between all pairs of nodes should be included.

init_cycle : list of all nodes or "greedy"
    The initial solution (a cycle through all nodes returning to the start).
    This argument has no default to make you think about it.
    If "greedy", use `greedy_tsp(G, weight)`.
    Other common starting cycles are `list(G) + [next(iter(G))]` or the final
    result of `simulated_annealing_tsp` when doing `threshold_accepting_tsp`.

weight : string, optional (default="weight")
    Edge data key corresponding to the edge weight.
    If any edge does not have this attribute the weight is set to 1.

source : node, optional (default: first node in list(G))
    Starting node.  If None, defaults to ``next(iter(G))``

temp : int, optional (default=100)
    The algorithm's temperature parameter. It represents the initial
    value of temperature

move : "1-1" or "1-0" or function, optional (default="1-1")
    Indicator of what move to use when finding new trial solutions.
    Strings indicate two special built-in moves:

    - "1-1": 1-1 exchange which transposes the position
      of two elements of the current solution.
      The function called is :func:`swap_two_nodes`.
      For example if we apply 1-1 exchange in the solution
      ``A = [3, 2, 1, 4, 3]``
      we can get the following by the transposition of 1 and 4 elements:
      ``A' = [3, 2, 4, 1, 3]``
    - "1-0": 1-0 exchange which moves an node in the solution
      to a new position.
      The function called is :func:`move_one_node`.
      For example if we apply 1-0 exchange in the solution
      ``A = [3, 2, 1, 4, 3]``
      we can transfer the fourth element to the second position:
      ``A' = [3, 4, 2, 1, 3]``

    You may provide your own functions to enact a move from
    one solution to a neighbor solution. The function must take
    the solution as input along with a `seed` input to control
    random number generation (see the `seed` input here).
    Your function should maintain the solution as a cycle with
    equal first and last node and all others appearing once.
    Your function should return the new solution.

max_iterations : int, optional (default=10)
    Declared done when this number of consecutive iterations of
    the outer loop occurs without any change in the best cost solution.

N_inner : int, optional (default=100)
    The number of iterations of the inner loop.

alpha : float between (0, 1), optional (default=0.01)
    Percentage of temperature decrease in each iteration
    of outer loop

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
cycle : list of nodes
    Returns the cycle (list of nodes) that a salesman
    can follow to minimize total weight of the trip.

Raises
------
NetworkXError
    If `G` is not complete the algorithm raises an exception.

Examples
--------
&gt;&gt;&gt; from networkx.algorithms import approximation as approx
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_weighted_edges_from({
...     ("A", "B", 3), ("A", "C", 17), ("A", "D", 14), ("B", "A", 3),
...     ("B", "C", 12), ("B", "D", 16), ("C", "A", 13),("C", "B", 12),
...     ("C", "D", 4), ("D", "A", 14), ("D", "B", 15), ("D", "C", 2)
... })
&gt;&gt;&gt; cycle = approx.simulated_annealing_tsp(G, "greedy", source="D")
&gt;&gt;&gt; cost = sum(G[n][nbr]["weight"] for n, nbr in nx.utils.pairwise(cycle))
&gt;&gt;&gt; cycle
['D', 'C', 'B', 'A', 'D']
&gt;&gt;&gt; cost
31
&gt;&gt;&gt; incycle = ["D", "B", "A", "C", "D"]
&gt;&gt;&gt; cycle = approx.simulated_annealing_tsp(G, incycle, source="D")
&gt;&gt;&gt; cost = sum(G[n][nbr]["weight"] for n, nbr in nx.utils.pairwise(cycle))
&gt;&gt;&gt; cycle
['D', 'C', 'B', 'A', 'D']
&gt;&gt;&gt; cost
31

Notes
-----
Simulated Annealing is a metaheuristic local search algorithm.
The main characteristic of this algorithm is that it accepts
even solutions which lead to the increase of the cost in order
to escape from low quality local optimal solutions.

This algorithm needs an initial solution. If not provided, it is
constructed by a simple greedy algorithm. At every iteration, the
algorithm selects thoughtfully a neighbor solution.
Consider $c(x)$ cost of current solution and $c(x')$ cost of a
neighbor solution.
If $c(x') - c(x) &lt;= 0$ then the neighbor solution becomes the current
solution for the next iteration. Otherwise, the algorithm accepts
the neighbor solution with probability $p = exp - ([c(x') - c(x)] / temp)$.
Otherwise the current solution is retained.

`temp` is a parameter of the algorithm and represents temperature.

Time complexity:
For $N_i$ iterations of the inner loop and $N_o$ iterations of the
outer loop, this algorithm has running time $O(N_i * N_o * |V|)$.

For more information and how the algorithm is inspired see:
http://en.wikipedia.org/wiki/Simulated_annealing
</pre> 
</div>
</div>
<a id="a0fdde926c7d59c76a087e4b4ee5502e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fdde926c7d59c76a087e4b4ee5502e1">&#9670;&nbsp;</a></span>swap_two_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.traveling_salesman.swap_two_nodes </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>soln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Swap two nodes in `soln` to give a neighbor solution.

Parameters
----------
soln : list of nodes
    Current cycle of nodes

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
list
    The solution after move is applied. (A neighbor solution.)

Notes
-----
    This function assumes that the incoming list `soln` is a cycle
    (that the first and last element are the same) and also that
    we don't want any move to change the first node in the list
    (and thus not the last node either).

    The input list is changed as well as returned. Make a copy if needed.

See Also
--------
    move_one_node
</pre> 
</div>
</div>
<a id="aada31f6fee5230024ff9b5f1c27118aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada31f6fee5230024ff9b5f1c27118aa">&#9670;&nbsp;</a></span>threshold_accepting_tsp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.traveling_salesman.threshold_accepting_tsp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>init_cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>source</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>move</em> = <code>&quot;1-1&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_iterations</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N_inner</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>seed</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns an approximate solution to the traveling salesman problem.

This function uses threshold accepting methods to approximate the minimal cost
cycle through the nodes. Starting from a suboptimal solution, threshold
accepting methods perturb that solution, accepting any changes that make
the solution no worse than increasing by a threshold amount. Improvements
in cost are accepted, but so are changes leading to small increases in cost.
This allows the solution to leave suboptimal local minima in solution space.
The threshold is decreased slowly as iterations proceed helping to ensure
an optimum. In summary, the function returns a cycle starting at `source`
for which the total cost is minimized.

Parameters
----------
G : Graph
    `G` should be a complete weighted undirected graph.
    The distance between all pairs of nodes should be included.

init_cycle : list or "greedy"
    The initial solution (a cycle through all nodes returning to the start).
    This argument has no default to make you think about it.
    If "greedy", use `greedy_tsp(G, weight)`.
    Other common starting cycles are `list(G) + [next(iter(G))]` or the final
    result of `simulated_annealing_tsp` when doing `threshold_accepting_tsp`.

weight : string, optional (default="weight")
    Edge data key corresponding to the edge weight.
    If any edge does not have this attribute the weight is set to 1.

source : node, optional (default: first node in list(G))
    Starting node.  If None, defaults to ``next(iter(G))``

threshold : int, optional (default=1)
    The algorithm's threshold parameter. It represents the initial
    threshold's value

move : "1-1" or "1-0" or function, optional (default="1-1")
    Indicator of what move to use when finding new trial solutions.
    Strings indicate two special built-in moves:

    - "1-1": 1-1 exchange which transposes the position
      of two elements of the current solution.
      The function called is :func:`swap_two_nodes`.
      For example if we apply 1-1 exchange in the solution
      ``A = [3, 2, 1, 4, 3]``
      we can get the following by the transposition of 1 and 4 elements:
      ``A' = [3, 2, 4, 1, 3]``
    - "1-0": 1-0 exchange which moves an node in the solution
      to a new position.
      The function called is :func:`move_one_node`.
      For example if we apply 1-0 exchange in the solution
      ``A = [3, 2, 1, 4, 3]``
      we can transfer the fourth element to the second position:
      ``A' = [3, 4, 2, 1, 3]``

    You may provide your own functions to enact a move from
    one solution to a neighbor solution. The function must take
    the solution as input along with a `seed` input to control
    random number generation (see the `seed` input here).
    Your function should maintain the solution as a cycle with
    equal first and last node and all others appearing once.
    Your function should return the new solution.

max_iterations : int, optional (default=10)
    Declared done when this number of consecutive iterations of
    the outer loop occurs without any change in the best cost solution.

N_inner : int, optional (default=100)
    The number of iterations of the inner loop.

alpha : float between (0, 1), optional (default=0.1)
    Percentage of threshold decrease when there is at
    least one acceptance of a neighbor solution.
    If no inner loop moves are accepted the threshold remains unchanged.

seed : integer, random_state, or None (default)
    Indicator of random number generation state.
    See :ref:`Randomness&lt;randomness&gt;`.

Returns
-------
cycle : list of nodes
    Returns the cycle (list of nodes) that a salesman
    can follow to minimize total weight of the trip.

Raises
------
NetworkXError
    If `G` is not complete the algorithm raises an exception.

Examples
--------
&gt;&gt;&gt; from networkx.algorithms import approximation as approx
&gt;&gt;&gt; G = nx.DiGraph()
&gt;&gt;&gt; G.add_weighted_edges_from({
...     ("A", "B", 3), ("A", "C", 17), ("A", "D", 14), ("B", "A", 3),
...     ("B", "C", 12), ("B", "D", 16), ("C", "A", 13),("C", "B", 12),
...     ("C", "D", 4), ("D", "A", 14), ("D", "B", 15), ("D", "C", 2)
... })
&gt;&gt;&gt; cycle = approx.threshold_accepting_tsp(G, "greedy", source="D")
&gt;&gt;&gt; cost = sum(G[n][nbr]["weight"] for n, nbr in nx.utils.pairwise(cycle))
&gt;&gt;&gt; cycle
['D', 'C', 'B', 'A', 'D']
&gt;&gt;&gt; cost
31
&gt;&gt;&gt; incycle = ["D", "B", "A", "C", "D"]
&gt;&gt;&gt; cycle = approx.threshold_accepting_tsp(G, incycle, source="D")
&gt;&gt;&gt; cost = sum(G[n][nbr]["weight"] for n, nbr in nx.utils.pairwise(cycle))
&gt;&gt;&gt; cycle
['D', 'C', 'B', 'A', 'D']
&gt;&gt;&gt; cost
31

Notes
-----
Threshold Accepting is a metaheuristic local search algorithm.
The main characteristic of this algorithm is that it accepts
even solutions which lead to the increase of the cost in order
to escape from low quality local optimal solutions.

This algorithm needs an initial solution. This solution can be
constructed by a simple greedy algorithm. At every iteration, it
selects thoughtfully a neighbor solution.
Consider $c(x)$ cost of current solution and $c(x')$ cost of
neighbor solution.
If $c(x') - c(x) &lt;= threshold$ then the neighbor solution becomes the current
solution for the next iteration, where the threshold is named threshold.

In comparison to the Simulated Annealing algorithm, the Threshold
Accepting algorithm does not accept very low quality solutions
(due to the presence of the threshold value). In the case of
Simulated Annealing, even a very low quality solution can
be accepted with probability $p$.

Time complexity:
It has a running time $O(m * n * |V|)$ where $m$ and $n$ are the number
of times the outer and inner loop run respectively.

For more information and how algorithm is inspired see:
https://doi.org/10.1016/0021-9991(90)90201-B

See Also
--------
simulated_annealing_tsp</pre> 
</div>
</div>
<a id="a2c82677b10d52786a34aa0ea42f8b1d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c82677b10d52786a34aa0ea42f8b1d2">&#9670;&nbsp;</a></span>traveling_salesman_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.approximation.traveling_salesman.traveling_salesman_problem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nodes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cycle</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find the shortest path in `G` connecting specified nodes

This function allows approximate solution to the traveling salesman
problem on networks that are not complete graphs and/or where the
salesman does not need to visit all nodes.

This function proceeds in two steps. First, it creates a complete
graph using the all-pairs shortest_paths between nodes in `nodes`.
Edge weights in the new graph are the lengths of the paths
between each pair of nodes in the original graph.
Second, an algorithm (default: `christofides`) is used to approximate
the minimal Hamiltonian cycle on this new graph. The available
algorithms are:

 - christofides
 - greedy_tsp
 - simulated_annealing_tsp
 - threshold_accepting_tsp

Once the Hamiltonian Cycle is found, this function post-processes to
accommodate the structure of the original graph. If `cycle` is ``False``,
the biggest weight edge is removed to make a Hamiltonian path.
Then each edge on the new complete graph used for that analysis is
replaced by the shortest_path between those nodes on the original graph.

Parameters
----------
G : NetworkX graph
    Undirected possibly weighted graph

nodes : collection of nodes (default=G.nodes)
    collection (list, set, etc.) of nodes to visit

weight : string, optional (default="weight")
    Edge data key corresponding to the edge weight.
    If any edge does not have this attribute the weight is set to 1.

cycle : bool (default: True)
    Indicates whether a cycle should be returned, or a path.
    Note: the cycle is the approximate minimal cycle.
    The path simply removes the biggest edge in that cycle.

method : function (default: None)
    A function that returns a cycle on all nodes and approximates
    the solution to the traveling salesman problem on a complete
    graph. The returned cycle is then used to find a corresponding
    solution on `G`. `method` should be callable; take inputs
    `G`, and `weight`; and return a list of nodes along the cycle.

    Provided options include :func:`christofides`, :func:`greedy_tsp`,
    :func:`simulated_annealing_tsp` and :func:`threshold_accepting_tsp`.

    If `method is None`: use :func:`christofides` for undirected `G` and
    :func:`threshold_accepting_tsp` for directed `G`.

    To specify parameters for these provided functions, construct lambda
    functions that state the specific value. `method` must have 2 inputs.
    (See examples).

Returns
-------
list
    List of nodes in `G` along a path with a 3/2-approximation of the minimal
    path through `nodes`.

Examples
--------
&gt;&gt;&gt; tsp = nx.approximation.traveling_salesman_problem
&gt;&gt;&gt; G = nx.cycle_graph(9)
&gt;&gt;&gt; G[4][5]["weight"] = 5  # all other weights are 1
&gt;&gt;&gt; tsp(G, nodes=[3, 6])
[3, 2, 1, 0, 8, 7, 6, 7, 8, 0, 1, 2, 3]
&gt;&gt;&gt; path = tsp(G, cycle=False)
&gt;&gt;&gt; path in ([4, 3, 2, 1, 0, 8, 7, 6, 5], [5, 6, 7, 8, 0, 1, 2, 3, 4])
True

Build (curry) your own function to provide parameter values to the methods.

&gt;&gt;&gt; SA_tsp = nx.approximation.simulated_annealing_tsp
&gt;&gt;&gt; method = lambda G, wt: SA_tsp(G, "greedy", weight=wt, temp=500)
&gt;&gt;&gt; path = tsp(G, cycle=False, method=method)
&gt;&gt;&gt; path in ([4, 3, 2, 1, 0, 8, 7, 6, 5], [5, 6, 7, 8, 0, 1, 2, 3, 4])
True</pre> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
