<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: networkx.algorithms.bipartite.matching Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenetworkx.html">networkx</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms.html">algorithms</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite.html">bipartite</a></li><li class="navelem"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1matching.html">matching</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">networkx.algorithms.bipartite.matching Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a33efdccdbaa981ba4a114541761fb22e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1matching.html#a33efdccdbaa981ba4a114541761fb22e">hopcroft_karp_matching</a> (G, top_nodes=None)</td></tr>
<tr class="separator:a33efdccdbaa981ba4a114541761fb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01b7d4fca81449c710c8dc4a14bed5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1matching.html#a4e01b7d4fca81449c710c8dc4a14bed5">eppstein_matching</a> (G, top_nodes=None)</td></tr>
<tr class="separator:a4e01b7d4fca81449c710c8dc4a14bed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c6a1cdd9dd0838060648c8b5cf0514"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1matching.html#a96c6a1cdd9dd0838060648c8b5cf0514">to_vertex_cover</a> (G, matching, top_nodes=None)</td></tr>
<tr class="separator:a96c6a1cdd9dd0838060648c8b5cf0514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618396f60731ee676163c1c6899dcf91"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1matching.html#a618396f60731ee676163c1c6899dcf91">minimum_weight_full_matching</a> (G, top_nodes=None, weight=&quot;weight&quot;)</td></tr>
<tr class="separator:a618396f60731ee676163c1c6899dcf91"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a785e6e3cbcaf6e38680ba55e563bb91b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1matching.html#a785e6e3cbcaf6e38680ba55e563bb91b">INFINITY</a></td></tr>
<tr class="separator:a785e6e3cbcaf6e38680ba55e563bb91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e09b799c5153f2b1b4d589e8b80118"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenetworkx_1_1algorithms_1_1bipartite_1_1matching.html#a87e09b799c5153f2b1b4d589e8b80118">maximum_matching</a></td></tr>
<tr class="separator:a87e09b799c5153f2b1b4d589e8b80118"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4e01b7d4fca81449c710c8dc4a14bed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e01b7d4fca81449c710c8dc4a14bed5">&#9670;&nbsp;</a></span>eppstein_matching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.matching.eppstein_matching </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>top_nodes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the maximum cardinality matching of the bipartite graph `G`.

Parameters
----------
G : NetworkX graph

  Undirected bipartite graph

top_nodes : container

  Container with all nodes in one bipartite node set. If not supplied
  it will be computed. But if more than one solution exists an exception
  will be raised.

Returns
-------
matches : dictionary

  The matching is returned as a dictionary, `matching`, such that
  ``matching[v] == w`` if node `v` is matched to node `w`. Unmatched
  nodes do not occur as a key in `matching`.

Raises
------
AmbiguousSolution
  Raised if the input bipartite graph is disconnected and no container
  with all nodes in one bipartite set is provided. When determining
  the nodes in each bipartite set more than one valid solution is
  possible if the input graph is disconnected.

Notes
-----
This function is implemented with David Eppstein's version of the algorithm
Hopcroft--Karp algorithm (see :func:`hopcroft_karp_matching`), which
originally appeared in the `Python Algorithms and Data Structures library
(PADS) &lt;http://www.ics.uci.edu/~eppstein/PADS/ABOUT-PADS.txt&gt;`_.

See :mod:`bipartite documentation &lt;networkx.algorithms.bipartite&gt;`
for further details on how bipartite graphs are handled in NetworkX.

See Also
--------

hopcroft_karp_matching</pre> 
</div>
</div>
<a id="a33efdccdbaa981ba4a114541761fb22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33efdccdbaa981ba4a114541761fb22e">&#9670;&nbsp;</a></span>hopcroft_karp_matching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.matching.hopcroft_karp_matching </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>top_nodes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the maximum cardinality matching of the bipartite graph `G`.

A matching is a set of edges that do not share any nodes. A maximum
cardinality matching is a matching with the most edges possible. It
is not always unique. Finding a matching in a bipartite graph can be
treated as a networkx flow problem.

The functions ``hopcroft_karp_matching`` and ``maximum_matching``
are aliases of the same function.

Parameters
----------
G : NetworkX graph

  Undirected bipartite graph

top_nodes : container of nodes

  Container with all nodes in one bipartite node set. If not supplied
  it will be computed. But if more than one solution exists an exception
  will be raised.

Returns
-------
matches : dictionary

  The matching is returned as a dictionary, `matches`, such that
  ``matches[v] == w`` if node `v` is matched to node `w`. Unmatched
  nodes do not occur as a key in `matches`.

Raises
------
AmbiguousSolution
  Raised if the input bipartite graph is disconnected and no container
  with all nodes in one bipartite set is provided. When determining
  the nodes in each bipartite set more than one valid solution is
  possible if the input graph is disconnected.

Notes
-----
This function is implemented with the `Hopcroft--Karp matching algorithm
&lt;https://en.wikipedia.org/wiki/Hopcroft%E2%80%93Karp_algorithm&gt;`_ for
bipartite graphs.

See :mod:`bipartite documentation &lt;networkx.algorithms.bipartite&gt;`
for further details on how bipartite graphs are handled in NetworkX.

See Also
--------
maximum_matching
hopcroft_karp_matching
eppstein_matching

References
----------
.. [1] John E. Hopcroft and Richard M. Karp. "An n^{5 / 2} Algorithm for
   Maximum Matchings in Bipartite Graphs" In: **SIAM Journal of Computing**
   2.4 (1973), pp. 225--231. &lt;https://doi.org/10.1137/0202019&gt;.</pre> 
</div>
</div>
<a id="a618396f60731ee676163c1c6899dcf91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618396f60731ee676163c1c6899dcf91">&#9670;&nbsp;</a></span>minimum_weight_full_matching()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.matching.minimum_weight_full_matching </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>top_nodes</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>&quot;weight&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns a minimum weight full matching of the bipartite graph `G`.

Let :math:`G = ((U, V), E)` be a weighted bipartite graph with real weights
:math:`w : E \to \mathbb{R}`. This function then produces a matching
:math:`M \subseteq E` with cardinality

.. math::
   \lvert M \rvert = \min(\lvert U \rvert, \lvert V \rvert),

which minimizes the sum of the weights of the edges included in the
matching, :math:`\sum_{e \in M} w(e)`, or raises an error if no such
matching exists.

When :math:`\lvert U \rvert = \lvert V \rvert`, this is commonly
referred to as a perfect matching; here, since we allow
:math:`\lvert U \rvert` and :math:`\lvert V \rvert` to differ, we
follow Karp [1]_ and refer to the matching as *full*.

Parameters
----------
G : NetworkX graph

  Undirected bipartite graph

top_nodes : container

  Container with all nodes in one bipartite node set. If not supplied
  it will be computed.

weight : string, optional (default='weight')

   The edge data key used to provide each value in the matrix.

Returns
-------
matches : dictionary

  The matching is returned as a dictionary, `matches`, such that
  ``matches[v] == w`` if node `v` is matched to node `w`. Unmatched
  nodes do not occur as a key in `matches`.

Raises
------
ValueError
  Raised if no full matching exists.

ImportError
  Raised if SciPy is not available.

Notes
-----
The problem of determining a minimum weight full matching is also known as
the rectangular linear assignment problem. This implementation defers the
calculation of the assignment to SciPy.

References
----------
.. [1] Richard Manning Karp:
   An algorithm to Solve the m x n Assignment Problem in Expected Time
   O(mn log n).
   Networks, 10(2):143–152, 1980.</pre> 
</div>
</div>
<a id="a96c6a1cdd9dd0838060648c8b5cf0514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c6a1cdd9dd0838060648c8b5cf0514">&#9670;&nbsp;</a></span>to_vertex_cover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def networkx.algorithms.bipartite.matching.to_vertex_cover </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matching</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>top_nodes</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the minimum vertex cover corresponding to the given maximum
matching of the bipartite graph `G`.

Parameters
----------
G : NetworkX graph

  Undirected bipartite graph

matching : dictionary

  A dictionary whose keys are vertices in `G` and whose values are the
  distinct neighbors comprising the maximum matching for `G`, as returned
  by, for example, :func:`maximum_matching`. The dictionary *must*
  represent the maximum matching.

top_nodes : container

  Container with all nodes in one bipartite node set. If not supplied
  it will be computed. But if more than one solution exists an exception
  will be raised.

Returns
-------
vertex_cover : :class:`set`

  The minimum vertex cover in `G`.

Raises
------
AmbiguousSolution
  Raised if the input bipartite graph is disconnected and no container
  with all nodes in one bipartite set is provided. When determining
  the nodes in each bipartite set more than one valid solution is
  possible if the input graph is disconnected.

Notes
-----
This function is implemented using the procedure guaranteed by `Konig's
theorem
&lt;https://en.wikipedia.org/wiki/K%C3%B6nig%27s_theorem_%28graph_theory%29&gt;`_,
which proves an equivalence between a maximum matching and a minimum vertex
cover in bipartite graphs.

Since a minimum vertex cover is the complement of a maximum independent set
for any graph, one can compute the maximum independent set of a bipartite
graph this way:

&gt;&gt;&gt; G = nx.complete_bipartite_graph(2, 3)
&gt;&gt;&gt; matching = nx.bipartite.maximum_matching(G)
&gt;&gt;&gt; vertex_cover = nx.bipartite.to_vertex_cover(G, matching)
&gt;&gt;&gt; independent_set = set(G) - vertex_cover
&gt;&gt;&gt; print(list(independent_set))
[2, 3, 4]

See :mod:`bipartite documentation &lt;networkx.algorithms.bipartite&gt;`
for further details on how bipartite graphs are handled in NetworkX.</pre> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a785e6e3cbcaf6e38680ba55e563bb91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785e6e3cbcaf6e38680ba55e563bb91b">&#9670;&nbsp;</a></span>INFINITY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">networkx.algorithms.bipartite.matching.INFINITY</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87e09b799c5153f2b1b4d589e8b80118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e09b799c5153f2b1b4d589e8b80118">&#9670;&nbsp;</a></span>maximum_matching</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">networkx.algorithms.bipartite.matching.maximum_matching</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
